(() => {
  var __defProp = Object.defineProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // node_modules/@waxio/waxjs/node_modules/eosjs/dist/ripemd.js
  var require_ripemd = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/dist/ripemd.js"(exports, module) {
      "use strict";
      var _slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var RIPEMD160 = function() {
        function RIPEMD1602() {
          _classCallCheck(this, RIPEMD1602);
        }
        _createClass(RIPEMD1602, null, [{
          key: "get_n_pad_bytes",
          value: function get_n_pad_bytes(message_size) {
            return 64 - (message_size + 8 & 63);
          }
        }, {
          key: "pad",
          value: function pad(message) {
            var message_size = message.byteLength;
            var n_pad = RIPEMD1602.get_n_pad_bytes(message_size);
            var divmod = function divmod2(dividend, divisor) {
              return [Math.floor(dividend / divisor), dividend % divisor];
            };
            var _divmod$map = divmod(message_size, 536870912).map(function(x, index) {
              return index ? x * 8 : x;
            }), _divmod$map2 = _slicedToArray(_divmod$map, 2), msg_bit_size_most = _divmod$map2[0], msg_bit_size_least = _divmod$map2[1];
            var padded = new Uint8Array(message_size + n_pad + 8);
            padded.set(new Uint8Array(message), 0);
            var data_view = new DataView(padded.buffer);
            data_view.setUint8(message_size, 128);
            data_view.setUint32(message_size + n_pad, msg_bit_size_least, true);
            data_view.setUint32(message_size + n_pad + 4, msg_bit_size_most, true);
            return padded.buffer;
          }
        }, {
          key: "f",
          value: function f2(j, x, y, z) {
            if (0 <= j && j <= 15) {
              return x ^ y ^ z;
            }
            if (16 <= j && j <= 31) {
              return x & y | ~x & z;
            }
            if (32 <= j && j <= 47) {
              return (x | ~y) ^ z;
            }
            if (48 <= j && j <= 63) {
              return x & z | y & ~z;
            }
            if (64 <= j && j <= 79) {
              return x ^ (y | ~z);
            }
          }
        }, {
          key: "K",
          value: function K(j) {
            if (0 <= j && j <= 15) {
              return 0;
            }
            if (16 <= j && j <= 31) {
              return 1518500249;
            }
            if (32 <= j && j <= 47) {
              return 1859775393;
            }
            if (48 <= j && j <= 63) {
              return 2400959708;
            }
            if (64 <= j && j <= 79) {
              return 2840853838;
            }
          }
        }, {
          key: "KP",
          value: function KP(j) {
            if (0 <= j && j <= 15) {
              return 1352829926;
            }
            if (16 <= j && j <= 31) {
              return 1548603684;
            }
            if (32 <= j && j <= 47) {
              return 1836072691;
            }
            if (48 <= j && j <= 63) {
              return 2053994217;
            }
            if (64 <= j && j <= 79) {
              return 0;
            }
          }
        }, {
          key: "add_modulo32",
          value: function add_modulo32() {
            return Array.from(arguments).reduce(function(a, b) {
              return a + b;
            }, 0) | 0;
          }
        }, {
          key: "rol32",
          value: function rol32(value, count) {
            return value << count | value >>> 32 - count;
          }
        }, {
          key: "hash",
          value: function hash(message) {
            var padded = RIPEMD1602.pad(message);
            var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
            var rP = [
              5,
              14,
              7,
              0,
              9,
              2,
              11,
              4,
              13,
              6,
              15,
              8,
              1,
              10,
              3,
              12,
              6,
              11,
              3,
              7,
              0,
              13,
              5,
              10,
              14,
              15,
              8,
              12,
              4,
              9,
              1,
              2,
              15,
              5,
              1,
              3,
              7,
              14,
              6,
              9,
              11,
              8,
              12,
              2,
              10,
              0,
              4,
              13,
              8,
              6,
              4,
              1,
              3,
              11,
              15,
              0,
              5,
              12,
              2,
              13,
              9,
              7,
              10,
              14,
              12,
              15,
              10,
              4,
              1,
              5,
              8,
              7,
              6,
              2,
              13,
              14,
              0,
              3,
              9,
              11
            ];
            var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
            var sP = [
              8,
              9,
              9,
              11,
              13,
              15,
              15,
              5,
              7,
              7,
              8,
              11,
              14,
              14,
              12,
              6,
              9,
              13,
              15,
              7,
              12,
              8,
              9,
              11,
              7,
              7,
              12,
              7,
              6,
              15,
              13,
              11,
              9,
              7,
              15,
              11,
              8,
              6,
              6,
              14,
              12,
              13,
              5,
              14,
              13,
              13,
              7,
              5,
              15,
              5,
              8,
              11,
              14,
              14,
              6,
              14,
              6,
              9,
              12,
              9,
              12,
              5,
              15,
              8,
              8,
              5,
              12,
              9,
              12,
              5,
              14,
              6,
              8,
              13,
              6,
              5,
              15,
              13,
              11,
              11
            ];
            var word_size = 4;
            var block_size = 64;
            var t = padded.byteLength / block_size;
            var X = new Array(t).fill(void 0).map(function(_, i2) {
              return function(j2) {
                return new DataView(padded, i2 * block_size, block_size).getUint32(j2 * word_size, true);
              };
            });
            var h = [
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ];
            for (var i = 0; i < t; ++i) {
              var A = h[0], B = h[1], C = h[2], D = h[3], E = h[4];
              var AP = A, BP = B, CP = C, DP = D, EP = E;
              for (var j = 0; j < 80; ++j) {
                var _T = RIPEMD1602.add_modulo32(RIPEMD1602.rol32(RIPEMD1602.add_modulo32(A, RIPEMD1602.f(j, B, C, D), X[i](r[j]), RIPEMD1602.K(j)), s[j]), E);
                A = E;
                E = D;
                D = RIPEMD1602.rol32(C, 10);
                C = B;
                B = _T;
                _T = RIPEMD1602.add_modulo32(RIPEMD1602.rol32(RIPEMD1602.add_modulo32(AP, RIPEMD1602.f(79 - j, BP, CP, DP), X[i](rP[j]), RIPEMD1602.KP(j)), sP[j]), EP);
                AP = EP;
                EP = DP;
                DP = RIPEMD1602.rol32(CP, 10);
                CP = BP;
                BP = _T;
              }
              var T = RIPEMD1602.add_modulo32(h[1], C, DP);
              h[1] = RIPEMD1602.add_modulo32(h[2], D, EP);
              h[2] = RIPEMD1602.add_modulo32(h[3], E, AP);
              h[3] = RIPEMD1602.add_modulo32(h[4], A, BP);
              h[4] = RIPEMD1602.add_modulo32(h[0], B, CP);
              h[0] = T;
            }
            var result = new ArrayBuffer(20);
            var data_view = new DataView(result);
            h.forEach(function(h_i, i2) {
              return data_view.setUint32(i2 * 4, h_i, true);
            });
            return result;
          }
        }]);
        return RIPEMD1602;
      }();
      module.exports = {
        RIPEMD160
      };
    }
  });

  // node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-numeric.js
  var require_eosjs_numeric = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-numeric.js"(exports) {
      "use strict";
      var __read = exports && exports.__read || function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      var __spread = exports && exports.__spread || function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      var __values = exports && exports.__values || function(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
          return m.call(o);
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var ripemd160 = require_ripemd().RIPEMD160.hash;
      var base58Chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      function create_base58_map() {
        var base58M = Array(256).fill(-1);
        for (var i = 0; i < base58Chars.length; ++i) {
          base58M[base58Chars.charCodeAt(i)] = i;
        }
        return base58M;
      }
      var base58Map = create_base58_map();
      function create_base64_map() {
        var base64M = Array(256).fill(-1);
        for (var i = 0; i < base64Chars.length; ++i) {
          base64M[base64Chars.charCodeAt(i)] = i;
        }
        base64M["=".charCodeAt(0)] = 0;
        return base64M;
      }
      var base64Map = create_base64_map();
      function isNegative(bignum) {
        return (bignum[bignum.length - 1] & 128) !== 0;
      }
      exports.isNegative = isNegative;
      function negate(bignum) {
        var carry = 1;
        for (var i = 0; i < bignum.length; ++i) {
          var x = (~bignum[i] & 255) + carry;
          bignum[i] = x;
          carry = x >> 8;
        }
      }
      exports.negate = negate;
      function decimalToBinary(size, s) {
        var result = new Uint8Array(size);
        for (var i = 0; i < s.length; ++i) {
          var srcDigit = s.charCodeAt(i);
          if (srcDigit < "0".charCodeAt(0) || srcDigit > "9".charCodeAt(0)) {
            throw new Error("invalid number");
          }
          var carry = srcDigit - "0".charCodeAt(0);
          for (var j = 0; j < size; ++j) {
            var x = result[j] * 10 + carry;
            result[j] = x;
            carry = x >> 8;
          }
          if (carry) {
            throw new Error("number is out of range");
          }
        }
        return result;
      }
      exports.decimalToBinary = decimalToBinary;
      function signedDecimalToBinary(size, s) {
        var negative = s[0] === "-";
        if (negative) {
          s = s.substr(1);
        }
        var result = decimalToBinary(size, s);
        if (negative) {
          negate(result);
          if (!isNegative(result)) {
            throw new Error("number is out of range");
          }
        } else if (isNegative(result)) {
          throw new Error("number is out of range");
        }
        return result;
      }
      exports.signedDecimalToBinary = signedDecimalToBinary;
      function binaryToDecimal(bignum, minDigits) {
        if (minDigits === void 0) {
          minDigits = 1;
        }
        var result = Array(minDigits).fill("0".charCodeAt(0));
        for (var i = bignum.length - 1; i >= 0; --i) {
          var carry = bignum[i];
          for (var j = 0; j < result.length; ++j) {
            var x = (result[j] - "0".charCodeAt(0) << 8) + carry;
            result[j] = "0".charCodeAt(0) + x % 10;
            carry = x / 10 | 0;
          }
          while (carry) {
            result.push("0".charCodeAt(0) + carry % 10);
            carry = carry / 10 | 0;
          }
        }
        result.reverse();
        return String.fromCharCode.apply(String, __spread(result));
      }
      exports.binaryToDecimal = binaryToDecimal;
      function signedBinaryToDecimal(bignum, minDigits) {
        if (minDigits === void 0) {
          minDigits = 1;
        }
        if (isNegative(bignum)) {
          var x = bignum.slice();
          negate(x);
          return "-" + binaryToDecimal(x, minDigits);
        }
        return binaryToDecimal(bignum, minDigits);
      }
      exports.signedBinaryToDecimal = signedBinaryToDecimal;
      function base58ToBinary(size, s) {
        var result = new Uint8Array(size);
        for (var i = 0; i < s.length; ++i) {
          var carry = base58Map[s.charCodeAt(i)];
          if (carry < 0) {
            throw new Error("invalid base-58 value");
          }
          for (var j = 0; j < size; ++j) {
            var x = result[j] * 58 + carry;
            result[j] = x;
            carry = x >> 8;
          }
          if (carry) {
            throw new Error("base-58 value is out of range");
          }
        }
        result.reverse();
        return result;
      }
      exports.base58ToBinary = base58ToBinary;
      function binaryToBase58(bignum, minDigits) {
        if (minDigits === void 0) {
          minDigits = 1;
        }
        var e_1, _a, e_2, _b;
        var result = [];
        try {
          for (var bignum_1 = __values(bignum), bignum_1_1 = bignum_1.next(); !bignum_1_1.done; bignum_1_1 = bignum_1.next()) {
            var byte = bignum_1_1.value;
            var carry = byte;
            for (var j = 0; j < result.length; ++j) {
              var x = (base58Map[result[j]] << 8) + carry;
              result[j] = base58Chars.charCodeAt(x % 58);
              carry = x / 58 | 0;
            }
            while (carry) {
              result.push(base58Chars.charCodeAt(carry % 58));
              carry = carry / 58 | 0;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (bignum_1_1 && !bignum_1_1.done && (_a = bignum_1.return))
              _a.call(bignum_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        try {
          for (var bignum_2 = __values(bignum), bignum_2_1 = bignum_2.next(); !bignum_2_1.done; bignum_2_1 = bignum_2.next()) {
            var byte = bignum_2_1.value;
            if (byte) {
              break;
            } else {
              result.push("1".charCodeAt(0));
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (bignum_2_1 && !bignum_2_1.done && (_b = bignum_2.return))
              _b.call(bignum_2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        result.reverse();
        return String.fromCharCode.apply(String, __spread(result));
      }
      exports.binaryToBase58 = binaryToBase58;
      function base64ToBinary(s) {
        var len = s.length;
        if ((len & 3) === 1 && s[len - 1] === "=") {
          len -= 1;
        }
        if ((len & 3) !== 0) {
          throw new Error("base-64 value is not padded correctly");
        }
        var groups = len >> 2;
        var bytes = groups * 3;
        if (len > 0 && s[len - 1] === "=") {
          if (s[len - 2] === "=") {
            bytes -= 2;
          } else {
            bytes -= 1;
          }
        }
        var result = new Uint8Array(bytes);
        for (var group = 0; group < groups; ++group) {
          var digit0 = base64Map[s.charCodeAt(group * 4 + 0)];
          var digit1 = base64Map[s.charCodeAt(group * 4 + 1)];
          var digit2 = base64Map[s.charCodeAt(group * 4 + 2)];
          var digit3 = base64Map[s.charCodeAt(group * 4 + 3)];
          result[group * 3 + 0] = digit0 << 2 | digit1 >> 4;
          if (group * 3 + 1 < bytes) {
            result[group * 3 + 1] = (digit1 & 15) << 4 | digit2 >> 2;
          }
          if (group * 3 + 2 < bytes) {
            result[group * 3 + 2] = (digit2 & 3) << 6 | digit3;
          }
        }
        return result;
      }
      exports.base64ToBinary = base64ToBinary;
      var KeyType;
      (function(KeyType2) {
        KeyType2[KeyType2["k1"] = 0] = "k1";
        KeyType2[KeyType2["r1"] = 1] = "r1";
      })(KeyType = exports.KeyType || (exports.KeyType = {}));
      exports.publicKeyDataSize = 33;
      exports.privateKeyDataSize = 32;
      exports.signatureDataSize = 65;
      function digestSuffixRipemd160(data, suffix) {
        var d = new Uint8Array(data.length + suffix.length);
        for (var i = 0; i < data.length; ++i) {
          d[i] = data[i];
        }
        for (var i = 0; i < suffix.length; ++i) {
          d[data.length + i] = suffix.charCodeAt(i);
        }
        return ripemd160(d);
      }
      function stringToKey(s, type, size, suffix) {
        var whole = base58ToBinary(size + 4, s);
        var result = { type, data: new Uint8Array(whole.buffer, 0, size) };
        var digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));
        if (digest[0] !== whole[size + 0] || digest[1] !== whole[size + 1] || digest[2] !== whole[size + 2] || digest[3] !== whole[size + 3]) {
          throw new Error("checksum doesn't match");
        }
        return result;
      }
      function keyToString(key, suffix, prefix) {
        var digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));
        var whole = new Uint8Array(key.data.length + 4);
        for (var i = 0; i < key.data.length; ++i) {
          whole[i] = key.data[i];
        }
        for (var i = 0; i < 4; ++i) {
          whole[i + key.data.length] = digest[i];
        }
        return prefix + binaryToBase58(whole);
      }
      function stringToPublicKey(s) {
        if (typeof s !== "string") {
          throw new Error("expected string containing public key");
        }
        if (s.substr(0, 3) === "EOS") {
          var whole = base58ToBinary(exports.publicKeyDataSize + 4, s.substr(3));
          var key = { type: KeyType.k1, data: new Uint8Array(exports.publicKeyDataSize) };
          for (var i = 0; i < exports.publicKeyDataSize; ++i) {
            key.data[i] = whole[i];
          }
          var digest = new Uint8Array(ripemd160(key.data));
          if (digest[0] !== whole[exports.publicKeyDataSize] || digest[1] !== whole[34] || digest[2] !== whole[35] || digest[3] !== whole[36]) {
            throw new Error("checksum doesn't match");
          }
          return key;
        } else if (s.substr(0, 7) === "PUB_K1_") {
          return stringToKey(s.substr(7), KeyType.k1, exports.publicKeyDataSize, "K1");
        } else if (s.substr(0, 7) === "PUB_R1_") {
          return stringToKey(s.substr(7), KeyType.r1, exports.publicKeyDataSize, "R1");
        } else {
          throw new Error("unrecognized public key format");
        }
      }
      exports.stringToPublicKey = stringToPublicKey;
      function publicKeyToString(key) {
        if (key.type === KeyType.k1 && key.data.length === exports.publicKeyDataSize) {
          return keyToString(key, "K1", "PUB_K1_");
        } else if (key.type === KeyType.r1 && key.data.length === exports.publicKeyDataSize) {
          return keyToString(key, "R1", "PUB_R1_");
        } else {
          throw new Error("unrecognized public key format");
        }
      }
      exports.publicKeyToString = publicKeyToString;
      function convertLegacyPublicKey(s) {
        if (s.substr(0, 3) === "EOS") {
          return publicKeyToString(stringToPublicKey(s));
        }
        return s;
      }
      exports.convertLegacyPublicKey = convertLegacyPublicKey;
      function convertLegacyPublicKeys(keys) {
        return keys.map(convertLegacyPublicKey);
      }
      exports.convertLegacyPublicKeys = convertLegacyPublicKeys;
      function stringToPrivateKey(s) {
        if (typeof s !== "string") {
          throw new Error("expected string containing private key");
        }
        if (s.substr(0, 7) === "PVT_R1_") {
          return stringToKey(s.substr(7), KeyType.r1, exports.privateKeyDataSize, "R1");
        } else {
          throw new Error("unrecognized private key format");
        }
      }
      exports.stringToPrivateKey = stringToPrivateKey;
      function privateKeyToString(key) {
        if (key.type === KeyType.r1) {
          return keyToString(key, "R1", "PVT_R1_");
        } else {
          throw new Error("unrecognized private key format");
        }
      }
      exports.privateKeyToString = privateKeyToString;
      function stringToSignature(s) {
        if (typeof s !== "string") {
          throw new Error("expected string containing signature");
        }
        if (s.substr(0, 7) === "SIG_K1_") {
          return stringToKey(s.substr(7), KeyType.k1, exports.signatureDataSize, "K1");
        } else if (s.substr(0, 7) === "SIG_R1_") {
          return stringToKey(s.substr(7), KeyType.r1, exports.signatureDataSize, "R1");
        } else {
          throw new Error("unrecognized signature format");
        }
      }
      exports.stringToSignature = stringToSignature;
      function signatureToString(signature) {
        if (signature.type === KeyType.k1) {
          return keyToString(signature, "K1", "SIG_K1_");
        } else if (signature.type === KeyType.r1) {
          return keyToString(signature, "R1", "SIG_R1_");
        } else {
          throw new Error("unrecognized signature format");
        }
      }
      exports.signatureToString = signatureToString;
    }
  });

  // node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-serialize.js
  var require_eosjs_serialize = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-serialize.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __read = exports && exports.__read || function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      var __spread = exports && exports.__spread || function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      var __values = exports && exports.__values || function(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
          return m.call(o);
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var numeric = require_eosjs_numeric();
      var SerializerState = function() {
        function SerializerState2(options) {
          if (options === void 0) {
            options = {};
          }
          this.skippedBinaryExtension = false;
          this.options = options;
        }
        return SerializerState2;
      }();
      exports.SerializerState = SerializerState;
      var SerialBuffer = function() {
        function SerialBuffer2(_a) {
          var _b = _a === void 0 ? {} : _a, textEncoder = _b.textEncoder, textDecoder = _b.textDecoder, array = _b.array;
          this.readPos = 0;
          this.array = array || new Uint8Array(1024);
          this.length = array ? array.length : 0;
          this.textEncoder = textEncoder || new TextEncoder();
          this.textDecoder = textDecoder || new TextDecoder("utf-8", { fatal: true });
        }
        SerialBuffer2.prototype.reserve = function(size) {
          if (this.length + size <= this.array.length) {
            return;
          }
          var l = this.array.length;
          while (this.length + size > l) {
            l = Math.ceil(l * 1.5);
          }
          var newArray = new Uint8Array(l);
          newArray.set(this.array);
          this.array = newArray;
        };
        SerialBuffer2.prototype.haveReadData = function() {
          return this.readPos < this.length;
        };
        SerialBuffer2.prototype.restartRead = function() {
          this.readPos = 0;
        };
        SerialBuffer2.prototype.asUint8Array = function() {
          return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);
        };
        SerialBuffer2.prototype.pushArray = function(v) {
          this.reserve(v.length);
          this.array.set(v, this.length);
          this.length += v.length;
        };
        SerialBuffer2.prototype.push = function() {
          var v = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            v[_i] = arguments[_i];
          }
          this.pushArray(v);
        };
        SerialBuffer2.prototype.get = function() {
          if (this.readPos < this.length) {
            return this.array[this.readPos++];
          }
          throw new Error("Read past end of buffer");
        };
        SerialBuffer2.prototype.pushUint8ArrayChecked = function(v, len) {
          if (v.length !== len) {
            throw new Error("Binary data has incorrect size");
          }
          this.pushArray(v);
        };
        SerialBuffer2.prototype.getUint8Array = function(len) {
          if (this.readPos + len > this.length) {
            throw new Error("Read past end of buffer");
          }
          var result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);
          this.readPos += len;
          return result;
        };
        SerialBuffer2.prototype.pushUint16 = function(v) {
          this.push(v >> 0 & 255, v >> 8 & 255);
        };
        SerialBuffer2.prototype.getUint16 = function() {
          var v = 0;
          v |= this.get() << 0;
          v |= this.get() << 8;
          return v;
        };
        SerialBuffer2.prototype.pushUint32 = function(v) {
          this.push(v >> 0 & 255, v >> 8 & 255, v >> 16 & 255, v >> 24 & 255);
        };
        SerialBuffer2.prototype.getUint32 = function() {
          var v = 0;
          v |= this.get() << 0;
          v |= this.get() << 8;
          v |= this.get() << 16;
          v |= this.get() << 24;
          return v >>> 0;
        };
        SerialBuffer2.prototype.pushNumberAsUint64 = function(v) {
          this.pushUint32(v >>> 0);
          this.pushUint32(Math.floor(v / 4294967296) >>> 0);
        };
        SerialBuffer2.prototype.getUint64AsNumber = function() {
          var low = this.getUint32();
          var high = this.getUint32();
          return (high >>> 0) * 4294967296 + (low >>> 0);
        };
        SerialBuffer2.prototype.pushVaruint32 = function(v) {
          while (true) {
            if (v >>> 7) {
              this.push(128 | v & 127);
              v = v >>> 7;
            } else {
              this.push(v);
              break;
            }
          }
        };
        SerialBuffer2.prototype.getVaruint32 = function() {
          var v = 0;
          var bit = 0;
          while (true) {
            var b = this.get();
            v |= (b & 127) << bit;
            bit += 7;
            if (!(b & 128)) {
              break;
            }
          }
          return v >>> 0;
        };
        SerialBuffer2.prototype.pushVarint32 = function(v) {
          this.pushVaruint32(v << 1 ^ v >> 31);
        };
        SerialBuffer2.prototype.getVarint32 = function() {
          var v = this.getVaruint32();
          if (v & 1) {
            return ~v >> 1 | 2147483648;
          } else {
            return v >>> 1;
          }
        };
        SerialBuffer2.prototype.pushFloat32 = function(v) {
          this.pushArray(new Uint8Array(new Float32Array([v]).buffer));
        };
        SerialBuffer2.prototype.getFloat32 = function() {
          return new Float32Array(this.getUint8Array(4).slice().buffer)[0];
        };
        SerialBuffer2.prototype.pushFloat64 = function(v) {
          this.pushArray(new Uint8Array(new Float64Array([v]).buffer));
        };
        SerialBuffer2.prototype.getFloat64 = function() {
          return new Float64Array(this.getUint8Array(8).slice().buffer)[0];
        };
        SerialBuffer2.prototype.pushName = function(s) {
          if (typeof s !== "string") {
            throw new Error("Expected string containing name");
          }
          function charToSymbol(c2) {
            if (c2 >= "a".charCodeAt(0) && c2 <= "z".charCodeAt(0)) {
              return c2 - "a".charCodeAt(0) + 6;
            }
            if (c2 >= "1".charCodeAt(0) && c2 <= "5".charCodeAt(0)) {
              return c2 - "1".charCodeAt(0) + 1;
            }
            return 0;
          }
          var a = new Uint8Array(8);
          var bit = 63;
          for (var i = 0; i < s.length; ++i) {
            var c = charToSymbol(s.charCodeAt(i));
            if (bit < 5) {
              c = c << 1;
            }
            for (var j = 4; j >= 0; --j) {
              if (bit >= 0) {
                a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;
                --bit;
              }
            }
          }
          this.pushArray(a);
        };
        SerialBuffer2.prototype.getName = function() {
          var a = this.getUint8Array(8);
          var result = "";
          for (var bit = 63; bit >= 0; ) {
            var c = 0;
            for (var i = 0; i < 5; ++i) {
              if (bit >= 0) {
                c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;
                --bit;
              }
            }
            if (c >= 6) {
              result += String.fromCharCode(c + "a".charCodeAt(0) - 6);
            } else if (c >= 1) {
              result += String.fromCharCode(c + "1".charCodeAt(0) - 1);
            } else {
              result += ".";
            }
          }
          while (result.endsWith(".")) {
            result = result.substr(0, result.length - 1);
          }
          return result;
        };
        SerialBuffer2.prototype.pushBytes = function(v) {
          this.pushVaruint32(v.length);
          this.pushArray(v);
        };
        SerialBuffer2.prototype.getBytes = function() {
          return this.getUint8Array(this.getVaruint32());
        };
        SerialBuffer2.prototype.pushString = function(v) {
          this.pushBytes(this.textEncoder.encode(v));
        };
        SerialBuffer2.prototype.getString = function() {
          return this.textDecoder.decode(this.getBytes());
        };
        SerialBuffer2.prototype.pushSymbolCode = function(name) {
          if (typeof name !== "string") {
            throw new Error("Expected string containing symbol_code");
          }
          var a = [];
          a.push.apply(a, __spread(this.textEncoder.encode(name)));
          while (a.length < 8) {
            a.push(0);
          }
          this.pushArray(a.slice(0, 8));
        };
        SerialBuffer2.prototype.getSymbolCode = function() {
          var a = this.getUint8Array(8);
          var len;
          for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
              break;
            }
          }
          var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
          return name;
        };
        SerialBuffer2.prototype.pushSymbol = function(_a) {
          var name = _a.name, precision = _a.precision;
          var a = [precision & 255];
          a.push.apply(a, __spread(this.textEncoder.encode(name)));
          while (a.length < 8) {
            a.push(0);
          }
          this.pushArray(a.slice(0, 8));
        };
        SerialBuffer2.prototype.getSymbol = function() {
          var precision = this.get();
          var a = this.getUint8Array(7);
          var len;
          for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
              break;
            }
          }
          var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
          return { name, precision };
        };
        SerialBuffer2.prototype.pushAsset = function(s) {
          if (typeof s !== "string") {
            throw new Error("Expected string containing asset");
          }
          s = s.trim();
          var pos = 0;
          var amount = "";
          var precision = 0;
          if (s[pos] === "-") {
            amount += "-";
            ++pos;
          }
          var foundDigit = false;
          while (pos < s.length && s.charCodeAt(pos) >= "0".charCodeAt(0) && s.charCodeAt(pos) <= "9".charCodeAt(0)) {
            foundDigit = true;
            amount += s[pos];
            ++pos;
          }
          if (!foundDigit) {
            throw new Error("Asset must begin with a number");
          }
          if (s[pos] === ".") {
            ++pos;
            while (pos < s.length && s.charCodeAt(pos) >= "0".charCodeAt(0) && s.charCodeAt(pos) <= "9".charCodeAt(0)) {
              amount += s[pos];
              ++precision;
              ++pos;
            }
          }
          var name = s.substr(pos).trim();
          this.pushArray(numeric.signedDecimalToBinary(8, amount));
          this.pushSymbol({ name, precision });
        };
        SerialBuffer2.prototype.getAsset = function() {
          var amount = this.getUint8Array(8);
          var _a = this.getSymbol(), name = _a.name, precision = _a.precision;
          var s = numeric.signedBinaryToDecimal(amount, precision + 1);
          if (precision) {
            s = s.substr(0, s.length - precision) + "." + s.substr(s.length - precision);
          }
          return s + " " + name;
        };
        SerialBuffer2.prototype.pushPublicKey = function(s) {
          var key = numeric.stringToPublicKey(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getPublicKey = function() {
          var type = this.get();
          var data = this.getUint8Array(numeric.publicKeyDataSize);
          return numeric.publicKeyToString({ type, data });
        };
        SerialBuffer2.prototype.pushPrivateKey = function(s) {
          var key = numeric.stringToPrivateKey(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getPrivateKey = function() {
          var type = this.get();
          var data = this.getUint8Array(numeric.privateKeyDataSize);
          return numeric.privateKeyToString({ type, data });
        };
        SerialBuffer2.prototype.pushSignature = function(s) {
          var key = numeric.stringToSignature(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getSignature = function() {
          var type = this.get();
          var data = this.getUint8Array(numeric.signatureDataSize);
          return numeric.signatureToString({ type, data });
        };
        return SerialBuffer2;
      }();
      exports.SerialBuffer = SerialBuffer;
      function supportedAbiVersion(version2) {
        return version2.startsWith("eosio::abi/1.");
      }
      exports.supportedAbiVersion = supportedAbiVersion;
      function checkDateParse(date) {
        var result = Date.parse(date);
        if (Number.isNaN(result)) {
          throw new Error("Invalid time format");
        }
        return result;
      }
      function dateToTimePoint(date) {
        return Math.round(checkDateParse(date + "Z") * 1e3);
      }
      exports.dateToTimePoint = dateToTimePoint;
      function timePointToDate(us) {
        var s = new Date(us / 1e3).toISOString();
        return s.substr(0, s.length - 1);
      }
      exports.timePointToDate = timePointToDate;
      function dateToTimePointSec(date) {
        return Math.round(checkDateParse(date + "Z") / 1e3);
      }
      exports.dateToTimePointSec = dateToTimePointSec;
      function timePointSecToDate(sec) {
        var s = new Date(sec * 1e3).toISOString();
        return s.substr(0, s.length - 1);
      }
      exports.timePointSecToDate = timePointSecToDate;
      function dateToBlockTimestamp(date) {
        return Math.round((checkDateParse(date + "Z") - 9466848e5) / 500);
      }
      exports.dateToBlockTimestamp = dateToBlockTimestamp;
      function blockTimestampToDate(slot) {
        var s = new Date(slot * 500 + 9466848e5).toISOString();
        return s.substr(0, s.length - 1);
      }
      exports.blockTimestampToDate = blockTimestampToDate;
      function stringToSymbol(s) {
        if (typeof s !== "string") {
          throw new Error("Expected string containing symbol");
        }
        var m = s.match(/^([0-9]+),([A-Z]+)$/);
        if (!m) {
          throw new Error("Invalid symbol");
        }
        return { name: m[2], precision: +m[1] };
      }
      exports.stringToSymbol = stringToSymbol;
      function symbolToString(_a) {
        var name = _a.name, precision = _a.precision;
        return precision + "," + name;
      }
      exports.symbolToString = symbolToString;
      function arrayToHex(data) {
        var e_1, _a;
        var result = "";
        try {
          for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var x = data_1_1.value;
            result += ("00" + x.toString(16)).slice(-2);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (data_1_1 && !data_1_1.done && (_a = data_1.return))
              _a.call(data_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return result.toUpperCase();
      }
      exports.arrayToHex = arrayToHex;
      function hexToUint8Array(hex) {
        if (typeof hex !== "string") {
          throw new Error("Expected string containing hex digits");
        }
        if (hex.length % 2) {
          throw new Error("Odd number of hex digits");
        }
        var l = hex.length / 2;
        var result = new Uint8Array(l);
        for (var i = 0; i < l; ++i) {
          var x = parseInt(hex.substr(i * 2, 2), 16);
          if (Number.isNaN(x)) {
            throw new Error("Expected hex string");
          }
          result[i] = x;
        }
        return result;
      }
      exports.hexToUint8Array = hexToUint8Array;
      function serializeUnknown(buffer, data) {
        throw new Error("Don't know how to serialize " + this.name);
      }
      function deserializeUnknown(buffer) {
        throw new Error("Don't know how to deserialize " + this.name);
      }
      function serializeStruct(buffer, data, state, allowExtensions) {
        if (state === void 0) {
          state = new SerializerState();
        }
        if (allowExtensions === void 0) {
          allowExtensions = true;
        }
        var e_2, _a;
        if (typeof data !== "object") {
          throw new Error("expected object containing data: " + JSON.stringify(data));
        }
        if (this.base) {
          this.base.serialize(buffer, data, state, allowExtensions);
        }
        try {
          for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
            var field = _c.value;
            if (field.name in data) {
              if (state.skippedBinaryExtension) {
                throw new Error("unexpected " + this.name + "." + field.name);
              }
              field.type.serialize(buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);
            } else {
              if (allowExtensions && field.type.extensionOf) {
                state.skippedBinaryExtension = true;
              } else {
                throw new Error("missing " + this.name + "." + field.name + " (type=" + field.type.name + ")");
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      function deserializeStruct(buffer, state, allowExtensions) {
        if (state === void 0) {
          state = new SerializerState();
        }
        if (allowExtensions === void 0) {
          allowExtensions = true;
        }
        var e_3, _a;
        var result;
        if (this.base) {
          result = this.base.deserialize(buffer, state, allowExtensions);
        } else {
          result = {};
        }
        try {
          for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
            var field = _c.value;
            if (allowExtensions && field.type.extensionOf && !buffer.haveReadData()) {
              state.skippedBinaryExtension = true;
            } else {
              result[field.name] = field.type.deserialize(buffer, state, allowExtensions);
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        return result;
      }
      function serializeVariant(buffer, data, state, allowExtensions) {
        if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== "string") {
          throw new Error('expected variant: ["type", value]');
        }
        var i = this.fields.findIndex(function(field) {
          return field.name === data[0];
        });
        if (i < 0) {
          throw new Error('type "' + data[0] + '" is not valid for variant');
        }
        buffer.pushVaruint32(i);
        this.fields[i].type.serialize(buffer, data[1], state, allowExtensions);
      }
      function deserializeVariant(buffer, state, allowExtensions) {
        var i = buffer.getVaruint32();
        if (i >= this.fields.length) {
          throw new Error("type index " + i + " is not valid for variant");
        }
        var field = this.fields[i];
        return [field.name, field.type.deserialize(buffer, state, allowExtensions)];
      }
      function serializeArray(buffer, data, state, allowExtensions) {
        var e_4, _a;
        buffer.pushVaruint32(data.length);
        try {
          for (var data_2 = __values(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {
            var item = data_2_1.value;
            this.arrayOf.serialize(buffer, item, state, false);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (data_2_1 && !data_2_1.done && (_a = data_2.return))
              _a.call(data_2);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
      }
      function deserializeArray(buffer, state, allowExtensions) {
        var len = buffer.getVaruint32();
        var result = [];
        for (var i = 0; i < len; ++i) {
          result.push(this.arrayOf.deserialize(buffer, state, false));
        }
        return result;
      }
      function serializeOptional(buffer, data, state, allowExtensions) {
        if (data === null || data === void 0) {
          buffer.push(0);
        } else {
          buffer.push(1);
          this.optionalOf.serialize(buffer, data, state, allowExtensions);
        }
      }
      function deserializeOptional(buffer, state, allowExtensions) {
        if (buffer.get()) {
          return this.optionalOf.deserialize(buffer, state, allowExtensions);
        } else {
          return null;
        }
      }
      function serializeExtension(buffer, data, state, allowExtensions) {
        this.extensionOf.serialize(buffer, data, state, allowExtensions);
      }
      function deserializeExtension(buffer, state, allowExtensions) {
        return this.extensionOf.deserialize(buffer, state, allowExtensions);
      }
      function createType(attrs) {
        return __assign({ name: "<missing name>", aliasOfName: "", arrayOf: null, optionalOf: null, extensionOf: null, baseName: "", base: null, fields: [], serialize: serializeUnknown, deserialize: deserializeUnknown }, attrs);
      }
      function checkRange(orig, converted) {
        if (Number.isNaN(+orig) || Number.isNaN(+converted) || typeof orig !== "number" && typeof orig !== "string") {
          throw new Error("Expected number");
        }
        if (+orig !== +converted) {
          throw new Error("Number is out of range");
        }
        return +orig;
      }
      function createInitialTypes() {
        var result = new Map(Object.entries({
          bool: createType({
            name: "bool",
            serialize: function(buffer, data) {
              if (typeof data !== "boolean") {
                throw new Error("Expected true or false");
              }
              buffer.push(data ? 1 : 0);
            },
            deserialize: function(buffer) {
              return !!buffer.get();
            }
          }),
          uint8: createType({
            name: "uint8",
            serialize: function(buffer, data) {
              buffer.push(checkRange(data, data & 255));
            },
            deserialize: function(buffer) {
              return buffer.get();
            }
          }),
          int8: createType({
            name: "int8",
            serialize: function(buffer, data) {
              buffer.push(checkRange(data, data << 24 >> 24));
            },
            deserialize: function(buffer) {
              return buffer.get() << 24 >> 24;
            }
          }),
          uint16: createType({
            name: "uint16",
            serialize: function(buffer, data) {
              buffer.pushUint16(checkRange(data, data & 65535));
            },
            deserialize: function(buffer) {
              return buffer.getUint16();
            }
          }),
          int16: createType({
            name: "int16",
            serialize: function(buffer, data) {
              buffer.pushUint16(checkRange(data, data << 16 >> 16));
            },
            deserialize: function(buffer) {
              return buffer.getUint16() << 16 >> 16;
            }
          }),
          uint32: createType({
            name: "uint32",
            serialize: function(buffer, data) {
              buffer.pushUint32(checkRange(data, data >>> 0));
            },
            deserialize: function(buffer) {
              return buffer.getUint32();
            }
          }),
          uint64: createType({
            name: "uint64",
            serialize: function(buffer, data) {
              buffer.pushArray(numeric.decimalToBinary(8, "" + data));
            },
            deserialize: function(buffer) {
              return numeric.binaryToDecimal(buffer.getUint8Array(8));
            }
          }),
          int64: createType({
            name: "int64",
            serialize: function(buffer, data) {
              buffer.pushArray(numeric.signedDecimalToBinary(8, "" + data));
            },
            deserialize: function(buffer) {
              return numeric.signedBinaryToDecimal(buffer.getUint8Array(8));
            }
          }),
          int32: createType({
            name: "int32",
            serialize: function(buffer, data) {
              buffer.pushUint32(checkRange(data, data | 0));
            },
            deserialize: function(buffer) {
              return buffer.getUint32() | 0;
            }
          }),
          varuint32: createType({
            name: "varuint32",
            serialize: function(buffer, data) {
              buffer.pushVaruint32(checkRange(data, data >>> 0));
            },
            deserialize: function(buffer) {
              return buffer.getVaruint32();
            }
          }),
          varint32: createType({
            name: "varint32",
            serialize: function(buffer, data) {
              buffer.pushVarint32(checkRange(data, data | 0));
            },
            deserialize: function(buffer) {
              return buffer.getVarint32();
            }
          }),
          uint128: createType({
            name: "uint128",
            serialize: function(buffer, data) {
              buffer.pushArray(numeric.decimalToBinary(16, "" + data));
            },
            deserialize: function(buffer) {
              return numeric.binaryToDecimal(buffer.getUint8Array(16));
            }
          }),
          int128: createType({
            name: "int128",
            serialize: function(buffer, data) {
              buffer.pushArray(numeric.signedDecimalToBinary(16, "" + data));
            },
            deserialize: function(buffer) {
              return numeric.signedBinaryToDecimal(buffer.getUint8Array(16));
            }
          }),
          float32: createType({
            name: "float32",
            serialize: function(buffer, data) {
              buffer.pushFloat32(data);
            },
            deserialize: function(buffer) {
              return buffer.getFloat32();
            }
          }),
          float64: createType({
            name: "float64",
            serialize: function(buffer, data) {
              buffer.pushFloat64(data);
            },
            deserialize: function(buffer) {
              return buffer.getFloat64();
            }
          }),
          float128: createType({
            name: "float128",
            serialize: function(buffer, data) {
              buffer.pushUint8ArrayChecked(hexToUint8Array(data), 16);
            },
            deserialize: function(buffer) {
              return arrayToHex(buffer.getUint8Array(16));
            }
          }),
          bytes: createType({
            name: "bytes",
            serialize: function(buffer, data) {
              if (data instanceof Uint8Array || Array.isArray(data)) {
                buffer.pushBytes(data);
              } else {
                buffer.pushBytes(hexToUint8Array(data));
              }
            },
            deserialize: function(buffer, state) {
              if (state && state.options.bytesAsUint8Array) {
                return buffer.getBytes();
              } else {
                return arrayToHex(buffer.getBytes());
              }
            }
          }),
          string: createType({
            name: "string",
            serialize: function(buffer, data) {
              buffer.pushString(data);
            },
            deserialize: function(buffer) {
              return buffer.getString();
            }
          }),
          name: createType({
            name: "name",
            serialize: function(buffer, data) {
              buffer.pushName(data);
            },
            deserialize: function(buffer) {
              return buffer.getName();
            }
          }),
          time_point: createType({
            name: "time_point",
            serialize: function(buffer, data) {
              buffer.pushNumberAsUint64(dateToTimePoint(data));
            },
            deserialize: function(buffer) {
              return timePointToDate(buffer.getUint64AsNumber());
            }
          }),
          time_point_sec: createType({
            name: "time_point_sec",
            serialize: function(buffer, data) {
              buffer.pushUint32(dateToTimePointSec(data));
            },
            deserialize: function(buffer) {
              return timePointSecToDate(buffer.getUint32());
            }
          }),
          block_timestamp_type: createType({
            name: "block_timestamp_type",
            serialize: function(buffer, data) {
              buffer.pushUint32(dateToBlockTimestamp(data));
            },
            deserialize: function(buffer) {
              return blockTimestampToDate(buffer.getUint32());
            }
          }),
          symbol_code: createType({
            name: "symbol_code",
            serialize: function(buffer, data) {
              buffer.pushSymbolCode(data);
            },
            deserialize: function(buffer) {
              return buffer.getSymbolCode();
            }
          }),
          symbol: createType({
            name: "symbol",
            serialize: function(buffer, data) {
              buffer.pushSymbol(stringToSymbol(data));
            },
            deserialize: function(buffer) {
              return symbolToString(buffer.getSymbol());
            }
          }),
          asset: createType({
            name: "asset",
            serialize: function(buffer, data) {
              buffer.pushAsset(data);
            },
            deserialize: function(buffer) {
              return buffer.getAsset();
            }
          }),
          checksum160: createType({
            name: "checksum160",
            serialize: function(buffer, data) {
              buffer.pushUint8ArrayChecked(hexToUint8Array(data), 20);
            },
            deserialize: function(buffer) {
              return arrayToHex(buffer.getUint8Array(20));
            }
          }),
          checksum256: createType({
            name: "checksum256",
            serialize: function(buffer, data) {
              buffer.pushUint8ArrayChecked(hexToUint8Array(data), 32);
            },
            deserialize: function(buffer) {
              return arrayToHex(buffer.getUint8Array(32));
            }
          }),
          checksum512: createType({
            name: "checksum512",
            serialize: function(buffer, data) {
              buffer.pushUint8ArrayChecked(hexToUint8Array(data), 64);
            },
            deserialize: function(buffer) {
              return arrayToHex(buffer.getUint8Array(64));
            }
          }),
          public_key: createType({
            name: "public_key",
            serialize: function(buffer, data) {
              buffer.pushPublicKey(data);
            },
            deserialize: function(buffer) {
              return buffer.getPublicKey();
            }
          }),
          private_key: createType({
            name: "private_key",
            serialize: function(buffer, data) {
              buffer.pushPrivateKey(data);
            },
            deserialize: function(buffer) {
              return buffer.getPrivateKey();
            }
          }),
          signature: createType({
            name: "signature",
            serialize: function(buffer, data) {
              buffer.pushSignature(data);
            },
            deserialize: function(buffer) {
              return buffer.getSignature();
            }
          })
        }));
        result.set("extended_asset", createType({
          name: "extended_asset",
          baseName: "",
          fields: [
            { name: "quantity", typeName: "asset", type: result.get("asset") },
            { name: "contract", typeName: "name", type: result.get("name") }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        return result;
      }
      exports.createInitialTypes = createInitialTypes;
      function getType(types, name) {
        var type = types.get(name);
        if (type && type.aliasOfName) {
          return getType(types, type.aliasOfName);
        }
        if (type) {
          return type;
        }
        if (name.endsWith("[]")) {
          return createType({
            name,
            arrayOf: getType(types, name.substr(0, name.length - 2)),
            serialize: serializeArray,
            deserialize: deserializeArray
          });
        }
        if (name.endsWith("?")) {
          return createType({
            name,
            optionalOf: getType(types, name.substr(0, name.length - 1)),
            serialize: serializeOptional,
            deserialize: deserializeOptional
          });
        }
        if (name.endsWith("$")) {
          return createType({
            name,
            extensionOf: getType(types, name.substr(0, name.length - 1)),
            serialize: serializeExtension,
            deserialize: deserializeExtension
          });
        }
        throw new Error("Unknown type: " + name);
      }
      exports.getType = getType;
      function getTypesFromAbi(initialTypes, abi) {
        var e_5, _a, e_6, _b, e_7, _c, e_8, _d, e_9, _e;
        var types = new Map(initialTypes);
        if (abi.types) {
          try {
            for (var _f = __values(abi.types), _g = _f.next(); !_g.done; _g = _f.next()) {
              var _h = _g.value, new_type_name = _h.new_type_name, type = _h.type;
              types.set(new_type_name, createType({ name: new_type_name, aliasOfName: type }));
            }
          } catch (e_5_1) {
            e_5 = { error: e_5_1 };
          } finally {
            try {
              if (_g && !_g.done && (_a = _f.return))
                _a.call(_f);
            } finally {
              if (e_5)
                throw e_5.error;
            }
          }
        }
        if (abi.structs) {
          try {
            for (var _j = __values(abi.structs), _k = _j.next(); !_k.done; _k = _j.next()) {
              var _l = _k.value, name_1 = _l.name, base = _l.base, fields = _l.fields;
              types.set(name_1, createType({
                name: name_1,
                baseName: base,
                fields: fields.map(function(_a2) {
                  var n = _a2.name, type2 = _a2.type;
                  return { name: n, typeName: type2, type: null };
                }),
                serialize: serializeStruct,
                deserialize: deserializeStruct
              }));
            }
          } catch (e_6_1) {
            e_6 = { error: e_6_1 };
          } finally {
            try {
              if (_k && !_k.done && (_b = _j.return))
                _b.call(_j);
            } finally {
              if (e_6)
                throw e_6.error;
            }
          }
        }
        if (abi.variants) {
          try {
            for (var _m = __values(abi.variants), _o = _m.next(); !_o.done; _o = _m.next()) {
              var _p = _o.value, name_2 = _p.name, t = _p.types;
              types.set(name_2, createType({
                name: name_2,
                fields: t.map(function(s) {
                  return { name: s, typeName: s, type: null };
                }),
                serialize: serializeVariant,
                deserialize: deserializeVariant
              }));
            }
          } catch (e_7_1) {
            e_7 = { error: e_7_1 };
          } finally {
            try {
              if (_o && !_o.done && (_c = _m.return))
                _c.call(_m);
            } finally {
              if (e_7)
                throw e_7.error;
            }
          }
        }
        try {
          for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
            var _q = __read(types_1_1.value, 2), name_3 = _q[0], type = _q[1];
            if (type.baseName) {
              type.base = getType(types, type.baseName);
            }
            try {
              for (var _r = __values(type.fields), _s = _r.next(); !_s.done; _s = _r.next()) {
                var field = _s.value;
                field.type = getType(types, field.typeName);
              }
            } catch (e_9_1) {
              e_9 = { error: e_9_1 };
            } finally {
              try {
                if (_s && !_s.done && (_e = _r.return))
                  _e.call(_r);
              } finally {
                if (e_9)
                  throw e_9.error;
              }
            }
          }
        } catch (e_8_1) {
          e_8 = { error: e_8_1 };
        } finally {
          try {
            if (types_1_1 && !types_1_1.done && (_d = types_1.return))
              _d.call(types_1);
          } finally {
            if (e_8)
              throw e_8.error;
          }
        }
        return types;
      }
      exports.getTypesFromAbi = getTypesFromAbi;
      function transactionHeader(refBlock, expireSeconds) {
        return {
          expiration: timePointSecToDate(dateToTimePointSec(refBlock.timestamp) + expireSeconds),
          ref_block_num: refBlock.block_num & 65535,
          ref_block_prefix: refBlock.ref_block_prefix
        };
      }
      exports.transactionHeader = transactionHeader;
      function serializeActionData(contract, account, name, data, textEncoder, textDecoder) {
        var action = contract.actions.get(name);
        if (!action) {
          throw new Error("Unknown action " + name + " in contract " + account);
        }
        var buffer = new SerialBuffer({ textEncoder, textDecoder });
        action.serialize(buffer, data);
        return arrayToHex(buffer.asUint8Array());
      }
      exports.serializeActionData = serializeActionData;
      function serializeAction(contract, account, name, authorization, data, textEncoder, textDecoder) {
        return {
          account,
          name,
          authorization,
          data: serializeActionData(contract, account, name, data, textEncoder, textDecoder)
        };
      }
      exports.serializeAction = serializeAction;
      function deserializeActionData(contract, account, name, data, textEncoder, textDecoder) {
        var action = contract.actions.get(name);
        if (typeof data === "string") {
          data = hexToUint8Array(data);
        }
        if (!action) {
          throw new Error("Unknown action " + name + " in contract " + account);
        }
        var buffer = new SerialBuffer({ textDecoder, textEncoder });
        buffer.pushArray(data);
        return action.deserialize(buffer);
      }
      exports.deserializeActionData = deserializeActionData;
      function deserializeAction(contract, account, name, authorization, data, textEncoder, textDecoder) {
        return {
          account,
          name,
          authorization,
          data: deserializeActionData(contract, account, name, data, textEncoder, textDecoder)
        };
      }
      exports.deserializeAction = deserializeAction;
    }
  });

  // node_modules/@waxio/waxjs/node_modules/eosjs/src/abi.abi.json
  var require_abi_abi = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/src/abi.abi.json"(exports, module) {
      module.exports = {
        version: "eosio::abi/1.1",
        structs: [
          {
            name: "extensions_entry",
            base: "",
            fields: [
              {
                name: "tag",
                type: "uint16"
              },
              {
                name: "value",
                type: "bytes"
              }
            ]
          },
          {
            name: "type_def",
            base: "",
            fields: [
              {
                name: "new_type_name",
                type: "string"
              },
              {
                name: "type",
                type: "string"
              }
            ]
          },
          {
            name: "field_def",
            base: "",
            fields: [
              {
                name: "name",
                type: "string"
              },
              {
                name: "type",
                type: "string"
              }
            ]
          },
          {
            name: "struct_def",
            base: "",
            fields: [
              {
                name: "name",
                type: "string"
              },
              {
                name: "base",
                type: "string"
              },
              {
                name: "fields",
                type: "field_def[]"
              }
            ]
          },
          {
            name: "action_def",
            base: "",
            fields: [
              {
                name: "name",
                type: "name"
              },
              {
                name: "type",
                type: "string"
              },
              {
                name: "ricardian_contract",
                type: "string"
              }
            ]
          },
          {
            name: "table_def",
            base: "",
            fields: [
              {
                name: "name",
                type: "name"
              },
              {
                name: "index_type",
                type: "string"
              },
              {
                name: "key_names",
                type: "string[]"
              },
              {
                name: "key_types",
                type: "string[]"
              },
              {
                name: "type",
                type: "string"
              }
            ]
          },
          {
            name: "clause_pair",
            base: "",
            fields: [
              {
                name: "id",
                type: "string"
              },
              {
                name: "body",
                type: "string"
              }
            ]
          },
          {
            name: "error_message",
            base: "",
            fields: [
              {
                name: "error_code",
                type: "uint64"
              },
              {
                name: "error_msg",
                type: "string"
              }
            ]
          },
          {
            name: "variant_def",
            base: "",
            fields: [
              {
                name: "name",
                type: "string"
              },
              {
                name: "types",
                type: "string[]"
              }
            ]
          },
          {
            name: "abi_def",
            base: "",
            fields: [
              {
                name: "version",
                type: "string"
              },
              {
                name: "types",
                type: "type_def[]"
              },
              {
                name: "structs",
                type: "struct_def[]"
              },
              {
                name: "actions",
                type: "action_def[]"
              },
              {
                name: "tables",
                type: "table_def[]"
              },
              {
                name: "ricardian_clauses",
                type: "clause_pair[]"
              },
              {
                name: "error_messages",
                type: "error_message[]"
              },
              {
                name: "abi_extensions",
                type: "extensions_entry[]"
              },
              {
                name: "variants",
                type: "variant_def[]$"
              }
            ]
          }
        ]
      };
    }
  });

  // node_modules/@waxio/waxjs/node_modules/eosjs/src/transaction.abi.json
  var require_transaction_abi = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/src/transaction.abi.json"(exports, module) {
      module.exports = {
        version: "eosio::abi/1.0",
        types: [
          {
            new_type_name: "account_name",
            type: "name"
          },
          {
            new_type_name: "action_name",
            type: "name"
          },
          {
            new_type_name: "permission_name",
            type: "name"
          }
        ],
        structs: [
          {
            name: "permission_level",
            base: "",
            fields: [
              {
                name: "actor",
                type: "account_name"
              },
              {
                name: "permission",
                type: "permission_name"
              }
            ]
          },
          {
            name: "action",
            base: "",
            fields: [
              {
                name: "account",
                type: "account_name"
              },
              {
                name: "name",
                type: "action_name"
              },
              {
                name: "authorization",
                type: "permission_level[]"
              },
              {
                name: "data",
                type: "bytes"
              }
            ]
          },
          {
            name: "extension",
            base: "",
            fields: [
              {
                name: "type",
                type: "uint16"
              },
              {
                name: "data",
                type: "bytes"
              }
            ]
          },
          {
            name: "transaction_header",
            base: "",
            fields: [
              {
                name: "expiration",
                type: "time_point_sec"
              },
              {
                name: "ref_block_num",
                type: "uint16"
              },
              {
                name: "ref_block_prefix",
                type: "uint32"
              },
              {
                name: "max_net_usage_words",
                type: "varuint32"
              },
              {
                name: "max_cpu_usage_ms",
                type: "uint8"
              },
              {
                name: "delay_sec",
                type: "varuint32"
              }
            ]
          },
          {
            name: "transaction",
            base: "transaction_header",
            fields: [
              {
                name: "context_free_actions",
                type: "action[]"
              },
              {
                name: "actions",
                type: "action[]"
              },
              {
                name: "transaction_extensions",
                type: "extension[]"
              }
            ]
          }
        ]
      };
    }
  });

  // node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-api.js
  var require_eosjs_api = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-api.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : new P(function(resolve2) {
              resolve2(result.value);
            }).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f2, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f2 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") {
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
            if (e.indexOf(p[i]) < 0)
              t[p[i]] = s[p[i]];
        }
        return t;
      };
      var __read = exports && exports.__read || function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      var __spread = exports && exports.__spread || function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      var __values = exports && exports.__values || function(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
          return m.call(o);
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var ser = require_eosjs_serialize();
      var abiAbi = require_abi_abi();
      var transactionAbi = require_transaction_abi();
      var Api = function() {
        function Api2(args) {
          this.contracts = new Map();
          this.cachedAbis = new Map();
          this.rpc = args.rpc;
          this.authorityProvider = args.authorityProvider || args.rpc;
          this.abiProvider = args.abiProvider || args.rpc;
          this.signatureProvider = args.signatureProvider;
          this.chainId = args.chainId;
          this.textEncoder = args.textEncoder;
          this.textDecoder = args.textDecoder;
          this.abiTypes = ser.getTypesFromAbi(ser.createInitialTypes(), abiAbi);
          this.transactionTypes = ser.getTypesFromAbi(ser.createInitialTypes(), transactionAbi);
        }
        Api2.prototype.rawAbiToJson = function(rawAbi) {
          var buffer = new ser.SerialBuffer({
            textEncoder: this.textEncoder,
            textDecoder: this.textDecoder,
            array: rawAbi
          });
          if (!ser.supportedAbiVersion(buffer.getString())) {
            throw new Error("Unsupported abi version");
          }
          buffer.restartRead();
          return this.abiTypes.get("abi_def").deserialize(buffer);
        };
        Api2.prototype.getCachedAbi = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            var cachedAbi, rawAbi, abi, e_1;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!reload && this.cachedAbis.get(accountName)) {
                    return [2, this.cachedAbis.get(accountName)];
                  }
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 3, , 4]);
                  return [4, this.abiProvider.getRawAbi(accountName)];
                case 2:
                  rawAbi = _a.sent().abi;
                  abi = this.rawAbiToJson(rawAbi);
                  cachedAbi = { rawAbi, abi };
                  return [3, 4];
                case 3:
                  e_1 = _a.sent();
                  e_1.message = "fetching abi for " + accountName + ": " + e_1.message;
                  throw e_1;
                case 4:
                  if (!cachedAbi) {
                    throw new Error("Missing abi for " + accountName);
                  }
                  this.cachedAbis.set(accountName, cachedAbi);
                  return [2, cachedAbi];
              }
            });
          });
        };
        Api2.prototype.getAbi = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getCachedAbi(accountName, reload)];
                case 1:
                  return [2, _a.sent().abi];
              }
            });
          });
        };
        Api2.prototype.getTransactionAbis = function(transaction, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            var accounts, uniqueAccounts, actionPromises;
            var _this = this;
            return __generator(this, function(_a) {
              accounts = transaction.actions.map(function(action) {
                return action.account;
              });
              uniqueAccounts = new Set(accounts);
              actionPromises = __spread(uniqueAccounts).map(function(account) {
                return __awaiter(_this, void 0, void 0, function() {
                  var _a2;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        _a2 = {
                          accountName: account
                        };
                        return [4, this.getCachedAbi(account, reload)];
                      case 1:
                        return [2, (_a2.abi = _b.sent().rawAbi, _a2)];
                    }
                  });
                });
              });
              return [2, Promise.all(actionPromises)];
            });
          });
        };
        Api2.prototype.getContract = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            var e_2, _a, abi, types, actions, _b, _c, _d, name_1, type, result;
            return __generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  if (!reload && this.contracts.get(accountName)) {
                    return [2, this.contracts.get(accountName)];
                  }
                  return [4, this.getAbi(accountName, reload)];
                case 1:
                  abi = _e.sent();
                  types = ser.getTypesFromAbi(ser.createInitialTypes(), abi);
                  actions = new Map();
                  try {
                    for (_b = __values(abi.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
                      _d = _c.value, name_1 = _d.name, type = _d.type;
                      actions.set(name_1, ser.getType(types, type));
                    }
                  } catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                  } finally {
                    try {
                      if (_c && !_c.done && (_a = _b.return))
                        _a.call(_b);
                    } finally {
                      if (e_2)
                        throw e_2.error;
                    }
                  }
                  result = { types, actions };
                  this.contracts.set(accountName, result);
                  return [2, result];
              }
            });
          });
        };
        Api2.prototype.serialize = function(buffer, type, value) {
          this.transactionTypes.get(type).serialize(buffer, value);
        };
        Api2.prototype.deserialize = function(buffer, type) {
          return this.transactionTypes.get(type).deserialize(buffer);
        };
        Api2.prototype.serializeTransaction = function(transaction) {
          var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          this.serialize(buffer, "transaction", __assign({ max_net_usage_words: 0, max_cpu_usage_ms: 0, delay_sec: 0, context_free_actions: [], actions: [], transaction_extensions: [] }, transaction));
          return buffer.asUint8Array();
        };
        Api2.prototype.deserializeTransaction = function(transaction) {
          var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          buffer.pushArray(transaction);
          return this.deserialize(buffer, "transaction");
        };
        Api2.prototype.serializeActions = function(actions) {
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, Promise.all(actions.map(function(_a2) {
                    var account = _a2.account, name = _a2.name, authorization = _a2.authorization, data = _a2.data;
                    return __awaiter(_this, void 0, void 0, function() {
                      var contract;
                      return __generator(this, function(_b) {
                        switch (_b.label) {
                          case 0:
                            return [4, this.getContract(account)];
                          case 1:
                            contract = _b.sent();
                            return [2, ser.serializeAction(contract, account, name, authorization, data, this.textEncoder, this.textDecoder)];
                        }
                      });
                    });
                  }))];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        Api2.prototype.deserializeActions = function(actions) {
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, Promise.all(actions.map(function(_a2) {
                    var account = _a2.account, name = _a2.name, authorization = _a2.authorization, data = _a2.data;
                    return __awaiter(_this, void 0, void 0, function() {
                      var contract;
                      return __generator(this, function(_b) {
                        switch (_b.label) {
                          case 0:
                            return [4, this.getContract(account)];
                          case 1:
                            contract = _b.sent();
                            return [2, ser.deserializeAction(contract, account, name, authorization, data, this.textEncoder, this.textDecoder)];
                        }
                      });
                    });
                  }))];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        Api2.prototype.deserializeTransactionWithActions = function(transaction) {
          return __awaiter(this, void 0, void 0, function() {
            var deserializedTransaction, deserializedActions;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (typeof transaction === "string") {
                    transaction = ser.hexToUint8Array(transaction);
                  }
                  deserializedTransaction = this.deserializeTransaction(transaction);
                  return [4, this.deserializeActions(deserializedTransaction.actions)];
                case 1:
                  deserializedActions = _a.sent();
                  return [2, __assign({}, deserializedTransaction, { actions: deserializedActions })];
              }
            });
          });
        };
        Api2.prototype.transact = function(transaction, _a) {
          var _b = _a === void 0 ? {} : _a, _c = _b.broadcast, broadcast = _c === void 0 ? true : _c, _d = _b.sign, sign = _d === void 0 ? true : _d, blocksBehind = _b.blocksBehind, expireSeconds = _b.expireSeconds;
          return __awaiter(this, void 0, void 0, function() {
            var info, refBlock, abis, _e, _f, serializedTransaction, pushTransactionArgs, availableKeys, requiredKeys;
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  if (!!this.chainId)
                    return [3, 2];
                  return [4, this.rpc.get_info()];
                case 1:
                  info = _g.sent();
                  this.chainId = info.chain_id;
                  _g.label = 2;
                case 2:
                  if (!(typeof blocksBehind === "number" && expireSeconds))
                    return [3, 6];
                  if (!!info)
                    return [3, 4];
                  return [4, this.rpc.get_info()];
                case 3:
                  info = _g.sent();
                  _g.label = 4;
                case 4:
                  return [4, this.rpc.get_block(info.head_block_num - blocksBehind)];
                case 5:
                  refBlock = _g.sent();
                  transaction = __assign({}, ser.transactionHeader(refBlock, expireSeconds), transaction);
                  _g.label = 6;
                case 6:
                  if (!this.hasRequiredTaposFields(transaction)) {
                    throw new Error("Required configuration or TAPOS fields are not present");
                  }
                  return [4, this.getTransactionAbis(transaction)];
                case 7:
                  abis = _g.sent();
                  _e = [{}, transaction];
                  _f = {};
                  return [4, this.serializeActions(transaction.actions)];
                case 8:
                  transaction = __assign.apply(void 0, _e.concat([(_f.actions = _g.sent(), _f)]));
                  serializedTransaction = this.serializeTransaction(transaction);
                  pushTransactionArgs = { serializedTransaction, signatures: [] };
                  if (!sign)
                    return [3, 12];
                  return [4, this.signatureProvider.getAvailableKeys()];
                case 9:
                  availableKeys = _g.sent();
                  return [4, this.authorityProvider.getRequiredKeys({ transaction, availableKeys })];
                case 10:
                  requiredKeys = _g.sent();
                  return [4, this.signatureProvider.sign({
                    chainId: this.chainId,
                    requiredKeys,
                    serializedTransaction,
                    abis
                  })];
                case 11:
                  pushTransactionArgs = _g.sent();
                  _g.label = 12;
                case 12:
                  if (broadcast) {
                    return [2, this.pushSignedTransaction(pushTransactionArgs)];
                  }
                  return [2, pushTransactionArgs];
              }
            });
          });
        };
        Api2.prototype.pushSignedTransaction = function(_a) {
          var signatures = _a.signatures, serializedTransaction = _a.serializedTransaction;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_b) {
              return [2, this.rpc.push_transaction({
                signatures,
                serializedTransaction
              })];
            });
          });
        };
        Api2.prototype.hasRequiredTaposFields = function(_a) {
          var expiration = _a.expiration, ref_block_num = _a.ref_block_num, ref_block_prefix = _a.ref_block_prefix, transaction = __rest(_a, ["expiration", "ref_block_num", "ref_block_prefix"]);
          return !!(expiration && ref_block_num && ref_block_prefix);
        };
        return Api2;
      }();
      exports.Api = Api;
    }
  });

  // node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-api-interfaces.js
  var require_eosjs_api_interfaces = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-api-interfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-rpcerror.js
  var require_eosjs_rpcerror = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-rpcerror.js"(exports) {
      "use strict";
      var __extends = exports && exports.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (b2.hasOwnProperty(p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      var RpcError = function(_super) {
        __extends(RpcError2, _super);
        function RpcError2(json) {
          var _this = this;
          if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
          } else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
          } else {
            _this = _super.call(this, json.message) || this;
          }
          Object.setPrototypeOf(_this, RpcError2.prototype);
          _this.json = json;
          return _this;
        }
        return RpcError2;
      }(Error);
      exports.RpcError = RpcError;
    }
  });

  // node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-jsonrpc.js
  var require_eosjs_jsonrpc = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-jsonrpc.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : new P(function(resolve2) {
              resolve2(result.value);
            }).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f2, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f2 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __values = exports && exports.__values || function(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
          return m.call(o);
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var eosjs_numeric_1 = require_eosjs_numeric();
      var eosjs_rpcerror_1 = require_eosjs_rpcerror();
      function arrayToHex(data) {
        var e_1, _a;
        var result = "";
        try {
          for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var x = data_1_1.value;
            result += ("00" + x.toString(16)).slice(-2);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (data_1_1 && !data_1_1.done && (_a = data_1.return))
              _a.call(data_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return result;
      }
      var JsonRpc = function() {
        function JsonRpc2(endpoint, args) {
          if (args === void 0) {
            args = {};
          }
          this.endpoint = endpoint;
          if (args.fetch) {
            this.fetchBuiltin = args.fetch;
          } else {
            this.fetchBuiltin = global.fetch;
          }
        }
        JsonRpc2.prototype.fetch = function(path, body) {
          return __awaiter(this, void 0, void 0, function() {
            var response, json, f2, e_2;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 3, , 4]);
                  f2 = this.fetchBuiltin;
                  return [4, f2(this.endpoint + path, {
                    body: JSON.stringify(body),
                    method: "POST"
                  })];
                case 1:
                  response = _a.sent();
                  return [4, response.json()];
                case 2:
                  json = _a.sent();
                  if (json.processed && json.processed.except) {
                    throw new eosjs_rpcerror_1.RpcError(json);
                  }
                  return [3, 4];
                case 3:
                  e_2 = _a.sent();
                  e_2.isFetchError = true;
                  throw e_2;
                case 4:
                  if (!response.ok) {
                    throw new eosjs_rpcerror_1.RpcError(json);
                  }
                  return [2, json];
              }
            });
          });
        };
        JsonRpc2.prototype.get_abi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_abi", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_account = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_account", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_block_header_state = function(blockNumOrId) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_block_header_state", { block_num_or_id: blockNumOrId })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_block = function(blockNumOrId) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_block", { block_num_or_id: blockNumOrId })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_code = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_code", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_currency_balance = function(code, account, symbol) {
          if (symbol === void 0) {
            symbol = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_currency_balance", { code, account, symbol })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_currency_stats = function(code, symbol) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_currency_stats", { code, symbol })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_info = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_info", {})];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_producer_schedule = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_producer_schedule", {})];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_producers = function(json, lowerBound, limit) {
          if (json === void 0) {
            json = true;
          }
          if (lowerBound === void 0) {
            lowerBound = "";
          }
          if (limit === void 0) {
            limit = 50;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_producers", { json, lower_bound: lowerBound, limit })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_raw_code_and_abi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_raw_code_and_abi", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.getRawAbi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            var rawCodeAndAbi, abi;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.get_raw_code_and_abi(accountName)];
                case 1:
                  rawCodeAndAbi = _a.sent();
                  abi = eosjs_numeric_1.base64ToBinary(rawCodeAndAbi.abi);
                  return [2, { accountName: rawCodeAndAbi.account_name, abi }];
              }
            });
          });
        };
        JsonRpc2.prototype.get_table_rows = function(_a) {
          var _b = _a.json, json = _b === void 0 ? true : _b, code = _a.code, scope = _a.scope, table = _a.table, _c = _a.table_key, table_key = _c === void 0 ? "" : _c, _d = _a.lower_bound, lower_bound = _d === void 0 ? "" : _d, _e = _a.upper_bound, upper_bound = _e === void 0 ? "" : _e, _f = _a.index_position, index_position = _f === void 0 ? 1 : _f, _g = _a.key_type, key_type = _g === void 0 ? "" : _g, _h = _a.limit, limit = _h === void 0 ? 10 : _h, _j = _a.reverse, reverse = _j === void 0 ? false : _j, _k = _a.show_payer, show_payer = _k === void 0 ? false : _k;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_l) {
              switch (_l.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_table_rows", {
                    json,
                    code,
                    scope,
                    table,
                    table_key,
                    lower_bound,
                    upper_bound,
                    index_position,
                    key_type,
                    limit,
                    reverse,
                    show_payer
                  })];
                case 1:
                  return [2, _l.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_table_by_scope = function(_a) {
          var code = _a.code, table = _a.table, _b = _a.lower_bound, lower_bound = _b === void 0 ? "" : _b, _c = _a.upper_bound, upper_bound = _c === void 0 ? "" : _c, _d = _a.limit, limit = _d === void 0 ? 10 : _d;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_table_by_scope", {
                    code,
                    table,
                    lower_bound,
                    upper_bound,
                    limit
                  })];
                case 1:
                  return [2, _e.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.getRequiredKeys = function(args) {
          return __awaiter(this, void 0, void 0, function() {
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a = eosjs_numeric_1.convertLegacyPublicKeys;
                  return [4, this.fetch("/v1/chain/get_required_keys", {
                    transaction: args.transaction,
                    available_keys: args.availableKeys
                  })];
                case 1:
                  return [2, _a.apply(void 0, [_b.sent().required_keys])];
              }
            });
          });
        };
        JsonRpc2.prototype.push_transaction = function(_a) {
          var signatures = _a.signatures, serializedTransaction = _a.serializedTransaction;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/push_transaction", {
                    signatures,
                    compression: 0,
                    packed_context_free_data: "",
                    packed_trx: arrayToHex(serializedTransaction)
                  })];
                case 1:
                  return [2, _b.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.db_size_get = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/db_size/get", {})];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_actions = function(accountName, pos, offset) {
          if (pos === void 0) {
            pos = null;
          }
          if (offset === void 0) {
            offset = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_actions", { account_name: accountName, pos, offset })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_transaction = function(id, blockNumHint) {
          if (blockNumHint === void 0) {
            blockNumHint = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_transaction", { id, block_num_hint: blockNumHint })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_key_accounts = function(publicKey) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_key_accounts", { public_key: publicKey })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_controlled_accounts = function(controllingAccount) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_controlled_accounts", { controlling_account: controllingAccount })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return JsonRpc2;
      }();
      exports.JsonRpc = JsonRpc;
    }
  });

  // node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-rpc-interfaces.js
  var require_eosjs_rpc_interfaces = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/dist/eosjs-rpc-interfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@waxio/waxjs/node_modules/eosjs/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@waxio/waxjs/node_modules/eosjs/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var eosjs_api_1 = require_eosjs_api();
      exports.Api = eosjs_api_1.Api;
      var ApiInterfaces = require_eosjs_api_interfaces();
      exports.ApiInterfaces = ApiInterfaces;
      var eosjs_jsonrpc_1 = require_eosjs_jsonrpc();
      exports.JsonRpc = eosjs_jsonrpc_1.JsonRpc;
      var Numeric = require_eosjs_numeric();
      exports.Numeric = Numeric;
      var RpcInterfaces = require_eosjs_rpc_interfaces();
      exports.RpcInterfaces = RpcInterfaces;
      var eosjs_rpcerror_1 = require_eosjs_rpcerror();
      exports.RpcError = eosjs_rpcerror_1.RpcError;
      var Serialize = require_eosjs_serialize();
      exports.Serialize = Serialize;
    }
  });

  // node_modules/@waxio/waxjs/dist/WaxEventSource.js
  var require_WaxEventSource = __commonJS({
    "node_modules/@waxio/waxjs/dist/WaxEventSource.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var WaxEventSource = class {
        constructor(waxSigningURL = "http://localhost:3000") {
          this.waxSigningURL = waxSigningURL;
          this.timeout = () => {
            return new Promise((resolve, reject) => {
              const wait = setTimeout(() => {
                clearTimeout(wait);
                reject(new Error("Timeout"));
              }, 2e3);
            });
          };
          this.openEventSource = this.openEventSource.bind(this);
          this.onceEvent = this.onceEvent.bind(this);
        }
        openEventSource(url, message, win) {
          return __awaiter(this, void 0, void 0, function* () {
            const openedWindow = win ? win : yield window.open(url, "WaxPopup", "height=800,width=600");
            if (!openedWindow) {
              throw new Error("Unable to open a popup window");
            }
            if (typeof message === "undefined") {
              return openedWindow;
            }
            const postTransaction = (event) => __awaiter(this, void 0, void 0, function* () {
              if (event.data.type === "READY") {
                openedWindow.postMessage(message, this.waxSigningURL);
              }
            });
            const eventPromise = this.onceEvent(openedWindow, this.waxSigningURL, postTransaction);
            yield Promise.race([eventPromise, this.timeout()]).catch((err) => {
              if (err.message !== "Timeout") {
                throw err;
              }
              openedWindow.postMessage(message, this.waxSigningURL);
            });
            return openedWindow;
          });
        }
        onceEvent(source, origin, action) {
          return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
              window.addEventListener("message", function onEvent(event) {
                return __awaiter(this, void 0, void 0, function* () {
                  if (event.origin !== origin) {
                    return;
                  }
                  if (event.source !== source) {
                    return;
                  }
                  if (typeof event.data !== "object") {
                    return;
                  }
                  try {
                    const result = yield action(event);
                    resolve(result);
                  } catch (e) {
                    reject(e);
                  }
                  window.removeEventListener("message", onEvent, false);
                });
              }, false);
            });
          });
        }
      };
      exports.WaxEventSource = WaxEventSource;
    }
  });

  // node_modules/@waxio/waxjs/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/@waxio/waxjs/dist/index.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var eosjs_1 = require_dist();
      var WaxEventSource_1 = require_WaxEventSource();
      var WaxJS = class {
        constructor(rcpEndpoint, userAccount = null, pubKeys = null, tryAutoLogin = true, apiSigner = null, waxSigningURL = "https://all-access.wax.io", waxAutoSigningURL = "https://api-idm.wax.io/v1/accounts/auto-accept/") {
          this.apiSigner = apiSigner;
          this.waxSigningURL = waxSigningURL;
          this.waxAutoSigningURL = waxAutoSigningURL;
          this.waxEventSource = new WaxEventSource_1.WaxEventSource(waxSigningURL);
          this.rpc = new eosjs_1.JsonRpc(rcpEndpoint);
          if (userAccount && Array.isArray(pubKeys)) {
            const data = { userAccount, pubKeys, verified: true };
            this.receiveLogin({ data });
          } else {
            if (tryAutoLogin) {
              this.loginViaEndpoint();
            }
          }
        }
        login() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.userAccount && Array.isArray(this.pubKeys)) {
              return this.userAccount;
            } else {
              return this.loginViaWindow();
            }
          });
        }
        isAutoLoginAvailable() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.userAccount && Array.isArray(this.pubKeys)) {
              return true;
            } else {
              try {
                yield this.loginViaEndpoint();
                return true;
              } catch (e) {
                return false;
              }
            }
            return false;
          });
        }
        loginViaWindow() {
          return __awaiter(this, void 0, void 0, function* () {
            const confirmationWindow = yield this.waxEventSource.openEventSource(this.waxSigningURL + "/cloud-wallet/login/");
            return this.waxEventSource.onceEvent(confirmationWindow, this.waxSigningURL, this.receiveLogin.bind(this));
          });
        }
        loginViaEndpoint() {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(this.waxAutoSigningURL + "login", {
              credentials: "include",
              method: "get"
            });
            if (!response.ok) {
              throw new Error(`Login Endpoint Error ${response.status} ${response.statusText}`);
            }
            const data = yield response.json();
            if (data.processed && data.processed.except) {
              throw new Error(data);
            }
            return this.receiveLogin({ data });
          });
        }
        receiveLogin(event) {
          return __awaiter(this, void 0, void 0, function* () {
            const { verified, userAccount, pubKeys, whitelistedContracts, autoLogin } = event.data;
            if (!verified) {
              throw new Error("User declined to share their user account");
            }
            if (userAccount == null || pubKeys == null) {
              throw new Error("User does not have a blockchain account");
            }
            localStorage.setItem("autoLogin", autoLogin);
            this.whitelistedContracts = whitelistedContracts || [];
            this.userAccount = userAccount;
            this.pubKeys = pubKeys;
            const signer = {
              getAvailableKeys: () => __awaiter(this, void 0, void 0, function* () {
                return [
                  ...this.pubKeys,
                  ...this.apiSigner && (yield this.apiSigner.getAvailableKeys()) || []
                ];
              }),
              sign: (data) => __awaiter(this, void 0, void 0, function* () {
                return {
                  serializedTransaction: data.serializedTransaction,
                  signatures: [
                    ...yield this.signing(data.serializedTransaction),
                    ...this.apiSigner && (yield this.apiSigner.sign(data)).signatures || []
                  ]
                };
              })
            };
            this.api = new eosjs_1.Api({ rpc: this.rpc, signatureProvider: signer });
            const transact = this.api.transact.bind(this.api);
            const url = this.waxSigningURL + "/cloud-wallet/signing/";
            this.api.transact = (transaction, namedParams) => __awaiter(this, void 0, void 0, function* () {
              if (!(yield this.canAutoSign(transaction))) {
                this.signingWindow = yield window.open(url, "WaxPopup", "height=800,width=600");
              }
              return yield transact(transaction, namedParams);
            });
            return this.userAccount;
          });
        }
        canAutoSign(transaction) {
          return __awaiter(this, void 0, void 0, function* () {
            const deserializedTransaction = transaction.actions ? transaction : yield this.api.deserializeTransactionWithActions(transaction);
            return !deserializedTransaction.actions.find((action) => {
              return !this.isWhitelisted(action);
            });
          });
        }
        isWhitelisted(action) {
          return !!this.whitelistedContracts.find((w) => {
            if (w.contract === action.account) {
              if (action.account === "eosio.token" && action.name === "transfer") {
                return w.recipients.includes(action.data.to);
              }
              return true;
            }
            return false;
          });
        }
        signing(transaction) {
          return __awaiter(this, void 0, void 0, function* () {
            if (yield this.canAutoSign(transaction)) {
              return this.signViaEndpoint(transaction).catch(() => this.signViaWindow(void 0, transaction));
            }
            return this.signViaWindow(this.signingWindow, transaction);
          });
        }
        signViaEndpoint(transaction) {
          return __awaiter(this, void 0, void 0, function* () {
            try {
              const response = yield fetch(this.waxAutoSigningURL + "signing", {
                body: JSON.stringify({
                  transaction: Object.values(transaction)
                }),
                credentials: "include",
                headers: {
                  "Content-Type": "application/json"
                },
                method: "POST"
              });
              if (!response.ok) {
                throw new Error(`Signing Endpoint Error ${response.status} ${response.statusText}`);
              }
              const data = yield response.json();
              if (data.processed && data.processed.except) {
                throw new Error(data);
              }
              return this.receiveSignatures({ data });
            } catch (e) {
              this.whitelistedContracts = [];
              throw e;
            }
          });
        }
        signViaWindow(window2, transaction) {
          return __awaiter(this, void 0, void 0, function* () {
            const confirmationWindow = yield this.waxEventSource.openEventSource(this.waxSigningURL + "/cloud-wallet/signing/", { type: "TRANSACTION", transaction }, window2);
            return this.waxEventSource.onceEvent(confirmationWindow, this.waxSigningURL, this.receiveSignatures.bind(this));
          });
        }
        receiveSignatures(event) {
          return __awaiter(this, void 0, void 0, function* () {
            if (event.data.type === "TX_SIGNED") {
              const { verified, signatures, whitelistedContracts } = event.data;
              if (!verified || signatures == null) {
                throw new Error("User declined to sign the transaction");
              }
              this.whitelistedContracts = whitelistedContracts || [];
              return signatures;
            } else if (event.data.type !== "READY") {
              throw new Error(`Unexpected response received when attempting signing: ${JSON.stringify(event.data, void 0, 2)}`);
            }
            return [];
          });
        }
      };
      exports.WaxJS = WaxJS;
    }
  });

  // node_modules/pako/lib/zlib/trees.js
  var require_trees = __commonJS({
    "node_modules/pako/lib/zlib/trees.js"(exports, module) {
      "use strict";
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;
      function zero(buf) {
        let len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
      var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
      var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
      var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);
      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      var d_code = (dist) => {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      };
      var put_short = (s, w) => {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
      };
      var send_bits = (s, value, length) => {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length;
        }
      };
      var send_code = (s, c, tree) => {
        send_bits(s, tree[c * 2], tree[c * 2 + 1]);
      };
      var bi_reverse = (code, len) => {
        let res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      };
      var bi_flush = (s) => {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      };
      var gen_bitlen = (s, desc) => {
        const tree = desc.dyn_tree;
        const max_code = desc.max_code;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const extra = desc.stat_desc.extra_bits;
        const base = desc.stat_desc.extra_base;
        const max_length = desc.stat_desc.max_length;
        let h;
        let n, m;
        let bits;
        let xbits;
        let f2;
        let overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f2 = tree[n * 2];
          s.opt_len += f2 * (bits + xbits);
          if (has_stree) {
            s.static_len += f2 * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      };
      var gen_codes = (tree, max_code, bl_count) => {
        const next_code = new Array(MAX_BITS + 1);
        let code = 0;
        let bits;
        let n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for (n = 0; n <= max_code; n++) {
          let len = tree[n * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
      };
      var tr_static_init = () => {
        let n;
        let bits;
        let length;
        let code;
        let dist;
        const bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code;
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      };
      var init_block = (s) => {
        let n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
      };
      var bi_windup = (s) => {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      };
      var copy_block = (s, buf, len, header) => {
        bi_windup(s);
        if (header) {
          put_short(s, len);
          put_short(s, ~len);
        }
        s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
        s.pending += len;
      };
      var smaller = (tree, n, m, depth) => {
        const _n2 = n * 2;
        const _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
      };
      var pqdownheap = (s, tree, k) => {
        const v = s.heap[k];
        let j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1;
        }
        s.heap[k] = v;
      };
      var compress_block = (s, ltree, dtree) => {
        let dist;
        let lc;
        let lx = 0;
        let code;
        let extra;
        if (s.last_lit !== 0) {
          do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);
              }
            }
          } while (lx < s.last_lit);
        }
        send_code(s, END_BLOCK, ltree);
      };
      var build_tree = (s, desc) => {
        const tree = desc.dyn_tree;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const elems = desc.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[1];
          s.heap[1] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1);
          m = s.heap[1];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[1] = node++;
          pqdownheap(s, tree, 1);
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      };
      var scan_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      };
      var send_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      };
      var build_bl_tree = (s) => {
        let max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      };
      var send_all_trees = (s, lcodes, dcodes, blcodes) => {
        let rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      };
      var detect_data_type = (s) => {
        let black_mask = 4093624447;
        let n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      };
      var static_init_done = false;
      var _tr_init = (s) => {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      };
      var _tr_stored_block = (s, buf, stored_len, last) => {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true);
      };
      var _tr_align = (s) => {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      };
      var _tr_flush_block = (s, buf, stored_len, last) => {
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
          bi_windup(s);
        }
      };
      var _tr_tally = (s, dist, lc) => {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.last_lit === s.lit_bufsize - 1;
      };
      module.exports._tr_init = _tr_init;
      module.exports._tr_stored_block = _tr_stored_block;
      module.exports._tr_flush_block = _tr_flush_block;
      module.exports._tr_tally = _tr_tally;
      module.exports._tr_align = _tr_align;
    }
  });

  // node_modules/pako/lib/zlib/adler32.js
  var require_adler32 = __commonJS({
    "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
      "use strict";
      var adler32 = (adler, buf, len, pos) => {
        let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      };
      module.exports = adler32;
    }
  });

  // node_modules/pako/lib/zlib/crc32.js
  var require_crc32 = __commonJS({
    "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
      "use strict";
      var makeTable = () => {
        let c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n] = c;
        }
        return table;
      };
      var crcTable = new Uint32Array(makeTable());
      var crc32 = (crc, buf, len, pos) => {
        const t = crcTable;
        const end = pos + len;
        crc ^= -1;
        for (let i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      };
      module.exports = crc32;
    }
  });

  // node_modules/pako/lib/zlib/messages.js
  var require_messages = __commonJS({
    "node_modules/pako/lib/zlib/messages.js"(exports, module) {
      "use strict";
      module.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      };
    }
  });

  // node_modules/pako/lib/zlib/constants.js
  var require_constants = __commonJS({
    "node_modules/pako/lib/zlib/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      };
    }
  });

  // node_modules/pako/lib/zlib/deflate.js
  var require_deflate = __commonJS({
    "node_modules/pako/lib/zlib/deflate.js"(exports, module) {
      "use strict";
      var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var msg = require_messages();
      var {
        Z_NO_FLUSH,
        Z_PARTIAL_FLUSH,
        Z_FULL_FLUSH,
        Z_FINISH,
        Z_BLOCK,
        Z_OK,
        Z_STREAM_END,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_BUF_ERROR,
        Z_DEFAULT_COMPRESSION,
        Z_FILTERED,
        Z_HUFFMAN_ONLY,
        Z_RLE,
        Z_FIXED,
        Z_DEFAULT_STRATEGY,
        Z_UNKNOWN,
        Z_DEFLATED
      } = require_constants();
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;
      var err = (strm, errorCode) => {
        strm.msg = msg[errorCode];
        return errorCode;
      };
      var rank = (f2) => {
        return (f2 << 1) - (f2 > 4 ? 9 : 0);
      };
      var zero = (buf) => {
        let len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      };
      var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
      var HASH = HASH_ZLIB;
      var flush_pending = (strm) => {
        const s = strm.state;
        let len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      };
      var flush_block_only = (s, last) => {
        _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      };
      var put_byte = (s, b) => {
        s.pending_buf[s.pending++] = b;
      };
      var putShortMSB = (s, b) => {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
      };
      var read_buf = (strm, buf, start, size) => {
        let len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      };
      var longest_match = (s, cur_match) => {
        let chain_length = s.max_chain_length;
        let scan = s.strstart;
        let match;
        let len;
        let best_len = s.prev_length;
        let nice_match = s.nice_match;
        const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        const _win = s.window;
        const wmask = s.w_mask;
        const prev = s.prev;
        const strend = s.strstart + MAX_MATCH;
        let scan_end1 = _win[scan + best_len - 1];
        let scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      };
      var fill_window = (s) => {
        const _w_size = s.w_size;
        let p, n, m, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
            while (s.insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      };
      var deflate_stored = (s, flush) => {
        let max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5;
        }
        for (; ; ) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          const max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_NEED_MORE;
      };
      var deflate_fast = (s, flush) => {
        let hash_head;
        let bflush;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
            }
          } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_slow = (s, flush) => {
        let hash_head;
        let bflush;
        let max_insert;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_rle = (s, flush) => {
        let bflush;
        let prev;
        let scan, strend;
        const _win = s.window;
        for (; ; ) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      var deflate_huff = (s, flush) => {
        let bflush;
        for (; ; ) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      };
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table = [
        new Config(0, 0, 0, 0, deflate_stored),
        new Config(4, 4, 8, 4, deflate_fast),
        new Config(4, 5, 16, 8, deflate_fast),
        new Config(4, 6, 32, 32, deflate_fast),
        new Config(4, 4, 16, 16, deflate_slow),
        new Config(8, 16, 32, 32, deflate_slow),
        new Config(8, 16, 128, 128, deflate_slow),
        new Config(8, 32, 128, 256, deflate_slow),
        new Config(32, 128, 258, 1024, deflate_slow),
        new Config(32, 258, 258, 4096, deflate_slow)
      ];
      var lm_init = (s) => {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      };
      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
        this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
        this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new Uint16Array(MAX_BITS + 1);
        this.heap = new Uint16Array(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new Uint16Array(2 * L_CODES + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      var deflateResetKeep = (strm) => {
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        const s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        _tr_init(s);
        return Z_OK;
      };
      var deflateReset = (strm) => {
        const ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      };
      var deflateSetHeader = (strm, head) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      };
      var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        let wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        const s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new Uint8Array(s.w_size * 2);
        s.head = new Uint16Array(s.hash_size);
        s.prev = new Uint16Array(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new Uint8Array(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      };
      var deflateInit = (strm, level) => {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      };
      var deflate = (strm, flush) => {
        let beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        const s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        s.strm = strm;
        const old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE;
            } else {
              put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
              put_byte(s, s.gzhead.time & 255);
              put_byte(s, s.gzhead.time >> 8 & 255);
              put_byte(s, s.gzhead.time >> 16 & 255);
              put_byte(s, s.gzhead.time >> 24 & 255);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 255);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 255);
                put_byte(s, s.gzhead.extra.length >> 8 & 255);
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE;
            }
          } else {
            let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            let level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0;
            } else if (s.level < 6) {
              level_flags = 1;
            } else if (s.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535);
            }
            strm.adler = 1;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 65535)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break;
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 255);
              s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE;
            }
          } else {
            s.status = NAME_STATE;
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE;
            }
          } else {
            s.status = COMMENT_STATE;
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.status = HCRC_STATE;
            }
          } else {
            s.status = HCRC_STATE;
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              strm.adler = 0;
              s.status = BUSY_STATE;
            }
          } else {
            s.status = BUSY_STATE;
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              _tr_align(s);
            } else if (flush !== Z_BLOCK) {
              _tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      };
      var deflateEnd = (strm) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      };
      var deflateSetDictionary = (strm, dictionary) => {
        let dictLength = dictionary.length;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const s = strm.state;
        const wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          let tmpDict = new Uint8Array(s.w_size);
          tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        const avail = strm.avail_in;
        const next = strm.next_in;
        const input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          let str = s.strstart;
          let n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      };
      module.exports.deflateInit = deflateInit;
      module.exports.deflateInit2 = deflateInit2;
      module.exports.deflateReset = deflateReset;
      module.exports.deflateResetKeep = deflateResetKeep;
      module.exports.deflateSetHeader = deflateSetHeader;
      module.exports.deflate = deflate;
      module.exports.deflateEnd = deflateEnd;
      module.exports.deflateSetDictionary = deflateSetDictionary;
      module.exports.deflateInfo = "pako deflate (from Nodeca project)";
    }
  });

  // node_modules/pako/lib/utils/common.js
  var require_common = __commonJS({
    "node_modules/pako/lib/utils/common.js"(exports, module) {
      "use strict";
      var _has = (obj, key) => {
        return Object.prototype.hasOwnProperty.call(obj, key);
      };
      module.exports.assign = function(obj) {
        const sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          const source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (const p in source) {
            if (_has(source, p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      };
      module.exports.flattenChunks = (chunks) => {
        let len = 0;
        for (let i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        const result = new Uint8Array(len);
        for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
          let chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      };
    }
  });

  // node_modules/pako/lib/utils/strings.js
  var require_strings = __commonJS({
    "node_modules/pako/lib/utils/strings.js"(exports, module) {
      "use strict";
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new Uint8Array(256);
      for (let q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
      }
      _utf8len[254] = _utf8len[254] = 1;
      module.exports.string2buf = (str) => {
        let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new Uint8Array(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i++] = c;
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          }
        }
        return buf;
      };
      var buf2binstring = (buf, len) => {
        if (len < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK) {
            return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
          }
        }
        let result = "";
        for (let i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      };
      module.exports.buf2string = (buf, max) => {
        let i, out;
        const len = max || buf.length;
        const utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
          let c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue;
          }
          let c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out++] = c;
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023;
          }
        }
        return buf2binstring(utf16buf, out);
      };
      module.exports.utf8border = (buf, max) => {
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        let pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
    }
  });

  // node_modules/pako/lib/zlib/zstream.js
  var require_zstream = __commonJS({
    "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
      "use strict";
      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module.exports = ZStream;
    }
  });

  // node_modules/pako/lib/deflate.js
  var require_deflate2 = __commonJS({
    "node_modules/pako/lib/deflate.js"(exports, module) {
      "use strict";
      var zlib_deflate = require_deflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var toString = Object.prototype.toString;
      var {
        Z_NO_FLUSH,
        Z_SYNC_FLUSH,
        Z_FULL_FLUSH,
        Z_FINISH,
        Z_OK,
        Z_STREAM_END,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_STRATEGY,
        Z_DEFLATED
      } = require_constants();
      function Deflate(options) {
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY
        }, options || {});
        let opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          let dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        let status, _flush_mode;
        if (this.ended) {
          return false;
        }
        if (flush_mode === ~~flush_mode)
          _flush_mode = flush_mode;
        else
          _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (; ; ) {
          if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
          }
          status = zlib_deflate.deflate(strm, _flush_mode);
          if (status === Z_STREAM_END) {
            if (strm.next_out > 0) {
              this.onData(strm.output.subarray(0, strm.next_out));
            }
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
          }
          if (strm.avail_out === 0) {
            this.onData(strm.output);
            continue;
          }
          if (_flush_mode > 0 && strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
          }
          if (strm.avail_in === 0)
            break;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          this.result = utils.flattenChunks(this.chunks);
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function deflate(input, options) {
        const deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || msg[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }
      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      module.exports.Deflate = Deflate;
      module.exports.deflate = deflate;
      module.exports.deflateRaw = deflateRaw;
      module.exports.gzip = gzip;
      module.exports.constants = require_constants();
    }
  });

  // node_modules/pako/lib/zlib/inffast.js
  var require_inffast = __commonJS({
    "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
      "use strict";
      var BAD = 30;
      var TYPE = 12;
      module.exports = function inflate_fast(strm, start) {
        let _in;
        let last;
        let _out;
        let beg;
        let end;
        let dmax;
        let wsize;
        let whave;
        let wnext;
        let s_window;
        let hold;
        let bits;
        let lcode;
        let dcode;
        let lmask;
        let dmask;
        let here;
        let op;
        let len;
        let dist;
        let from;
        let from_source;
        let input, output;
        const state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output[_out++] = here & 65535;
                } else if (op & 16) {
                  len = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (; ; ) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = here >>> 16 & 255;
                      if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                          op = dist - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break top;
                            }
                          }
                          from = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from += wsize - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          } else if (wnext < op) {
                            from += wsize + wnext - op;
                            op -= wnext;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = 0;
                              if (wnext < len) {
                                op = wnext;
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                          } else {
                            from += wnext - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                          while (len > 2) {
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            len -= 3;
                          }
                          if (len) {
                            output[_out++] = from_source[from++];
                            if (len > 1) {
                              output[_out++] = from_source[from++];
                            }
                          }
                        } else {
                          from = _out - dist;
                          do {
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            len -= 3;
                          } while (len > 2);
                          if (len) {
                            output[_out++] = output[from++];
                            if (len > 1) {
                              output[_out++] = output[from++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                      } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }
  });

  // node_modules/pako/lib/zlib/inftrees.js
  var require_inftrees = __commonJS({
    "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
      "use strict";
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = new Uint16Array([
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ]);
      var lext = new Uint8Array([
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ]);
      var dbase = new Uint16Array([
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ]);
      var dext = new Uint8Array([
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ]);
      var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
        const bits = opts.bits;
        let len = 0;
        let sym = 0;
        let min = 0, max = 0;
        let root = 0;
        let curr = 0;
        let drop = 0;
        let left = 0;
        let used = 0;
        let huff = 0;
        let incr;
        let fill;
        let low;
        let mask;
        let next;
        let base = null;
        let base_index = 0;
        let end;
        const count = new Uint16Array(MAXBITS + 1);
        const offs = new Uint16Array(MAXBITS + 1);
        let extra = null;
        let extra_index = 0;
        let here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }
        if (root > max) {
          root = max;
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }
        if (root < min) {
          root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19;
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256;
        } else {
          base = dbase;
          extra = dext;
          end = -1;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        for (; ; ) {
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len - drop;
          fill = 1 << curr;
          min = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
      };
      module.exports = inflate_table;
    }
  });

  // node_modules/pako/lib/zlib/inflate.js
  var require_inflate = __commonJS({
    "node_modules/pako/lib/zlib/inflate.js"(exports, module) {
      "use strict";
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var inflate_fast = require_inffast();
      var inflate_table = require_inftrees();
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var {
        Z_FINISH,
        Z_BLOCK,
        Z_TREES,
        Z_OK,
        Z_STREAM_END,
        Z_NEED_DICT,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_MEM_ERROR,
        Z_BUF_ERROR,
        Z_DEFLATED
      } = require_constants();
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;
      var zswap32 = (q) => {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      };
      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new Uint16Array(320);
        this.work = new Uint16Array(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }
      var inflateResetKeep = (strm) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
        state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
      };
      var inflateReset = (strm) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      };
      var inflateReset2 = (strm, windowBits) => {
        let wrap;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      };
      var inflateInit2 = (strm, windowBits) => {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        const state = new InflateState();
        strm.state = state;
        state.window = null;
        const ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null;
        }
        return ret;
      };
      var inflateInit = (strm) => {
        return inflateInit2(strm, DEF_WBITS);
      };
      var virgin = true;
      var lenfix;
      var distfix;
      var fixedtables = (state) => {
        if (virgin) {
          lenfix = new Int32Array(512);
          distfix = new Int32Array(32);
          let sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      };
      var updatewindow = (strm, src, end, copy) => {
        let dist;
        const state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new Uint8Array(state.wsize);
        }
        if (copy >= state.wsize) {
          state.window.set(src.subarray(end - state.wsize, end), 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy;
          }
          state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
          copy -= dist;
          if (copy) {
            state.window.set(src.subarray(end - copy, end), 0);
            state.wnext = copy;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      };
      var inflate = (strm, flush) => {
        let state;
        let input, output;
        let next;
        let put;
        let have, left;
        let hold;
        let bits;
        let _in, _out;
        let copy;
        let from;
        let from_source;
        let here = 0;
        let here_bits, here_op, here_val;
        let last_bits, last_op, last_val;
        let len;
        let ret;
        const hbuf = new Uint8Array(4);
        let opts;
        let n;
        const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave:
          for (; ; ) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                  state.check = 0;
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                state.flags = 0;
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                  strm.msg = "incorrect header check";
                  state.mode = BAD;
                  break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                  state.wbits = len;
                } else if (len > state.wbits) {
                  strm.msg = "invalid window size";
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << state.wbits;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 57344) {
                  strm.msg = "unknown header flags set";
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  hbuf[2] = hold >>> 16 & 255;
                  hbuf[3] = hold >>> 24 & 255;
                  state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = hold & 255;
                  state.head.os = hold >> 8;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              case EXLEN:
                if (state.flags & 1024) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA;
              case EXTRA:
                if (state.flags & 1024) {
                  copy = state.length;
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy) {
                    if (state.head) {
                      len = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Uint8Array(state.head.extra_len);
                      }
                      state.head.extra.set(input.subarray(next, next + copy), len);
                    }
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    state.length -= copy;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              case NAME:
                if (state.flags & 2048) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.name += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              case COMMENT:
                if (state.flags & 4096) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.comment += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              case HCRC:
                if (state.flags & 512) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.check & 65535)) {
                    strm.msg = "header crc mismatch";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = state.flags >> 9 & 1;
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                  strm.msg = "invalid stored block lengths";
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case COPY_:
                state.mode = COPY;
              case COPY:
                copy = state.length;
                if (copy) {
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  if (copy === 0) {
                    break inf_leave;
                  }
                  output.set(input.subarray(next, next + copy), put);
                  have -= copy;
                  next += copy;
                  left -= copy;
                  put += copy;
                  state.length -= copy;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = "too many length or distance symbols";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = hold & 7;
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = { bits: state.lenbits };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid code lengths set";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      len = state.lens[state.have - 1];
                      copy = 3 + (hold & 3);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 3 + (hold & 7);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 11 + (hold & 127);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy > state.nlen + state.ndist) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    while (copy--) {
                      state.lens[state.have++] = len;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = "invalid code -- missing end-of-block";
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = { bits: state.lenbits };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid literal/lengths set";
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = { bits: state.distbits };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid distances set";
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case LEN_:
                state.mode = LEN;
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inflate_fast(strm, _out);
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              case DIST:
                for (; ; ) {
                  here = state.distcode[hold & (1 << state.distbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                  copy = state.offset - copy;
                  if (copy > state.whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy > state.wnext) {
                    copy -= state.wnext;
                    from = state.wsize - copy;
                  } else {
                    from = state.wnext - copy;
                  }
                  if (copy > state.length) {
                    copy = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output;
                  from = put - state.offset;
                  copy = state.length;
                }
                if (copy > left) {
                  copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                  output[put++] = from_source[from++];
                } while (--copy);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (_out) {
                    strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                  }
                  _out = left;
                  if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = "incorrect data check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.total & 4294967295)) {
                    strm.msg = "incorrect length check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR;
              case SYNC:
              default:
                return Z_STREAM_ERROR;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      };
      var inflateEnd = (strm) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        let state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK;
      };
      var inflateGetHeader = (strm, head) => {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        const state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
      };
      var inflateSetDictionary = (strm, dictionary) => {
        const dictLength = dictionary.length;
        let state;
        let dictid;
        let ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
      };
      module.exports.inflateReset = inflateReset;
      module.exports.inflateReset2 = inflateReset2;
      module.exports.inflateResetKeep = inflateResetKeep;
      module.exports.inflateInit = inflateInit;
      module.exports.inflateInit2 = inflateInit2;
      module.exports.inflate = inflate;
      module.exports.inflateEnd = inflateEnd;
      module.exports.inflateGetHeader = inflateGetHeader;
      module.exports.inflateSetDictionary = inflateSetDictionary;
      module.exports.inflateInfo = "pako inflate (from Nodeca project)";
    }
  });

  // node_modules/pako/lib/zlib/gzheader.js
  var require_gzheader = __commonJS({
    "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
      "use strict";
      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
      }
      module.exports = GZheader;
    }
  });

  // node_modules/pako/lib/inflate.js
  var require_inflate2 = __commonJS({
    "node_modules/pako/lib/inflate.js"(exports, module) {
      "use strict";
      var zlib_inflate = require_inflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var GZheader = require_gzheader();
      var toString = Object.prototype.toString;
      var {
        Z_NO_FLUSH,
        Z_FINISH,
        Z_OK,
        Z_STREAM_END,
        Z_NEED_DICT,
        Z_STREAM_ERROR,
        Z_DATA_ERROR,
        Z_MEM_ERROR
      } = require_constants();
      function Inflate(options) {
        this.options = utils.assign({
          chunkSize: 1024 * 64,
          windowBits: 15,
          to: ""
        }, options || {});
        const opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15;
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this.header = new GZheader();
        zlib_inflate.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
          if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
          }
          if (opt.raw) {
            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }
          }
        }
      }
      Inflate.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const dictionary = this.options.dictionary;
        let status, _flush_mode, last_avail_out;
        if (this.ended)
          return false;
        if (flush_mode === ~~flush_mode)
          _flush_mode = flush_mode;
        else
          _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (; ; ) {
          if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_inflate.inflate(strm, _flush_mode);
          if (status === Z_NEED_DICT && dictionary) {
            status = zlib_inflate.inflateSetDictionary(strm, dictionary);
            if (status === Z_OK) {
              status = zlib_inflate.inflate(strm, _flush_mode);
            } else if (status === Z_DATA_ERROR) {
              status = Z_NEED_DICT;
            }
          }
          while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
            zlib_inflate.inflateReset(strm);
            status = zlib_inflate.inflate(strm, _flush_mode);
          }
          switch (status) {
            case Z_STREAM_ERROR:
            case Z_DATA_ERROR:
            case Z_NEED_DICT:
            case Z_MEM_ERROR:
              this.onEnd(status);
              this.ended = true;
              return false;
          }
          last_avail_out = strm.avail_out;
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === Z_STREAM_END) {
              if (this.options.to === "string") {
                let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                let tail = strm.next_out - next_out_utf8;
                let utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail)
                  strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                this.onData(utf8str);
              } else {
                this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
              }
            }
          }
          if (status === Z_OK && last_avail_out === 0)
            continue;
          if (status === Z_STREAM_END) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return true;
          }
          if (strm.avail_in === 0)
            break;
        }
        return true;
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function inflate(input, options) {
        const inflator = new Inflate(options);
        inflator.push(input);
        if (inflator.err)
          throw inflator.msg || msg[inflator.err];
        return inflator.result;
      }
      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
      }
      module.exports.Inflate = Inflate;
      module.exports.inflate = inflate;
      module.exports.inflateRaw = inflateRaw;
      module.exports.ungzip = inflate;
      module.exports.constants = require_constants();
    }
  });

  // node_modules/pako/index.js
  var require_pako = __commonJS({
    "node_modules/pako/index.js"(exports, module) {
      "use strict";
      var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
      var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
      var constants = require_constants();
      module.exports.Deflate = Deflate;
      module.exports.deflate = deflate;
      module.exports.deflateRaw = deflateRaw;
      module.exports.gzip = gzip;
      module.exports.Inflate = Inflate;
      module.exports.inflate = inflate;
      module.exports.inflateRaw = inflateRaw;
      module.exports.ungzip = ungzip;
      module.exports.constants = constants;
    }
  });

  // node_modules/minimalistic-assert/index.js
  var require_minimalistic_assert = __commonJS({
    "node_modules/minimalistic-assert/index.js"(exports, module) {
      module.exports = assert;
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/hash.js/lib/hash/utils.js
  var require_utils = __commonJS({
    "node_modules/hash.js/lib/hash/utils.js"(exports) {
      "use strict";
      var assert = require_minimalistic_assert();
      var inherits = require_inherits_browser();
      exports.inherits = inherits;
      function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
          return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              if (c < 128) {
                res[p++] = c;
              } else if (c < 2048) {
                res[p++] = c >> 6 | 192;
                res[p++] = c & 63 | 128;
              } else if (isSurrogatePair(msg, i)) {
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                res[p++] = c >> 18 | 240;
                res[p++] = c >> 12 & 63 | 128;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              } else {
                res[p++] = c >> 12 | 224;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i = 0; i < msg.length; i += 2)
              res.push(parseInt(msg[i] + msg[i + 1], 16));
          }
        } else {
          for (i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
        }
        return res;
      }
      exports.toArray = toArray;
      function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      exports.toHex = toHex;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      exports.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          var w = msg[i];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      exports.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i] = w >>> 0;
        }
        return res;
      }
      exports.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
          var m = msg[i];
          if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 255;
            res[k + 2] = m >>> 8 & 255;
            res[k + 3] = m & 255;
          } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 255;
            res[k + 1] = m >>> 8 & 255;
            res[k] = m & 255;
          }
        }
        return res;
      }
      exports.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      exports.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      exports.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      exports.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      exports.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      exports.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      exports.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
      }
      exports.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      exports.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
      }
      exports.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
      }
      exports.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      exports.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports.shr64_lo = shr64_lo;
    }
  });

  // node_modules/hash.js/lib/hash/common.js
  var require_common2 = __commonJS({
    "node_modules/hash.js/lib/hash/common.js"(exports) {
      "use strict";
      var utils = require_utils();
      var assert = require_minimalistic_assert();
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r, this.endian);
          for (var i = 0; i < msg.length; i += this._delta32)
            this._update(msg, i, i + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k = bytes - (len + this.padLength) % bytes;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++)
          res[i] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t = 8; t < this.padLength; t++)
            res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = len >>> 24 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len & 255;
        } else {
          res[i++] = len & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 24 & 255;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          for (t = 8; t < this.padLength; t++)
            res[i++] = 0;
        }
        return res;
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/common.js
  var require_common3 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
      "use strict";
      var utils = require_utils();
      var rotr32 = utils.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      exports.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      exports.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      exports.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      exports.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      exports.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      exports.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      exports.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      exports.g1_256 = g1_256;
    }
  });

  // node_modules/hash.js/lib/hash/sha/1.js
  var require__ = __commonJS({
    "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var common = require_common2();
      var shaCommon = require_common3();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_5 = utils.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
      ];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [
          1732584193,
          4023233417,
          2562383102,
          271733878,
          3285377520
        ];
        this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
          var s = ~~(i / 20);
          var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
          e = d;
          d = c;
          c = rotl32(b, 30);
          b = a;
          a = t;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/256.js
  var require__2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var common = require_common2();
      var shaCommon = require_common3();
      var assert = require_minimalistic_assert();
      var sum32 = utils.sum32;
      var sum32_4 = utils.sum32_4;
      var sum32_5 = utils.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256();
        BlockHash.call(this);
        this.h = [
          1779033703,
          3144134277,
          1013904242,
          2773480762,
          1359893119,
          2600822924,
          528734635,
          1541459225
        ];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils.inherits(SHA256, BlockHash);
      module.exports = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f2 = this.h[5];
        var g = this.h[6];
        var h = this.h[7];
        assert(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
          var T1 = sum32_5(h, s1_256(e), ch32(e, f2, g), this.k[i], W[i]);
          var T2 = sum32(s0_256(a), maj32(a, b, c));
          h = g;
          g = f2;
          f2 = e;
          e = sum32(d, T1);
          d = c;
          c = b;
          b = a;
          a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f2);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h);
      };
      SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/224.js
  var require__3 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var SHA256 = require__2();
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA256.call(this);
        this.h = [
          3238371032,
          914150663,
          812702999,
          4144912697,
          4290775857,
          1750603025,
          1694076839,
          3204075428
        ];
      }
      utils.inherits(SHA224, SHA256);
      module.exports = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/512.js
  var require__4 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var common = require_common2();
      var assert = require_minimalistic_assert();
      var rotr64_hi = utils.rotr64_hi;
      var rotr64_lo = utils.rotr64_lo;
      var shr64_hi = utils.shr64_hi;
      var shr64_lo = utils.shr64_lo;
      var sum64 = utils.sum64;
      var sum64_hi = utils.sum64_hi;
      var sum64_lo = utils.sum64_lo;
      var sum64_4_hi = utils.sum64_4_hi;
      var sum64_4_lo = utils.sum64_4_lo;
      var sum64_5_hi = utils.sum64_5_hi;
      var sum64_5_lo = utils.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [
          1779033703,
          4089235720,
          3144134277,
          2227873595,
          1013904242,
          4271175723,
          2773480762,
          1595750129,
          1359893119,
          2917565137,
          2600822924,
          725511199,
          528734635,
          4215389547,
          1541459225,
          327033209
        ];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils.inherits(SHA512, BlockHash);
      module.exports = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
          W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i];
          var c3_lo = this.k[i + 1];
          var c4_hi = W[i];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
    }
  });

  // node_modules/hash.js/lib/hash/sha/384.js
  var require__5 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var SHA512 = require__4();
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [
          3418070365,
          3238371032,
          1654270250,
          914150663,
          2438529370,
          812702999,
          355462360,
          4144912697,
          1731405415,
          4290775857,
          2394180231,
          1750603025,
          3675008525,
          1694076839,
          1203062813,
          3204075428
        ];
      }
      utils.inherits(SHA384, SHA512);
      module.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha.js
  var require_sha = __commonJS({
    "node_modules/hash.js/lib/hash/sha.js"(exports) {
      "use strict";
      exports.sha1 = require__();
      exports.sha224 = require__3();
      exports.sha256 = require__2();
      exports.sha384 = require__5();
      exports.sha512 = require__4();
    }
  });

  // node_modules/hash.js/lib/hash/ripemd.js
  var require_ripemd2 = __commonJS({
    "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
      "use strict";
      var utils = require_utils();
      var common = require_common2();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_3 = utils.sum32_3;
      var sum32_4 = utils.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils.inherits(RIPEMD160, BlockHash);
      exports.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
          var T = sum32(rotl32(sum32_4(A, f2(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
          A = E;
          E = D;
          D = rotl32(C, 10);
          C = B;
          B = T;
          T = sum32(rotl32(sum32_4(Ah, f2(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f2(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var rh = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var s = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sh = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
    }
  });

  // node_modules/hash.js/lib/hash/hmac.js
  var require_hmac = __commonJS({
    "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var assert = require_minimalistic_assert();
      function Hmac(hash, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash, key, enc);
        this.Hash = hash;
        this.blockSize = hash.blockSize / 8;
        this.outSize = hash.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key, enc));
      }
      module.exports = Hmac;
      Hmac.prototype._init = function init(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++)
          key.push(0);
        for (i = 0; i < key.length; i++)
          key[i] ^= 54;
        this.inner = new this.Hash().update(key);
        for (i = 0; i < key.length; i++)
          key[i] ^= 106;
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }
  });

  // node_modules/hash.js/lib/hash.js
  var require_hash = __commonJS({
    "node_modules/hash.js/lib/hash.js"(exports) {
      var hash = exports;
      hash.utils = require_utils();
      hash.common = require_common2();
      hash.sha = require_sha();
      hash.ripemd = require_ripemd2();
      hash.hmac = require_hmac();
      hash.sha1 = hash.sha.sha1;
      hash.sha256 = hash.sha.sha256;
      hash.sha224 = hash.sha.sha224;
      hash.sha384 = hash.sha.sha384;
      hash.sha512 = hash.sha.sha512;
      hash.ripemd160 = hash.ripemd.ripemd160;
    }
  });

  // node_modules/eosjs/dist/ripemd.js
  var require_ripemd3 = __commonJS({
    "node_modules/eosjs/dist/ripemd.js"(exports, module) {
      "use strict";
      var _slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var RIPEMD160 = function() {
        function RIPEMD1602() {
          _classCallCheck(this, RIPEMD1602);
        }
        _createClass(RIPEMD1602, null, [{
          key: "get_n_pad_bytes",
          value: function get_n_pad_bytes(message_size) {
            return 64 - (message_size + 8 & 63);
          }
        }, {
          key: "pad",
          value: function pad(message) {
            var message_size = message.byteLength;
            var n_pad = RIPEMD1602.get_n_pad_bytes(message_size);
            var divmod = function divmod2(dividend, divisor) {
              return [Math.floor(dividend / divisor), dividend % divisor];
            };
            var _divmod$map = divmod(message_size, 536870912).map(function(x, index) {
              return index ? x * 8 : x;
            }), _divmod$map2 = _slicedToArray(_divmod$map, 2), msg_bit_size_most = _divmod$map2[0], msg_bit_size_least = _divmod$map2[1];
            var padded = new Uint8Array(message_size + n_pad + 8);
            padded.set(new Uint8Array(message), 0);
            var data_view = new DataView(padded.buffer);
            data_view.setUint8(message_size, 128);
            data_view.setUint32(message_size + n_pad, msg_bit_size_least, true);
            data_view.setUint32(message_size + n_pad + 4, msg_bit_size_most, true);
            return padded.buffer;
          }
        }, {
          key: "f",
          value: function f2(j, x, y, z) {
            if (0 <= j && j <= 15) {
              return x ^ y ^ z;
            }
            if (16 <= j && j <= 31) {
              return x & y | ~x & z;
            }
            if (32 <= j && j <= 47) {
              return (x | ~y) ^ z;
            }
            if (48 <= j && j <= 63) {
              return x & z | y & ~z;
            }
            if (64 <= j && j <= 79) {
              return x ^ (y | ~z);
            }
          }
        }, {
          key: "K",
          value: function K(j) {
            if (0 <= j && j <= 15) {
              return 0;
            }
            if (16 <= j && j <= 31) {
              return 1518500249;
            }
            if (32 <= j && j <= 47) {
              return 1859775393;
            }
            if (48 <= j && j <= 63) {
              return 2400959708;
            }
            if (64 <= j && j <= 79) {
              return 2840853838;
            }
          }
        }, {
          key: "KP",
          value: function KP(j) {
            if (0 <= j && j <= 15) {
              return 1352829926;
            }
            if (16 <= j && j <= 31) {
              return 1548603684;
            }
            if (32 <= j && j <= 47) {
              return 1836072691;
            }
            if (48 <= j && j <= 63) {
              return 2053994217;
            }
            if (64 <= j && j <= 79) {
              return 0;
            }
          }
        }, {
          key: "add_modulo32",
          value: function add_modulo32() {
            return Array.from(arguments).reduce(function(a, b) {
              return a + b;
            }, 0) | 0;
          }
        }, {
          key: "rol32",
          value: function rol32(value, count) {
            return value << count | value >>> 32 - count;
          }
        }, {
          key: "hash",
          value: function hash(message) {
            var padded = RIPEMD1602.pad(message);
            var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
            var rP = [
              5,
              14,
              7,
              0,
              9,
              2,
              11,
              4,
              13,
              6,
              15,
              8,
              1,
              10,
              3,
              12,
              6,
              11,
              3,
              7,
              0,
              13,
              5,
              10,
              14,
              15,
              8,
              12,
              4,
              9,
              1,
              2,
              15,
              5,
              1,
              3,
              7,
              14,
              6,
              9,
              11,
              8,
              12,
              2,
              10,
              0,
              4,
              13,
              8,
              6,
              4,
              1,
              3,
              11,
              15,
              0,
              5,
              12,
              2,
              13,
              9,
              7,
              10,
              14,
              12,
              15,
              10,
              4,
              1,
              5,
              8,
              7,
              6,
              2,
              13,
              14,
              0,
              3,
              9,
              11
            ];
            var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
            var sP = [
              8,
              9,
              9,
              11,
              13,
              15,
              15,
              5,
              7,
              7,
              8,
              11,
              14,
              14,
              12,
              6,
              9,
              13,
              15,
              7,
              12,
              8,
              9,
              11,
              7,
              7,
              12,
              7,
              6,
              15,
              13,
              11,
              9,
              7,
              15,
              11,
              8,
              6,
              6,
              14,
              12,
              13,
              5,
              14,
              13,
              13,
              7,
              5,
              15,
              5,
              8,
              11,
              14,
              14,
              6,
              14,
              6,
              9,
              12,
              9,
              12,
              5,
              15,
              8,
              8,
              5,
              12,
              9,
              12,
              5,
              14,
              6,
              8,
              13,
              6,
              5,
              15,
              13,
              11,
              11
            ];
            var word_size = 4;
            var block_size = 64;
            var t = padded.byteLength / block_size;
            var X = new Array(t).fill(void 0).map(function(_, i2) {
              return function(j2) {
                return new DataView(padded, i2 * block_size, block_size).getUint32(j2 * word_size, true);
              };
            });
            var h = [
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ];
            for (var i = 0; i < t; ++i) {
              var A = h[0], B = h[1], C = h[2], D = h[3], E = h[4];
              var AP = A, BP = B, CP = C, DP = D, EP = E;
              for (var j = 0; j < 80; ++j) {
                var _T = RIPEMD1602.add_modulo32(RIPEMD1602.rol32(RIPEMD1602.add_modulo32(A, RIPEMD1602.f(j, B, C, D), X[i](r[j]), RIPEMD1602.K(j)), s[j]), E);
                A = E;
                E = D;
                D = RIPEMD1602.rol32(C, 10);
                C = B;
                B = _T;
                _T = RIPEMD1602.add_modulo32(RIPEMD1602.rol32(RIPEMD1602.add_modulo32(AP, RIPEMD1602.f(79 - j, BP, CP, DP), X[i](rP[j]), RIPEMD1602.KP(j)), sP[j]), EP);
                AP = EP;
                EP = DP;
                DP = RIPEMD1602.rol32(CP, 10);
                CP = BP;
                BP = _T;
              }
              var T = RIPEMD1602.add_modulo32(h[1], C, DP);
              h[1] = RIPEMD1602.add_modulo32(h[2], D, EP);
              h[2] = RIPEMD1602.add_modulo32(h[3], E, AP);
              h[3] = RIPEMD1602.add_modulo32(h[4], A, BP);
              h[4] = RIPEMD1602.add_modulo32(h[0], B, CP);
              h[0] = T;
            }
            var result = new ArrayBuffer(20);
            var data_view = new DataView(result);
            h.forEach(function(h_i, i2) {
              return data_view.setUint32(i2 * 4, h_i, true);
            });
            return result;
          }
        }]);
        return RIPEMD1602;
      }();
      module.exports = {
        RIPEMD160
      };
    }
  });

  // node_modules/eosjs/dist/eosjs-numeric.js
  var require_eosjs_numeric2 = __commonJS({
    "node_modules/eosjs/dist/eosjs-numeric.js"(exports) {
      "use strict";
      var __read = exports && exports.__read || function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
        return to;
      };
      var __values = exports && exports.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.signatureToString = exports.stringToSignature = exports.privateKeyToString = exports.privateKeyToLegacyString = exports.stringToPrivateKey = exports.convertLegacyPublicKeys = exports.convertLegacyPublicKey = exports.publicKeyToString = exports.publicKeyToLegacyString = exports.stringToPublicKey = exports.signatureDataSize = exports.privateKeyDataSize = exports.publicKeyDataSize = exports.KeyType = exports.base64ToBinary = exports.binaryToBase58 = exports.base58ToBinary = exports.signedBinaryToDecimal = exports.binaryToDecimal = exports.signedDecimalToBinary = exports.decimalToBinary = exports.negate = exports.isNegative = void 0;
      var hash_js_1 = require_hash();
      var ripemd160 = require_ripemd3().RIPEMD160.hash;
      var base58Chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var create_base58_map = function() {
        var base58M = Array(256).fill(-1);
        for (var i = 0; i < base58Chars.length; ++i) {
          base58M[base58Chars.charCodeAt(i)] = i;
        }
        return base58M;
      };
      var base58Map = create_base58_map();
      var create_base64_map = function() {
        var base64M = Array(256).fill(-1);
        for (var i = 0; i < base64Chars.length; ++i) {
          base64M[base64Chars.charCodeAt(i)] = i;
        }
        base64M["=".charCodeAt(0)] = 0;
        return base64M;
      };
      var base64Map = create_base64_map();
      var isNegative = function(bignum) {
        return (bignum[bignum.length - 1] & 128) !== 0;
      };
      exports.isNegative = isNegative;
      var negate = function(bignum) {
        var carry = 1;
        for (var i = 0; i < bignum.length; ++i) {
          var x = (~bignum[i] & 255) + carry;
          bignum[i] = x;
          carry = x >> 8;
        }
      };
      exports.negate = negate;
      var decimalToBinary = function(size, s) {
        var result = new Uint8Array(size);
        for (var i = 0; i < s.length; ++i) {
          var srcDigit = s.charCodeAt(i);
          if (srcDigit < "0".charCodeAt(0) || srcDigit > "9".charCodeAt(0)) {
            throw new Error("invalid number");
          }
          var carry = srcDigit - "0".charCodeAt(0);
          for (var j = 0; j < size; ++j) {
            var x = result[j] * 10 + carry;
            result[j] = x;
            carry = x >> 8;
          }
          if (carry) {
            throw new Error("number is out of range");
          }
        }
        return result;
      };
      exports.decimalToBinary = decimalToBinary;
      var signedDecimalToBinary = function(size, s) {
        var negative = s[0] === "-";
        if (negative) {
          s = s.substr(1);
        }
        var result = exports.decimalToBinary(size, s);
        if (negative) {
          exports.negate(result);
          if (!exports.isNegative(result)) {
            throw new Error("number is out of range");
          }
        } else if (exports.isNegative(result)) {
          throw new Error("number is out of range");
        }
        return result;
      };
      exports.signedDecimalToBinary = signedDecimalToBinary;
      var binaryToDecimal = function(bignum, minDigits) {
        if (minDigits === void 0) {
          minDigits = 1;
        }
        var result = Array(minDigits).fill("0".charCodeAt(0));
        for (var i = bignum.length - 1; i >= 0; --i) {
          var carry = bignum[i];
          for (var j = 0; j < result.length; ++j) {
            var x = (result[j] - "0".charCodeAt(0) << 8) + carry;
            result[j] = "0".charCodeAt(0) + x % 10;
            carry = x / 10 | 0;
          }
          while (carry) {
            result.push("0".charCodeAt(0) + carry % 10);
            carry = carry / 10 | 0;
          }
        }
        result.reverse();
        return String.fromCharCode.apply(String, __spreadArray([], __read(result)));
      };
      exports.binaryToDecimal = binaryToDecimal;
      var signedBinaryToDecimal = function(bignum, minDigits) {
        if (minDigits === void 0) {
          minDigits = 1;
        }
        if (exports.isNegative(bignum)) {
          var x = bignum.slice();
          exports.negate(x);
          return "-" + exports.binaryToDecimal(x, minDigits);
        }
        return exports.binaryToDecimal(bignum, minDigits);
      };
      exports.signedBinaryToDecimal = signedBinaryToDecimal;
      var base58ToBinaryVarSize = function(s) {
        var e_1, _a;
        var result = [];
        for (var i = 0; i < s.length; ++i) {
          var carry = base58Map[s.charCodeAt(i)];
          if (carry < 0) {
            throw new Error("invalid base-58 value");
          }
          for (var j = 0; j < result.length; ++j) {
            var x = result[j] * 58 + carry;
            result[j] = x & 255;
            carry = x >> 8;
          }
          if (carry) {
            result.push(carry);
          }
        }
        try {
          for (var s_1 = __values(s), s_1_1 = s_1.next(); !s_1_1.done; s_1_1 = s_1.next()) {
            var ch = s_1_1.value;
            if (ch === "1") {
              result.push(0);
            } else {
              break;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (s_1_1 && !s_1_1.done && (_a = s_1.return))
              _a.call(s_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        result.reverse();
        return new Uint8Array(result);
      };
      var base58ToBinary = function(size, s) {
        if (!size) {
          return base58ToBinaryVarSize(s);
        }
        var result = new Uint8Array(size);
        for (var i = 0; i < s.length; ++i) {
          var carry = base58Map[s.charCodeAt(i)];
          if (carry < 0) {
            throw new Error("invalid base-58 value");
          }
          for (var j = 0; j < size; ++j) {
            var x = result[j] * 58 + carry;
            result[j] = x;
            carry = x >> 8;
          }
          if (carry) {
            throw new Error("base-58 value is out of range");
          }
        }
        result.reverse();
        return result;
      };
      exports.base58ToBinary = base58ToBinary;
      var binaryToBase58 = function(bignum, minDigits) {
        var e_2, _a, e_3, _b;
        if (minDigits === void 0) {
          minDigits = 1;
        }
        var result = [];
        try {
          for (var bignum_1 = __values(bignum), bignum_1_1 = bignum_1.next(); !bignum_1_1.done; bignum_1_1 = bignum_1.next()) {
            var byte = bignum_1_1.value;
            var carry = byte;
            for (var j = 0; j < result.length; ++j) {
              var x = (base58Map[result[j]] << 8) + carry;
              result[j] = base58Chars.charCodeAt(x % 58);
              carry = x / 58 | 0;
            }
            while (carry) {
              result.push(base58Chars.charCodeAt(carry % 58));
              carry = carry / 58 | 0;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (bignum_1_1 && !bignum_1_1.done && (_a = bignum_1.return))
              _a.call(bignum_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        try {
          for (var bignum_2 = __values(bignum), bignum_2_1 = bignum_2.next(); !bignum_2_1.done; bignum_2_1 = bignum_2.next()) {
            var byte = bignum_2_1.value;
            if (byte) {
              break;
            } else {
              result.push("1".charCodeAt(0));
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (bignum_2_1 && !bignum_2_1.done && (_b = bignum_2.return))
              _b.call(bignum_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        result.reverse();
        return String.fromCharCode.apply(String, __spreadArray([], __read(result)));
      };
      exports.binaryToBase58 = binaryToBase58;
      var base64ToBinary = function(s) {
        var len = s.length;
        if ((len & 3) === 1 && s[len - 1] === "=") {
          len -= 1;
        }
        if ((len & 3) !== 0) {
          throw new Error("base-64 value is not padded correctly");
        }
        var groups = len >> 2;
        var bytes = groups * 3;
        if (len > 0 && s[len - 1] === "=") {
          if (s[len - 2] === "=") {
            bytes -= 2;
          } else {
            bytes -= 1;
          }
        }
        var result = new Uint8Array(bytes);
        for (var group = 0; group < groups; ++group) {
          var digit0 = base64Map[s.charCodeAt(group * 4 + 0)];
          var digit1 = base64Map[s.charCodeAt(group * 4 + 1)];
          var digit2 = base64Map[s.charCodeAt(group * 4 + 2)];
          var digit3 = base64Map[s.charCodeAt(group * 4 + 3)];
          result[group * 3 + 0] = digit0 << 2 | digit1 >> 4;
          if (group * 3 + 1 < bytes) {
            result[group * 3 + 1] = (digit1 & 15) << 4 | digit2 >> 2;
          }
          if (group * 3 + 2 < bytes) {
            result[group * 3 + 2] = (digit2 & 3) << 6 | digit3;
          }
        }
        return result;
      };
      exports.base64ToBinary = base64ToBinary;
      var KeyType;
      (function(KeyType2) {
        KeyType2[KeyType2["k1"] = 0] = "k1";
        KeyType2[KeyType2["r1"] = 1] = "r1";
        KeyType2[KeyType2["wa"] = 2] = "wa";
      })(KeyType = exports.KeyType || (exports.KeyType = {}));
      exports.publicKeyDataSize = 33;
      exports.privateKeyDataSize = 32;
      exports.signatureDataSize = 65;
      var digestSuffixRipemd160 = function(data, suffix) {
        var d = new Uint8Array(data.length + suffix.length);
        for (var i = 0; i < data.length; ++i) {
          d[i] = data[i];
        }
        for (var i = 0; i < suffix.length; ++i) {
          d[data.length + i] = suffix.charCodeAt(i);
        }
        return ripemd160(d);
      };
      var stringToKey = function(s, type, size, suffix) {
        var whole = exports.base58ToBinary(size ? size + 4 : 0, s);
        var result = { type, data: new Uint8Array(whole.buffer, 0, whole.length - 4) };
        var digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));
        if (digest[0] !== whole[whole.length - 4] || digest[1] !== whole[whole.length - 3] || digest[2] !== whole[whole.length - 2] || digest[3] !== whole[whole.length - 1]) {
          throw new Error("checksum doesn't match");
        }
        return result;
      };
      var keyToString = function(key, suffix, prefix) {
        var digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));
        var whole = new Uint8Array(key.data.length + 4);
        for (var i = 0; i < key.data.length; ++i) {
          whole[i] = key.data[i];
        }
        for (var i = 0; i < 4; ++i) {
          whole[i + key.data.length] = digest[i];
        }
        return prefix + exports.binaryToBase58(whole);
      };
      var stringToPublicKey = function(s) {
        if (typeof s !== "string") {
          throw new Error("expected string containing public key");
        }
        if (s.substr(0, 3) === "EOS") {
          var whole = exports.base58ToBinary(exports.publicKeyDataSize + 4, s.substr(3));
          var key = { type: KeyType.k1, data: new Uint8Array(exports.publicKeyDataSize) };
          for (var i = 0; i < exports.publicKeyDataSize; ++i) {
            key.data[i] = whole[i];
          }
          var digest = new Uint8Array(ripemd160(key.data));
          if (digest[0] !== whole[exports.publicKeyDataSize] || digest[1] !== whole[34] || digest[2] !== whole[35] || digest[3] !== whole[36]) {
            throw new Error("checksum doesn't match");
          }
          return key;
        } else if (s.substr(0, 7) === "PUB_K1_") {
          return stringToKey(s.substr(7), KeyType.k1, exports.publicKeyDataSize, "K1");
        } else if (s.substr(0, 7) === "PUB_R1_") {
          return stringToKey(s.substr(7), KeyType.r1, exports.publicKeyDataSize, "R1");
        } else if (s.substr(0, 7) === "PUB_WA_") {
          return stringToKey(s.substr(7), KeyType.wa, 0, "WA");
        } else {
          throw new Error("unrecognized public key format");
        }
      };
      exports.stringToPublicKey = stringToPublicKey;
      var publicKeyToLegacyString = function(key) {
        if (key.type === KeyType.k1 && key.data.length === exports.publicKeyDataSize) {
          return keyToString(key, "", "EOS");
        } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {
          throw new Error("Key format not supported in legacy conversion");
        } else {
          throw new Error("unrecognized public key format");
        }
      };
      exports.publicKeyToLegacyString = publicKeyToLegacyString;
      var publicKeyToString = function(key) {
        if (key.type === KeyType.k1 && key.data.length === exports.publicKeyDataSize) {
          return keyToString(key, "K1", "PUB_K1_");
        } else if (key.type === KeyType.r1 && key.data.length === exports.publicKeyDataSize) {
          return keyToString(key, "R1", "PUB_R1_");
        } else if (key.type === KeyType.wa) {
          return keyToString(key, "WA", "PUB_WA_");
        } else {
          throw new Error("unrecognized public key format");
        }
      };
      exports.publicKeyToString = publicKeyToString;
      var convertLegacyPublicKey = function(s) {
        if (s.substr(0, 3) === "EOS") {
          return exports.publicKeyToString(exports.stringToPublicKey(s));
        }
        return s;
      };
      exports.convertLegacyPublicKey = convertLegacyPublicKey;
      var convertLegacyPublicKeys = function(keys) {
        return keys.map(exports.convertLegacyPublicKey);
      };
      exports.convertLegacyPublicKeys = convertLegacyPublicKeys;
      var stringToPrivateKey = function(s) {
        if (typeof s !== "string") {
          throw new Error("expected string containing private key");
        }
        if (s.substr(0, 7) === "PVT_R1_") {
          return stringToKey(s.substr(7), KeyType.r1, exports.privateKeyDataSize, "R1");
        } else if (s.substr(0, 7) === "PVT_K1_") {
          return stringToKey(s.substr(7), KeyType.k1, exports.privateKeyDataSize, "K1");
        } else {
          var whole = exports.base58ToBinary(exports.privateKeyDataSize + 5, s);
          var key = { type: KeyType.k1, data: new Uint8Array(exports.privateKeyDataSize) };
          if (whole[0] !== 128) {
            throw new Error("unrecognized private key type");
          }
          for (var i = 0; i < exports.privateKeyDataSize; ++i) {
            key.data[i] = whole[i + 1];
          }
          return key;
        }
      };
      exports.stringToPrivateKey = stringToPrivateKey;
      var privateKeyToLegacyString = function(key) {
        if (key.type === KeyType.k1 && key.data.length === exports.privateKeyDataSize) {
          var whole_1 = [];
          whole_1.push(128);
          key.data.forEach(function(byte) {
            return whole_1.push(byte);
          });
          var digest = new Uint8Array(hash_js_1.sha256().update(hash_js_1.sha256().update(whole_1).digest()).digest());
          var result = new Uint8Array(exports.privateKeyDataSize + 5);
          for (var i = 0; i < whole_1.length; i++) {
            result[i] = whole_1[i];
          }
          for (var i = 0; i < 4; i++) {
            result[i + whole_1.length] = digest[i];
          }
          return exports.binaryToBase58(result);
        } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {
          throw new Error("Key format not supported in legacy conversion");
        } else {
          throw new Error("unrecognized public key format");
        }
      };
      exports.privateKeyToLegacyString = privateKeyToLegacyString;
      var privateKeyToString = function(key) {
        if (key.type === KeyType.r1) {
          return keyToString(key, "R1", "PVT_R1_");
        } else if (key.type === KeyType.k1) {
          return keyToString(key, "K1", "PVT_K1_");
        } else {
          throw new Error("unrecognized private key format");
        }
      };
      exports.privateKeyToString = privateKeyToString;
      var stringToSignature = function(s) {
        if (typeof s !== "string") {
          throw new Error("expected string containing signature");
        }
        if (s.substr(0, 7) === "SIG_K1_") {
          return stringToKey(s.substr(7), KeyType.k1, exports.signatureDataSize, "K1");
        } else if (s.substr(0, 7) === "SIG_R1_") {
          return stringToKey(s.substr(7), KeyType.r1, exports.signatureDataSize, "R1");
        } else if (s.substr(0, 7) === "SIG_WA_") {
          return stringToKey(s.substr(7), KeyType.wa, 0, "WA");
        } else {
          throw new Error("unrecognized signature format");
        }
      };
      exports.stringToSignature = stringToSignature;
      var signatureToString = function(signature) {
        if (signature.type === KeyType.k1) {
          return keyToString(signature, "K1", "SIG_K1_");
        } else if (signature.type === KeyType.r1) {
          return keyToString(signature, "R1", "SIG_R1_");
        } else if (signature.type === KeyType.wa) {
          return keyToString(signature, "WA", "SIG_WA_");
        } else {
          throw new Error("unrecognized signature format");
        }
      };
      exports.signatureToString = signatureToString;
    }
  });

  // node_modules/eosjs/dist/eosjs-serialize.js
  var require_eosjs_serialize2 = __commonJS({
    "node_modules/eosjs/dist/eosjs-serialize.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __read = exports && exports.__read || function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
        return to;
      };
      var __values = exports && exports.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.serializeQuery = exports.deserializeAnyArray = exports.serializeAnyArray = exports.deserializeAnyObject = exports.serializeAnyObject = exports.deserializeAnyvarShort = exports.deserializeAnyvar = exports.serializeAnyvar = exports.deserializeAction = exports.deserializeActionData = exports.serializeAction = exports.serializeActionData = exports.transactionHeader = exports.getTypesFromAbi = exports.getType = exports.createAbiTypes = exports.createInitialTypes = exports.hexToUint8Array = exports.arrayToHex = exports.symbolToString = exports.stringToSymbol = exports.blockTimestampToDate = exports.dateToBlockTimestamp = exports.timePointSecToDate = exports.dateToTimePointSec = exports.timePointToDate = exports.dateToTimePoint = exports.supportedAbiVersion = exports.SerialBuffer = exports.SerializerState = void 0;
      var numeric = require_eosjs_numeric2();
      var SerializerState = function() {
        function SerializerState2(options) {
          if (options === void 0) {
            options = {};
          }
          this.skippedBinaryExtension = false;
          this.options = options;
        }
        return SerializerState2;
      }();
      exports.SerializerState = SerializerState;
      var SerialBuffer = function() {
        function SerialBuffer2(_a) {
          var _b = _a === void 0 ? {} : _a, textEncoder = _b.textEncoder, textDecoder = _b.textDecoder, array = _b.array;
          this.readPos = 0;
          this.array = array || new Uint8Array(1024);
          this.length = array ? array.length : 0;
          this.textEncoder = textEncoder || new TextEncoder();
          this.textDecoder = textDecoder || new TextDecoder("utf-8", { fatal: true });
        }
        SerialBuffer2.prototype.reserve = function(size) {
          if (this.length + size <= this.array.length) {
            return;
          }
          var l = this.array.length;
          while (this.length + size > l) {
            l = Math.ceil(l * 1.5);
          }
          var newArray = new Uint8Array(l);
          newArray.set(this.array);
          this.array = newArray;
        };
        SerialBuffer2.prototype.haveReadData = function() {
          return this.readPos < this.length;
        };
        SerialBuffer2.prototype.restartRead = function() {
          this.readPos = 0;
        };
        SerialBuffer2.prototype.asUint8Array = function() {
          return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);
        };
        SerialBuffer2.prototype.pushArray = function(v) {
          this.reserve(v.length);
          this.array.set(v, this.length);
          this.length += v.length;
        };
        SerialBuffer2.prototype.push = function() {
          var v = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            v[_i] = arguments[_i];
          }
          this.pushArray(v);
        };
        SerialBuffer2.prototype.get = function() {
          if (this.readPos < this.length) {
            return this.array[this.readPos++];
          }
          throw new Error("Read past end of buffer");
        };
        SerialBuffer2.prototype.pushUint8ArrayChecked = function(v, len) {
          if (v.length !== len) {
            throw new Error("Binary data has incorrect size");
          }
          this.pushArray(v);
        };
        SerialBuffer2.prototype.getUint8Array = function(len) {
          if (this.readPos + len > this.length) {
            throw new Error("Read past end of buffer");
          }
          var result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);
          this.readPos += len;
          return result;
        };
        SerialBuffer2.prototype.skip = function(len) {
          if (this.readPos + len > this.length) {
            throw new Error("Read past end of buffer");
          }
          this.readPos += len;
        };
        SerialBuffer2.prototype.pushUint16 = function(v) {
          this.push(v >> 0 & 255, v >> 8 & 255);
        };
        SerialBuffer2.prototype.getUint16 = function() {
          var v = 0;
          v |= this.get() << 0;
          v |= this.get() << 8;
          return v;
        };
        SerialBuffer2.prototype.pushUint32 = function(v) {
          this.push(v >> 0 & 255, v >> 8 & 255, v >> 16 & 255, v >> 24 & 255);
        };
        SerialBuffer2.prototype.getUint32 = function() {
          var v = 0;
          v |= this.get() << 0;
          v |= this.get() << 8;
          v |= this.get() << 16;
          v |= this.get() << 24;
          return v >>> 0;
        };
        SerialBuffer2.prototype.pushNumberAsUint64 = function(v) {
          this.pushUint32(v >>> 0);
          this.pushUint32(Math.floor(v / 4294967296) >>> 0);
        };
        SerialBuffer2.prototype.getUint64AsNumber = function() {
          var low = this.getUint32();
          var high = this.getUint32();
          return (high >>> 0) * 4294967296 + (low >>> 0);
        };
        SerialBuffer2.prototype.pushVaruint32 = function(v) {
          while (true) {
            if (v >>> 7) {
              this.push(128 | v & 127);
              v = v >>> 7;
            } else {
              this.push(v);
              break;
            }
          }
        };
        SerialBuffer2.prototype.getVaruint32 = function() {
          var v = 0;
          var bit = 0;
          while (true) {
            var b = this.get();
            v |= (b & 127) << bit;
            bit += 7;
            if (!(b & 128)) {
              break;
            }
          }
          return v >>> 0;
        };
        SerialBuffer2.prototype.pushVarint32 = function(v) {
          this.pushVaruint32(v << 1 ^ v >> 31);
        };
        SerialBuffer2.prototype.getVarint32 = function() {
          var v = this.getVaruint32();
          if (v & 1) {
            return ~v >> 1 | 2147483648;
          } else {
            return v >>> 1;
          }
        };
        SerialBuffer2.prototype.pushFloat32 = function(v) {
          this.pushArray(new Uint8Array(new Float32Array([v]).buffer));
        };
        SerialBuffer2.prototype.getFloat32 = function() {
          return new Float32Array(this.getUint8Array(4).slice().buffer)[0];
        };
        SerialBuffer2.prototype.pushFloat64 = function(v) {
          this.pushArray(new Uint8Array(new Float64Array([v]).buffer));
        };
        SerialBuffer2.prototype.getFloat64 = function() {
          return new Float64Array(this.getUint8Array(8).slice().buffer)[0];
        };
        SerialBuffer2.prototype.pushName = function(s) {
          if (typeof s !== "string") {
            throw new Error("Expected string containing name");
          }
          var regex = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);
          if (!regex.test(s)) {
            throw new Error("Name should be less than 13 characters, or less than 14 if last character is between 1-5 or a-j, and only contain the following symbols .12345abcdefghijklmnopqrstuvwxyz");
          }
          var charToSymbol = function(c2) {
            if (c2 >= "a".charCodeAt(0) && c2 <= "z".charCodeAt(0)) {
              return c2 - "a".charCodeAt(0) + 6;
            }
            if (c2 >= "1".charCodeAt(0) && c2 <= "5".charCodeAt(0)) {
              return c2 - "1".charCodeAt(0) + 1;
            }
            return 0;
          };
          var a = new Uint8Array(8);
          var bit = 63;
          for (var i = 0; i < s.length; ++i) {
            var c = charToSymbol(s.charCodeAt(i));
            if (bit < 5) {
              c = c << 1;
            }
            for (var j = 4; j >= 0; --j) {
              if (bit >= 0) {
                a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;
                --bit;
              }
            }
          }
          this.pushArray(a);
        };
        SerialBuffer2.prototype.getName = function() {
          var a = this.getUint8Array(8);
          var result = "";
          for (var bit = 63; bit >= 0; ) {
            var c = 0;
            for (var i = 0; i < 5; ++i) {
              if (bit >= 0) {
                c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;
                --bit;
              }
            }
            if (c >= 6) {
              result += String.fromCharCode(c + "a".charCodeAt(0) - 6);
            } else if (c >= 1) {
              result += String.fromCharCode(c + "1".charCodeAt(0) - 1);
            } else {
              result += ".";
            }
          }
          while (result.endsWith(".")) {
            result = result.substr(0, result.length - 1);
          }
          return result;
        };
        SerialBuffer2.prototype.pushBytes = function(v) {
          this.pushVaruint32(v.length);
          this.pushArray(v);
        };
        SerialBuffer2.prototype.getBytes = function() {
          return this.getUint8Array(this.getVaruint32());
        };
        SerialBuffer2.prototype.pushString = function(v) {
          this.pushBytes(this.textEncoder.encode(v));
        };
        SerialBuffer2.prototype.getString = function() {
          return this.textDecoder.decode(this.getBytes());
        };
        SerialBuffer2.prototype.pushSymbolCode = function(name) {
          if (typeof name !== "string") {
            throw new Error("Expected string containing symbol_code");
          }
          var a = [];
          a.push.apply(a, __spreadArray([], __read(this.textEncoder.encode(name))));
          while (a.length < 8) {
            a.push(0);
          }
          this.pushArray(a.slice(0, 8));
        };
        SerialBuffer2.prototype.getSymbolCode = function() {
          var a = this.getUint8Array(8);
          var len;
          for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
              break;
            }
          }
          var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
          return name;
        };
        SerialBuffer2.prototype.pushSymbol = function(_a) {
          var name = _a.name, precision = _a.precision;
          if (!/^[A-Z]{1,7}$/.test(name)) {
            throw new Error("Expected symbol to be A-Z and between one and seven characters");
          }
          var a = [precision & 255];
          a.push.apply(a, __spreadArray([], __read(this.textEncoder.encode(name))));
          while (a.length < 8) {
            a.push(0);
          }
          this.pushArray(a.slice(0, 8));
        };
        SerialBuffer2.prototype.getSymbol = function() {
          var precision = this.get();
          var a = this.getUint8Array(7);
          var len;
          for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
              break;
            }
          }
          var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
          return { name, precision };
        };
        SerialBuffer2.prototype.pushAsset = function(s) {
          if (typeof s !== "string") {
            throw new Error("Expected string containing asset");
          }
          s = s.trim();
          var pos = 0;
          var amount = "";
          var precision = 0;
          if (s[pos] === "-") {
            amount += "-";
            ++pos;
          }
          var foundDigit = false;
          while (pos < s.length && s.charCodeAt(pos) >= "0".charCodeAt(0) && s.charCodeAt(pos) <= "9".charCodeAt(0)) {
            foundDigit = true;
            amount += s[pos];
            ++pos;
          }
          if (!foundDigit) {
            throw new Error("Asset must begin with a number");
          }
          if (s[pos] === ".") {
            ++pos;
            while (pos < s.length && s.charCodeAt(pos) >= "0".charCodeAt(0) && s.charCodeAt(pos) <= "9".charCodeAt(0)) {
              amount += s[pos];
              ++precision;
              ++pos;
            }
          }
          var name = s.substr(pos).trim();
          this.pushArray(numeric.signedDecimalToBinary(8, amount));
          this.pushSymbol({ name, precision });
        };
        SerialBuffer2.prototype.getAsset = function() {
          var amount = this.getUint8Array(8);
          var _a = this.getSymbol(), name = _a.name, precision = _a.precision;
          var s = numeric.signedBinaryToDecimal(amount, precision + 1);
          if (precision) {
            s = s.substr(0, s.length - precision) + "." + s.substr(s.length - precision);
          }
          return s + " " + name;
        };
        SerialBuffer2.prototype.pushPublicKey = function(s) {
          var key = numeric.stringToPublicKey(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getPublicKey = function() {
          var type = this.get();
          var data;
          if (type === numeric.KeyType.wa) {
            var begin = this.readPos;
            this.skip(34);
            this.skip(this.getVaruint32());
            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
          } else {
            data = this.getUint8Array(numeric.publicKeyDataSize);
          }
          return numeric.publicKeyToString({ type, data });
        };
        SerialBuffer2.prototype.pushPrivateKey = function(s) {
          var key = numeric.stringToPrivateKey(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getPrivateKey = function() {
          var type = this.get();
          var data = this.getUint8Array(numeric.privateKeyDataSize);
          return numeric.privateKeyToString({ type, data });
        };
        SerialBuffer2.prototype.pushSignature = function(s) {
          var key = numeric.stringToSignature(s);
          this.push(key.type);
          this.pushArray(key.data);
        };
        SerialBuffer2.prototype.getSignature = function() {
          var type = this.get();
          var data;
          if (type === numeric.KeyType.wa) {
            var begin = this.readPos;
            this.skip(65);
            this.skip(this.getVaruint32());
            this.skip(this.getVaruint32());
            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
          } else {
            data = this.getUint8Array(numeric.signatureDataSize);
          }
          return numeric.signatureToString({ type, data });
        };
        return SerialBuffer2;
      }();
      exports.SerialBuffer = SerialBuffer;
      var supportedAbiVersion = function(version2) {
        return version2.startsWith("eosio::abi/1.");
      };
      exports.supportedAbiVersion = supportedAbiVersion;
      var checkDateParse = function(date) {
        var result = Date.parse(date);
        if (Number.isNaN(result)) {
          throw new Error("Invalid time format");
        }
        return result;
      };
      var dateToTimePoint = function(date) {
        return Math.round(checkDateParse(date + "Z") * 1e3);
      };
      exports.dateToTimePoint = dateToTimePoint;
      var timePointToDate = function(us) {
        var s = new Date(us / 1e3).toISOString();
        return s.substr(0, s.length - 1);
      };
      exports.timePointToDate = timePointToDate;
      var dateToTimePointSec = function(date) {
        return Math.round(checkDateParse(date + "Z") / 1e3);
      };
      exports.dateToTimePointSec = dateToTimePointSec;
      var timePointSecToDate = function(sec) {
        var s = new Date(sec * 1e3).toISOString();
        return s.substr(0, s.length - 1);
      };
      exports.timePointSecToDate = timePointSecToDate;
      var dateToBlockTimestamp = function(date) {
        return Math.round((checkDateParse(date + "Z") - 9466848e5) / 500);
      };
      exports.dateToBlockTimestamp = dateToBlockTimestamp;
      var blockTimestampToDate = function(slot) {
        var s = new Date(slot * 500 + 9466848e5).toISOString();
        return s.substr(0, s.length - 1);
      };
      exports.blockTimestampToDate = blockTimestampToDate;
      var stringToSymbol = function(s) {
        if (typeof s !== "string") {
          throw new Error("Expected string containing symbol");
        }
        var m = s.match(/^([0-9]+),([A-Z]+)$/);
        if (!m) {
          throw new Error("Invalid symbol");
        }
        return { name: m[2], precision: +m[1] };
      };
      exports.stringToSymbol = stringToSymbol;
      var symbolToString = function(_a) {
        var name = _a.name, precision = _a.precision;
        return precision + "," + name;
      };
      exports.symbolToString = symbolToString;
      var arrayToHex = function(data) {
        var e_1, _a;
        var result = "";
        try {
          for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var x = data_1_1.value;
            result += ("00" + x.toString(16)).slice(-2);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (data_1_1 && !data_1_1.done && (_a = data_1.return))
              _a.call(data_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return result.toUpperCase();
      };
      exports.arrayToHex = arrayToHex;
      var hexToUint8Array = function(hex) {
        if (typeof hex !== "string") {
          throw new Error("Expected string containing hex digits");
        }
        if (hex.length % 2) {
          throw new Error("Odd number of hex digits");
        }
        var l = hex.length / 2;
        var result = new Uint8Array(l);
        for (var i = 0; i < l; ++i) {
          var x = parseInt(hex.substr(i * 2, 2), 16);
          if (Number.isNaN(x)) {
            throw new Error("Expected hex string");
          }
          result[i] = x;
        }
        return result;
      };
      exports.hexToUint8Array = hexToUint8Array;
      function serializeUnknown(buffer, data) {
        throw new Error("Don't know how to serialize " + this.name);
      }
      function deserializeUnknown(buffer) {
        throw new Error("Don't know how to deserialize " + this.name);
      }
      function serializeStruct(buffer, data, state, allowExtensions) {
        var e_2, _a;
        if (state === void 0) {
          state = new SerializerState();
        }
        if (allowExtensions === void 0) {
          allowExtensions = true;
        }
        if (typeof data !== "object") {
          throw new Error("expected object containing data: " + JSON.stringify(data));
        }
        if (this.base) {
          this.base.serialize(buffer, data, state, allowExtensions);
        }
        try {
          for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
            var field = _c.value;
            if (field.name in data) {
              if (state.skippedBinaryExtension) {
                throw new Error("unexpected " + this.name + "." + field.name);
              }
              field.type.serialize(buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);
            } else {
              if (allowExtensions && field.type.extensionOf) {
                state.skippedBinaryExtension = true;
              } else {
                throw new Error("missing " + this.name + "." + field.name + " (type=" + field.type.name + ")");
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      function deserializeStruct(buffer, state, allowExtensions) {
        var e_3, _a;
        if (state === void 0) {
          state = new SerializerState();
        }
        if (allowExtensions === void 0) {
          allowExtensions = true;
        }
        var result;
        if (this.base) {
          result = this.base.deserialize(buffer, state, allowExtensions);
        } else {
          result = {};
        }
        try {
          for (var _b = __values(this.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
            var field = _c.value;
            if (allowExtensions && field.type.extensionOf && !buffer.haveReadData()) {
              state.skippedBinaryExtension = true;
            } else {
              result[field.name] = field.type.deserialize(buffer, state, allowExtensions);
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        return result;
      }
      function serializeVariant(buffer, data, state, allowExtensions) {
        if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== "string") {
          throw new Error('expected variant: ["type", value]');
        }
        var i = this.fields.findIndex(function(field) {
          return field.name === data[0];
        });
        if (i < 0) {
          throw new Error('type "' + data[0] + '" is not valid for variant');
        }
        buffer.pushVaruint32(i);
        this.fields[i].type.serialize(buffer, data[1], state, allowExtensions);
      }
      function deserializeVariant(buffer, state, allowExtensions) {
        var i = buffer.getVaruint32();
        if (i >= this.fields.length) {
          throw new Error("type index " + i + " is not valid for variant");
        }
        var field = this.fields[i];
        return [field.name, field.type.deserialize(buffer, state, allowExtensions)];
      }
      function serializeArray(buffer, data, state, allowExtensions) {
        var e_4, _a;
        buffer.pushVaruint32(data.length);
        try {
          for (var data_2 = __values(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {
            var item = data_2_1.value;
            this.arrayOf.serialize(buffer, item, state, false);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (data_2_1 && !data_2_1.done && (_a = data_2.return))
              _a.call(data_2);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
      }
      function deserializeArray(buffer, state, allowExtensions) {
        var len = buffer.getVaruint32();
        var result = [];
        for (var i = 0; i < len; ++i) {
          result.push(this.arrayOf.deserialize(buffer, state, false));
        }
        return result;
      }
      function serializeOptional(buffer, data, state, allowExtensions) {
        if (data === null || data === void 0) {
          buffer.push(0);
        } else {
          buffer.push(1);
          this.optionalOf.serialize(buffer, data, state, allowExtensions);
        }
      }
      function deserializeOptional(buffer, state, allowExtensions) {
        if (buffer.get()) {
          return this.optionalOf.deserialize(buffer, state, allowExtensions);
        } else {
          return null;
        }
      }
      function serializeExtension(buffer, data, state, allowExtensions) {
        this.extensionOf.serialize(buffer, data, state, allowExtensions);
      }
      function deserializeExtension(buffer, state, allowExtensions) {
        return this.extensionOf.deserialize(buffer, state, allowExtensions);
      }
      function serializeObject(buffer, data, state, allowExtensions) {
        var e_5, _a;
        var entries = Object.entries(data);
        buffer.pushVaruint32(entries.length);
        try {
          for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
            var _b = __read(entries_1_1.value, 2), key = _b[0], value = _b[1];
            var keyType = this.fields[0].type;
            var dataType = this.fields[1].type;
            keyType.serialize(buffer, key, state, allowExtensions);
            dataType.serialize(buffer, value, state, allowExtensions);
          }
        } catch (e_5_1) {
          e_5 = { error: e_5_1 };
        } finally {
          try {
            if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return))
              _a.call(entries_1);
          } finally {
            if (e_5)
              throw e_5.error;
          }
        }
      }
      function deserializeObject(buffer, state, allowExtensions) {
        var len = buffer.getVaruint32();
        var result = {};
        for (var i = 0; i < len; ++i) {
          var keyType = this.fields[0].type;
          var dataType = this.fields[1].type;
          var key = keyType.deserialize(buffer, state, allowExtensions);
          result[key] = dataType.deserialize(buffer, state, allowExtensions);
        }
        return result;
      }
      var createType = function(attrs) {
        return __assign({ name: "<missing name>", aliasOfName: "", arrayOf: null, optionalOf: null, extensionOf: null, baseName: "", base: null, fields: [], serialize: serializeUnknown, deserialize: deserializeUnknown }, attrs);
      };
      var checkRange = function(orig, converted) {
        if (Number.isNaN(+orig) || Number.isNaN(+converted) || typeof orig !== "number" && typeof orig !== "string") {
          throw new Error("Expected number");
        }
        if (+orig !== +converted) {
          throw new Error("Number is out of range");
        }
        return +orig;
      };
      var createInitialTypes = function() {
        var result = new Map(Object.entries({
          bool: createType({
            name: "bool",
            serialize: function(buffer, data) {
              if (!(typeof data === "boolean" || typeof data === "number" && (data === 1 || data === 0))) {
                throw new Error("Expected boolean or number equal to 1 or 0");
              }
              buffer.push(data ? 1 : 0);
            },
            deserialize: function(buffer) {
              return !!buffer.get();
            }
          }),
          uint8: createType({
            name: "uint8",
            serialize: function(buffer, data) {
              buffer.push(checkRange(data, data & 255));
            },
            deserialize: function(buffer) {
              return buffer.get();
            }
          }),
          int8: createType({
            name: "int8",
            serialize: function(buffer, data) {
              buffer.push(checkRange(data, data << 24 >> 24));
            },
            deserialize: function(buffer) {
              return buffer.get() << 24 >> 24;
            }
          }),
          uint16: createType({
            name: "uint16",
            serialize: function(buffer, data) {
              buffer.pushUint16(checkRange(data, data & 65535));
            },
            deserialize: function(buffer) {
              return buffer.getUint16();
            }
          }),
          int16: createType({
            name: "int16",
            serialize: function(buffer, data) {
              buffer.pushUint16(checkRange(data, data << 16 >> 16));
            },
            deserialize: function(buffer) {
              return buffer.getUint16() << 16 >> 16;
            }
          }),
          uint32: createType({
            name: "uint32",
            serialize: function(buffer, data) {
              buffer.pushUint32(checkRange(data, data >>> 0));
            },
            deserialize: function(buffer) {
              return buffer.getUint32();
            }
          }),
          uint64: createType({
            name: "uint64",
            serialize: function(buffer, data) {
              buffer.pushArray(numeric.decimalToBinary(8, "" + data));
            },
            deserialize: function(buffer) {
              return numeric.binaryToDecimal(buffer.getUint8Array(8));
            }
          }),
          int64: createType({
            name: "int64",
            serialize: function(buffer, data) {
              buffer.pushArray(numeric.signedDecimalToBinary(8, "" + data));
            },
            deserialize: function(buffer) {
              return numeric.signedBinaryToDecimal(buffer.getUint8Array(8));
            }
          }),
          int32: createType({
            name: "int32",
            serialize: function(buffer, data) {
              buffer.pushUint32(checkRange(data, data | 0));
            },
            deserialize: function(buffer) {
              return buffer.getUint32() | 0;
            }
          }),
          varuint32: createType({
            name: "varuint32",
            serialize: function(buffer, data) {
              buffer.pushVaruint32(checkRange(data, data >>> 0));
            },
            deserialize: function(buffer) {
              return buffer.getVaruint32();
            }
          }),
          varint32: createType({
            name: "varint32",
            serialize: function(buffer, data) {
              buffer.pushVarint32(checkRange(data, data | 0));
            },
            deserialize: function(buffer) {
              return buffer.getVarint32();
            }
          }),
          uint128: createType({
            name: "uint128",
            serialize: function(buffer, data) {
              buffer.pushArray(numeric.decimalToBinary(16, "" + data));
            },
            deserialize: function(buffer) {
              return numeric.binaryToDecimal(buffer.getUint8Array(16));
            }
          }),
          int128: createType({
            name: "int128",
            serialize: function(buffer, data) {
              buffer.pushArray(numeric.signedDecimalToBinary(16, "" + data));
            },
            deserialize: function(buffer) {
              return numeric.signedBinaryToDecimal(buffer.getUint8Array(16));
            }
          }),
          float32: createType({
            name: "float32",
            serialize: function(buffer, data) {
              buffer.pushFloat32(data);
            },
            deserialize: function(buffer) {
              return buffer.getFloat32();
            }
          }),
          float64: createType({
            name: "float64",
            serialize: function(buffer, data) {
              buffer.pushFloat64(data);
            },
            deserialize: function(buffer) {
              return buffer.getFloat64();
            }
          }),
          float128: createType({
            name: "float128",
            serialize: function(buffer, data) {
              buffer.pushUint8ArrayChecked(exports.hexToUint8Array(data), 16);
            },
            deserialize: function(buffer) {
              return exports.arrayToHex(buffer.getUint8Array(16));
            }
          }),
          bytes: createType({
            name: "bytes",
            serialize: function(buffer, data) {
              if (data instanceof Uint8Array || Array.isArray(data)) {
                buffer.pushBytes(data);
              } else {
                buffer.pushBytes(exports.hexToUint8Array(data));
              }
            },
            deserialize: function(buffer, state) {
              if (state && state.options.bytesAsUint8Array) {
                return buffer.getBytes();
              } else {
                return exports.arrayToHex(buffer.getBytes());
              }
            }
          }),
          string: createType({
            name: "string",
            serialize: function(buffer, data) {
              buffer.pushString(data);
            },
            deserialize: function(buffer) {
              return buffer.getString();
            }
          }),
          name: createType({
            name: "name",
            serialize: function(buffer, data) {
              buffer.pushName(data);
            },
            deserialize: function(buffer) {
              return buffer.getName();
            }
          }),
          time_point: createType({
            name: "time_point",
            serialize: function(buffer, data) {
              buffer.pushNumberAsUint64(exports.dateToTimePoint(data));
            },
            deserialize: function(buffer) {
              return exports.timePointToDate(buffer.getUint64AsNumber());
            }
          }),
          time_point_sec: createType({
            name: "time_point_sec",
            serialize: function(buffer, data) {
              buffer.pushUint32(exports.dateToTimePointSec(data));
            },
            deserialize: function(buffer) {
              return exports.timePointSecToDate(buffer.getUint32());
            }
          }),
          block_timestamp_type: createType({
            name: "block_timestamp_type",
            serialize: function(buffer, data) {
              buffer.pushUint32(exports.dateToBlockTimestamp(data));
            },
            deserialize: function(buffer) {
              return exports.blockTimestampToDate(buffer.getUint32());
            }
          }),
          symbol_code: createType({
            name: "symbol_code",
            serialize: function(buffer, data) {
              buffer.pushSymbolCode(data);
            },
            deserialize: function(buffer) {
              return buffer.getSymbolCode();
            }
          }),
          symbol: createType({
            name: "symbol",
            serialize: function(buffer, data) {
              buffer.pushSymbol(exports.stringToSymbol(data));
            },
            deserialize: function(buffer) {
              return exports.symbolToString(buffer.getSymbol());
            }
          }),
          asset: createType({
            name: "asset",
            serialize: function(buffer, data) {
              buffer.pushAsset(data);
            },
            deserialize: function(buffer) {
              return buffer.getAsset();
            }
          }),
          checksum160: createType({
            name: "checksum160",
            serialize: function(buffer, data) {
              buffer.pushUint8ArrayChecked(exports.hexToUint8Array(data), 20);
            },
            deserialize: function(buffer) {
              return exports.arrayToHex(buffer.getUint8Array(20));
            }
          }),
          checksum256: createType({
            name: "checksum256",
            serialize: function(buffer, data) {
              buffer.pushUint8ArrayChecked(exports.hexToUint8Array(data), 32);
            },
            deserialize: function(buffer) {
              return exports.arrayToHex(buffer.getUint8Array(32));
            }
          }),
          checksum512: createType({
            name: "checksum512",
            serialize: function(buffer, data) {
              buffer.pushUint8ArrayChecked(exports.hexToUint8Array(data), 64);
            },
            deserialize: function(buffer) {
              return exports.arrayToHex(buffer.getUint8Array(64));
            }
          }),
          public_key: createType({
            name: "public_key",
            serialize: function(buffer, data) {
              buffer.pushPublicKey(data);
            },
            deserialize: function(buffer) {
              return buffer.getPublicKey();
            }
          }),
          private_key: createType({
            name: "private_key",
            serialize: function(buffer, data) {
              buffer.pushPrivateKey(data);
            },
            deserialize: function(buffer) {
              return buffer.getPrivateKey();
            }
          }),
          signature: createType({
            name: "signature",
            serialize: function(buffer, data) {
              buffer.pushSignature(data);
            },
            deserialize: function(buffer) {
              return buffer.getSignature();
            }
          })
        }));
        result.set("extended_asset", createType({
          name: "extended_asset",
          baseName: "",
          fields: [
            { name: "quantity", typeName: "asset", type: result.get("asset") },
            { name: "contract", typeName: "name", type: result.get("name") }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        return result;
      };
      exports.createInitialTypes = createInitialTypes;
      var createAbiTypes = function() {
        var initialTypes = exports.createInitialTypes();
        initialTypes.set("extensions_entry", createType({
          name: "extensions_entry",
          baseName: "",
          fields: [
            { name: "tag", typeName: "uint16", type: null },
            { name: "value", typeName: "bytes", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("type_def", createType({
          name: "type_def",
          baseName: "",
          fields: [
            { name: "new_type_name", typeName: "string", type: null },
            { name: "type", typeName: "string", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("field_def", createType({
          name: "field_def",
          baseName: "",
          fields: [
            { name: "name", typeName: "string", type: null },
            { name: "type", typeName: "string", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("struct_def", createType({
          name: "struct_def",
          baseName: "",
          fields: [
            { name: "name", typeName: "string", type: null },
            { name: "base", typeName: "string", type: null },
            { name: "fields", typeName: "field_def[]", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("action_def", createType({
          name: "action_def",
          baseName: "",
          fields: [
            { name: "name", typeName: "name", type: null },
            { name: "type", typeName: "string", type: null },
            { name: "ricardian_contract", typeName: "string", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("table_def", createType({
          name: "table_def",
          baseName: "",
          fields: [
            { name: "name", typeName: "name", type: null },
            { name: "index_type", typeName: "string", type: null },
            { name: "key_names", typeName: "string[]", type: null },
            { name: "key_types", typeName: "string[]", type: null },
            { name: "type", typeName: "string", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("clause_pair", createType({
          name: "clause_pair",
          baseName: "",
          fields: [
            { name: "id", typeName: "string", type: null },
            { name: "body", typeName: "string", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("error_message", createType({
          name: "error_message",
          baseName: "",
          fields: [
            { name: "error_code", typeName: "uint64", type: null },
            { name: "error_msg", typeName: "string", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("variant_def", createType({
          name: "variant_def",
          baseName: "",
          fields: [
            { name: "name", typeName: "string", type: null },
            { name: "types", typeName: "string[]", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("action_result", createType({
          name: "action_result",
          baseName: "",
          fields: [
            { name: "name", typeName: "name", type: null },
            { name: "result_type", typeName: "string", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("primary_key_index_def", createType({
          name: "primary_key_index_def",
          baseName: "",
          fields: [
            { name: "name", typeName: "name", type: null },
            { name: "type", typeName: "string", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("secondary_index_def", createType({
          name: "secondary_index_def",
          baseName: "",
          fields: [
            { name: "type", typeName: "string", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("secondary_indices", createType({
          name: "secondary_indices",
          baseName: "",
          fields: [
            { name: "name", typeName: "name", type: null },
            { name: "secondary_index_def", typeName: "secondary_index_def", type: null }
          ],
          serialize: serializeObject,
          deserialize: deserializeObject
        }));
        initialTypes.set("kv_table_entry_def", createType({
          name: "kv_table_entry_def",
          baseName: "",
          fields: [
            { name: "type", typeName: "string", type: null },
            { name: "primary_index", typeName: "primary_key_index_def", type: null },
            { name: "secondary_indices", typeName: "secondary_indices", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        initialTypes.set("kv_table", createType({
          name: "kv_table",
          baseName: "",
          fields: [
            { name: "name", typeName: "name", type: null },
            { name: "kv_table_entry_def", typeName: "kv_table_entry_def", type: null }
          ],
          serialize: serializeObject,
          deserialize: deserializeObject
        }));
        initialTypes.set("abi_def", createType({
          name: "abi_def",
          baseName: "",
          fields: [
            { name: "version", typeName: "string", type: null },
            { name: "types", typeName: "type_def[]", type: null },
            { name: "structs", typeName: "struct_def[]", type: null },
            { name: "actions", typeName: "action_def[]", type: null },
            { name: "tables", typeName: "table_def[]", type: null },
            { name: "ricardian_clauses", typeName: "clause_pair[]", type: null },
            { name: "error_messages", typeName: "error_message[]", type: null },
            { name: "abi_extensions", typeName: "extensions_entry[]", type: null },
            { name: "variants", typeName: "variant_def[]$", type: null },
            { name: "action_results", typeName: "action_result[]$", type: null },
            { name: "kv_tables", typeName: "kv_table$", type: null }
          ],
          serialize: serializeStruct,
          deserialize: deserializeStruct
        }));
        return initialTypes;
      };
      exports.createAbiTypes = createAbiTypes;
      var getType = function(types, name) {
        var type = types.get(name);
        if (type && type.aliasOfName) {
          return exports.getType(types, type.aliasOfName);
        }
        if (type) {
          return type;
        }
        if (name.endsWith("[]")) {
          return createType({
            name,
            arrayOf: exports.getType(types, name.substr(0, name.length - 2)),
            serialize: serializeArray,
            deserialize: deserializeArray
          });
        }
        if (name.endsWith("?")) {
          return createType({
            name,
            optionalOf: exports.getType(types, name.substr(0, name.length - 1)),
            serialize: serializeOptional,
            deserialize: deserializeOptional
          });
        }
        if (name.endsWith("$")) {
          return createType({
            name,
            extensionOf: exports.getType(types, name.substr(0, name.length - 1)),
            serialize: serializeExtension,
            deserialize: deserializeExtension
          });
        }
        throw new Error("Unknown type: " + name);
      };
      exports.getType = getType;
      var getTypesFromAbi = function(initialTypes, abi) {
        var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;
        var types = new Map(initialTypes);
        if (abi && abi.types) {
          try {
            for (var _f = __values(abi.types), _g = _f.next(); !_g.done; _g = _f.next()) {
              var _h = _g.value, new_type_name = _h.new_type_name, type = _h.type;
              types.set(new_type_name, createType({ name: new_type_name, aliasOfName: type }));
            }
          } catch (e_6_1) {
            e_6 = { error: e_6_1 };
          } finally {
            try {
              if (_g && !_g.done && (_a = _f.return))
                _a.call(_f);
            } finally {
              if (e_6)
                throw e_6.error;
            }
          }
        }
        if (abi && abi.structs) {
          try {
            for (var _j = __values(abi.structs), _k = _j.next(); !_k.done; _k = _j.next()) {
              var _l = _k.value, name_1 = _l.name, base = _l.base, fields = _l.fields;
              types.set(name_1, createType({
                name: name_1,
                baseName: base,
                fields: fields.map(function(_a2) {
                  var n = _a2.name, type2 = _a2.type;
                  return { name: n, typeName: type2, type: null };
                }),
                serialize: serializeStruct,
                deserialize: deserializeStruct
              }));
            }
          } catch (e_7_1) {
            e_7 = { error: e_7_1 };
          } finally {
            try {
              if (_k && !_k.done && (_b = _j.return))
                _b.call(_j);
            } finally {
              if (e_7)
                throw e_7.error;
            }
          }
        }
        if (abi && abi.variants) {
          try {
            for (var _m = __values(abi.variants), _o = _m.next(); !_o.done; _o = _m.next()) {
              var _p = _o.value, name_2 = _p.name, t = _p.types;
              types.set(name_2, createType({
                name: name_2,
                fields: t.map(function(s) {
                  return { name: s, typeName: s, type: null };
                }),
                serialize: serializeVariant,
                deserialize: deserializeVariant
              }));
            }
          } catch (e_8_1) {
            e_8 = { error: e_8_1 };
          } finally {
            try {
              if (_o && !_o.done && (_c = _m.return))
                _c.call(_m);
            } finally {
              if (e_8)
                throw e_8.error;
            }
          }
        }
        try {
          for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
            var _q = __read(types_1_1.value, 2), name_3 = _q[0], type = _q[1];
            if (type.baseName) {
              type.base = exports.getType(types, type.baseName);
            }
            try {
              for (var _r = (e_10 = void 0, __values(type.fields)), _s = _r.next(); !_s.done; _s = _r.next()) {
                var field = _s.value;
                field.type = exports.getType(types, field.typeName);
              }
            } catch (e_10_1) {
              e_10 = { error: e_10_1 };
            } finally {
              try {
                if (_s && !_s.done && (_e = _r.return))
                  _e.call(_r);
              } finally {
                if (e_10)
                  throw e_10.error;
              }
            }
          }
        } catch (e_9_1) {
          e_9 = { error: e_9_1 };
        } finally {
          try {
            if (types_1_1 && !types_1_1.done && (_d = types_1.return))
              _d.call(types_1);
          } finally {
            if (e_9)
              throw e_9.error;
          }
        }
        return types;
      };
      exports.getTypesFromAbi = getTypesFromAbi;
      var reverseHex = function(h) {
        return h.substr(6, 2) + h.substr(4, 2) + h.substr(2, 2) + h.substr(0, 2);
      };
      var transactionHeader = function(refBlock, expireSeconds) {
        var timestamp = refBlock.header ? refBlock.header.timestamp : refBlock.timestamp;
        var prefix = parseInt(reverseHex(refBlock.id.substr(16, 8)), 16);
        return {
          expiration: exports.timePointSecToDate(exports.dateToTimePointSec(timestamp) + expireSeconds),
          ref_block_num: refBlock.block_num & 65535,
          ref_block_prefix: prefix
        };
      };
      exports.transactionHeader = transactionHeader;
      var serializeActionData = function(contract, account, name, data, textEncoder, textDecoder) {
        var action = contract.actions.get(name);
        if (!action) {
          throw new Error("Unknown action " + name + " in contract " + account);
        }
        var buffer = new SerialBuffer({ textEncoder, textDecoder });
        action.serialize(buffer, data);
        return exports.arrayToHex(buffer.asUint8Array());
      };
      exports.serializeActionData = serializeActionData;
      var serializeAction = function(contract, account, name, authorization, data, textEncoder, textDecoder) {
        return {
          account,
          name,
          authorization,
          data: exports.serializeActionData(contract, account, name, data, textEncoder, textDecoder)
        };
      };
      exports.serializeAction = serializeAction;
      var deserializeActionData = function(contract, account, name, data, textEncoder, textDecoder) {
        var action = contract.actions.get(name);
        if (typeof data === "string") {
          data = exports.hexToUint8Array(data);
        }
        if (!action) {
          throw new Error("Unknown action " + name + " in contract " + account);
        }
        var buffer = new SerialBuffer({ textDecoder, textEncoder });
        buffer.pushArray(data);
        return action.deserialize(buffer);
      };
      exports.deserializeActionData = deserializeActionData;
      var deserializeAction = function(contract, account, name, authorization, data, textEncoder, textDecoder) {
        return {
          account,
          name,
          authorization,
          data: exports.deserializeActionData(contract, account, name, data, textEncoder, textDecoder)
        };
      };
      exports.deserializeAction = deserializeAction;
      var serializeAnyvar = function(buffer, anyvar) {
        var _a, _b, _c, _d, _e, _f, _g;
        var def;
        var value;
        if (anyvar === null) {
          _a = __read([anyvarDefs.null_t, anyvar], 2), def = _a[0], value = _a[1];
        } else if (typeof anyvar === "string") {
          _b = __read([anyvarDefs.string, anyvar], 2), def = _b[0], value = _b[1];
        } else if (typeof anyvar === "number") {
          _c = __read([anyvarDefs.int32, anyvar], 2), def = _c[0], value = _c[1];
        } else if (anyvar instanceof Uint8Array) {
          _d = __read([anyvarDefs.bytes, anyvar], 2), def = _d[0], value = _d[1];
        } else if (Array.isArray(anyvar)) {
          _e = __read([anyvarDefs.any_array, anyvar], 2), def = _e[0], value = _e[1];
        } else if (Object.keys(anyvar).length === 2 && anyvar.hasOwnProperty("type") && anyvar.hasOwnProperty("value")) {
          _f = __read([anyvarDefs[anyvar.type], anyvar.value], 2), def = _f[0], value = _f[1];
        } else {
          _g = __read([anyvarDefs.any_object, anyvar], 2), def = _g[0], value = _g[1];
        }
        buffer.pushVaruint32(def.index);
        def.type.serialize(buffer, value);
      };
      exports.serializeAnyvar = serializeAnyvar;
      var deserializeAnyvar = function(buffer, state) {
        var defIndex = buffer.getVaruint32();
        if (defIndex >= anyvarDefsByIndex.length) {
          throw new Error("Tried to deserialize unknown anyvar type");
        }
        var def = anyvarDefsByIndex[defIndex];
        var value = def.type.deserialize(buffer, state);
        if (state && state.options.useShortForm || def.useShortForm) {
          return value;
        } else {
          return { type: def.type.name, value };
        }
      };
      exports.deserializeAnyvar = deserializeAnyvar;
      var deserializeAnyvarShort = function(buffer) {
        return exports.deserializeAnyvar(buffer, new SerializerState({ useShortForm: true }));
      };
      exports.deserializeAnyvarShort = deserializeAnyvarShort;
      var serializeAnyObject = function(buffer, obj) {
        var e_11, _a;
        var entries = Object.entries(obj);
        buffer.pushVaruint32(entries.length);
        try {
          for (var entries_2 = __values(entries), entries_2_1 = entries_2.next(); !entries_2_1.done; entries_2_1 = entries_2.next()) {
            var _b = __read(entries_2_1.value, 2), key = _b[0], value = _b[1];
            buffer.pushString(key);
            exports.serializeAnyvar(buffer, value);
          }
        } catch (e_11_1) {
          e_11 = { error: e_11_1 };
        } finally {
          try {
            if (entries_2_1 && !entries_2_1.done && (_a = entries_2.return))
              _a.call(entries_2);
          } finally {
            if (e_11)
              throw e_11.error;
          }
        }
      };
      exports.serializeAnyObject = serializeAnyObject;
      var deserializeAnyObject = function(buffer, state) {
        var len = buffer.getVaruint32();
        var result = {};
        for (var i = 0; i < len; ++i) {
          var key = buffer.getString();
          if (key in result) {
            var j = 1;
            while (key + "_" + j in result) {
              ++j;
            }
            key = key + "_" + j;
          }
          result[key] = exports.deserializeAnyvar(buffer, state);
        }
        return result;
      };
      exports.deserializeAnyObject = deserializeAnyObject;
      var serializeAnyArray = function(buffer, arr) {
        var e_12, _a;
        buffer.pushVaruint32(arr.length);
        try {
          for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var x = arr_1_1.value;
            exports.serializeAnyvar(buffer, x);
          }
        } catch (e_12_1) {
          e_12 = { error: e_12_1 };
        } finally {
          try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return))
              _a.call(arr_1);
          } finally {
            if (e_12)
              throw e_12.error;
          }
        }
      };
      exports.serializeAnyArray = serializeAnyArray;
      var deserializeAnyArray = function(buffer, state) {
        var len = buffer.getVaruint32();
        var result = [];
        for (var i = 0; i < len; ++i) {
          result.push(exports.deserializeAnyvar(buffer, state));
        }
        return result;
      };
      exports.deserializeAnyArray = deserializeAnyArray;
      var addAdditionalTypes = function() {
        var initialTypes = exports.createInitialTypes();
        initialTypes.set("null_t", createType({
          name: "null_t",
          serialize: function(buffer, anyvar) {
          },
          deserialize: function(buffer, state) {
          }
        }));
        initialTypes.set("any_object", createType({
          name: "any_object",
          serialize: exports.serializeAnyObject,
          deserialize: exports.deserializeAnyObject
        }));
        initialTypes.set("any_array", createType({
          name: "any_array",
          serialize: exports.serializeAnyArray,
          deserialize: exports.deserializeAnyArray
        }));
        return initialTypes;
      };
      var additionalTypes = addAdditionalTypes();
      var anyvarDefs = {
        null_t: { index: 0, useShortForm: true, type: additionalTypes.get("null_t") },
        int64: { index: 1, useShortForm: false, type: additionalTypes.get("int64") },
        uint64: { index: 2, useShortForm: false, type: additionalTypes.get("uint64") },
        int32: { index: 3, useShortForm: true, type: additionalTypes.get("int32") },
        uint32: { index: 4, useShortForm: false, type: additionalTypes.get("uint32") },
        int16: { index: 5, useShortForm: false, type: additionalTypes.get("int16") },
        uint16: { index: 6, useShortForm: false, type: additionalTypes.get("uint16") },
        int8: { index: 7, useShortForm: false, type: additionalTypes.get("int8") },
        uint8: { index: 8, useShortForm: false, type: additionalTypes.get("uint8") },
        time_point: { index: 9, useShortForm: false, type: additionalTypes.get("time_point") },
        checksum256: { index: 10, useShortForm: false, type: additionalTypes.get("checksum256") },
        float64: { index: 11, useShortForm: false, type: additionalTypes.get("float64") },
        string: { index: 12, useShortForm: true, type: additionalTypes.get("string") },
        any_object: { index: 13, useShortForm: true, type: additionalTypes.get("any_object") },
        any_array: { index: 14, useShortForm: true, type: additionalTypes.get("any_array") },
        bytes: { index: 15, useShortForm: false, type: additionalTypes.get("bytes") },
        symbol: { index: 16, useShortForm: false, type: additionalTypes.get("symbol") },
        symbol_code: { index: 17, useShortForm: false, type: additionalTypes.get("symbol_code") },
        asset: { index: 18, useShortForm: false, type: additionalTypes.get("asset") }
      };
      var anyvarDefsByIndex = [
        anyvarDefs.null_t,
        anyvarDefs.int64,
        anyvarDefs.uint64,
        anyvarDefs.int32,
        anyvarDefs.uint32,
        anyvarDefs.int16,
        anyvarDefs.uint16,
        anyvarDefs.int8,
        anyvarDefs.uint8,
        anyvarDefs.time_point,
        anyvarDefs.checksum256,
        anyvarDefs.float64,
        anyvarDefs.string,
        anyvarDefs.any_object,
        anyvarDefs.any_array,
        anyvarDefs.bytes,
        anyvarDefs.symbol,
        anyvarDefs.symbol_code,
        anyvarDefs.asset
      ];
      var serializeQuery = function(buffer, query) {
        var _a, _b, _c, e_13, _d;
        var method;
        var arg;
        var filter;
        if (typeof query === "string") {
          method = query;
        } else if (Array.isArray(query) && query.length === 2) {
          _a = __read(query, 2), method = _a[0], filter = _a[1];
        } else if (Array.isArray(query) && query.length === 3) {
          _b = __read(query, 3), method = _b[0], arg = _b[1], filter = _b[2];
        } else {
          _c = __read([query.method, query.arg, query.filter], 3), method = _c[0], arg = _c[1], filter = _c[2];
        }
        buffer.pushString(method);
        if (arg === void 0) {
          buffer.push(0);
        } else {
          buffer.push(1);
          exports.serializeAnyvar(buffer, arg);
        }
        if (filter === void 0) {
          buffer.push(0);
        } else {
          buffer.pushVaruint32(filter.length);
          try {
            for (var filter_1 = __values(filter), filter_1_1 = filter_1.next(); !filter_1_1.done; filter_1_1 = filter_1.next()) {
              var q = filter_1_1.value;
              exports.serializeQuery(buffer, q);
            }
          } catch (e_13_1) {
            e_13 = { error: e_13_1 };
          } finally {
            try {
              if (filter_1_1 && !filter_1_1.done && (_d = filter_1.return))
                _d.call(filter_1);
            } finally {
              if (e_13)
                throw e_13.error;
            }
          }
        }
      };
      exports.serializeQuery = serializeQuery;
    }
  });

  // node_modules/eosjs/src/transaction.abi.json
  var require_transaction_abi2 = __commonJS({
    "node_modules/eosjs/src/transaction.abi.json"(exports, module) {
      module.exports = {
        version: "eosio::abi/1.0",
        types: [
          {
            new_type_name: "account_name",
            type: "name"
          },
          {
            new_type_name: "action_name",
            type: "name"
          },
          {
            new_type_name: "permission_name",
            type: "name"
          }
        ],
        structs: [
          {
            name: "permission_level",
            base: "",
            fields: [
              {
                name: "actor",
                type: "account_name"
              },
              {
                name: "permission",
                type: "permission_name"
              }
            ]
          },
          {
            name: "action",
            base: "",
            fields: [
              {
                name: "account",
                type: "account_name"
              },
              {
                name: "name",
                type: "action_name"
              },
              {
                name: "authorization",
                type: "permission_level[]"
              },
              {
                name: "data",
                type: "bytes"
              }
            ]
          },
          {
            name: "extension",
            base: "",
            fields: [
              {
                name: "type",
                type: "uint16"
              },
              {
                name: "data",
                type: "bytes"
              }
            ]
          },
          {
            name: "transaction_header",
            base: "",
            fields: [
              {
                name: "expiration",
                type: "time_point_sec"
              },
              {
                name: "ref_block_num",
                type: "uint16"
              },
              {
                name: "ref_block_prefix",
                type: "uint32"
              },
              {
                name: "max_net_usage_words",
                type: "varuint32"
              },
              {
                name: "max_cpu_usage_ms",
                type: "uint8"
              },
              {
                name: "delay_sec",
                type: "varuint32"
              }
            ]
          },
          {
            name: "transaction",
            base: "transaction_header",
            fields: [
              {
                name: "context_free_actions",
                type: "action[]"
              },
              {
                name: "actions",
                type: "action[]"
              },
              {
                name: "transaction_extensions",
                type: "extension[]"
              }
            ]
          }
        ]
      };
    }
  });

  // node_modules/eosjs/dist/eosjs-api.js
  var require_eosjs_api2 = __commonJS({
    "node_modules/eosjs/dist/eosjs-api.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f2, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f2 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __read = exports && exports.__read || function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
        return to;
      };
      var __values = exports && exports.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ActionBuilder = exports.TransactionBuilder = exports.Api = void 0;
      var pako_1 = require_pako();
      var ser = require_eosjs_serialize2();
      var transactionAbi = require_transaction_abi2();
      var Api = function() {
        function Api2(args) {
          this.contracts = new Map();
          this.cachedAbis = new Map();
          this.rpc = args.rpc;
          this.authorityProvider = args.authorityProvider || args.rpc;
          this.abiProvider = args.abiProvider || args.rpc;
          this.signatureProvider = args.signatureProvider;
          this.chainId = args.chainId;
          this.textEncoder = args.textEncoder;
          this.textDecoder = args.textDecoder;
          this.abiTypes = ser.getTypesFromAbi(ser.createAbiTypes());
          this.transactionTypes = ser.getTypesFromAbi(ser.createInitialTypes(), transactionAbi);
        }
        Api2.prototype.rawAbiToJson = function(rawAbi) {
          var buffer = new ser.SerialBuffer({
            textEncoder: this.textEncoder,
            textDecoder: this.textDecoder,
            array: rawAbi
          });
          if (!ser.supportedAbiVersion(buffer.getString())) {
            throw new Error("Unsupported abi version");
          }
          buffer.restartRead();
          return this.abiTypes.get("abi_def").deserialize(buffer);
        };
        Api2.prototype.jsonToRawAbi = function(jsonAbi) {
          var buffer = new ser.SerialBuffer({
            textEncoder: this.textEncoder,
            textDecoder: this.textDecoder
          });
          this.abiTypes.get("abi_def").serialize(buffer, jsonAbi);
          if (!ser.supportedAbiVersion(buffer.getString())) {
            throw new Error("Unsupported abi version");
          }
          return buffer.asUint8Array();
        };
        Api2.prototype.getCachedAbi = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            var cachedAbi, rawAbi, abi, e_1;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!reload && this.cachedAbis.get(accountName)) {
                    return [2, this.cachedAbis.get(accountName)];
                  }
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 3, , 4]);
                  return [4, this.abiProvider.getRawAbi(accountName)];
                case 2:
                  rawAbi = _a.sent().abi;
                  abi = this.rawAbiToJson(rawAbi);
                  cachedAbi = { rawAbi, abi };
                  return [3, 4];
                case 3:
                  e_1 = _a.sent();
                  e_1.message = "fetching abi for " + accountName + ": " + e_1.message;
                  throw e_1;
                case 4:
                  if (!cachedAbi) {
                    throw new Error("Missing abi for " + accountName);
                  }
                  this.cachedAbis.set(accountName, cachedAbi);
                  return [2, cachedAbi];
              }
            });
          });
        };
        Api2.prototype.getAbi = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getCachedAbi(accountName, reload)];
                case 1:
                  return [2, _a.sent().abi];
              }
            });
          });
        };
        Api2.prototype.getTransactionAbis = function(transaction, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            var actions, accounts, uniqueAccounts, actionPromises;
            var _this = this;
            return __generator(this, function(_a) {
              actions = (transaction.context_free_actions || []).concat(transaction.actions);
              accounts = actions.map(function(action) {
                return action.account;
              });
              uniqueAccounts = new Set(accounts);
              actionPromises = __spreadArray([], __read(uniqueAccounts)).map(function(account) {
                return __awaiter(_this, void 0, void 0, function() {
                  var _a2;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        _a2 = {
                          accountName: account
                        };
                        return [4, this.getCachedAbi(account, reload)];
                      case 1:
                        return [2, (_a2.abi = _b.sent().rawAbi, _a2)];
                    }
                  });
                });
              });
              return [2, Promise.all(actionPromises)];
            });
          });
        };
        Api2.prototype.getContract = function(accountName, reload) {
          if (reload === void 0) {
            reload = false;
          }
          return __awaiter(this, void 0, void 0, function() {
            var abi, types, actions, _a, _b, _c, name_1, type, result;
            var e_2, _d;
            return __generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  if (!reload && this.contracts.get(accountName)) {
                    return [2, this.contracts.get(accountName)];
                  }
                  return [4, this.getAbi(accountName, reload)];
                case 1:
                  abi = _e.sent();
                  types = ser.getTypesFromAbi(ser.createInitialTypes(), abi);
                  actions = new Map();
                  try {
                    for (_a = __values(abi.actions), _b = _a.next(); !_b.done; _b = _a.next()) {
                      _c = _b.value, name_1 = _c.name, type = _c.type;
                      actions.set(name_1, ser.getType(types, type));
                    }
                  } catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                  } finally {
                    try {
                      if (_b && !_b.done && (_d = _a.return))
                        _d.call(_a);
                    } finally {
                      if (e_2)
                        throw e_2.error;
                    }
                  }
                  result = { types, actions };
                  this.contracts.set(accountName, result);
                  return [2, result];
              }
            });
          });
        };
        Api2.prototype.serialize = function(buffer, type, value) {
          this.transactionTypes.get(type).serialize(buffer, value);
        };
        Api2.prototype.deserialize = function(buffer, type) {
          return this.transactionTypes.get(type).deserialize(buffer);
        };
        Api2.prototype.serializeTransaction = function(transaction) {
          var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          this.serialize(buffer, "transaction", __assign({ max_net_usage_words: 0, max_cpu_usage_ms: 0, delay_sec: 0, context_free_actions: [], actions: [], transaction_extensions: [] }, transaction));
          return buffer.asUint8Array();
        };
        Api2.prototype.serializeContextFreeData = function(contextFreeData) {
          var e_3, _a;
          if (!contextFreeData || !contextFreeData.length) {
            return null;
          }
          var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          buffer.pushVaruint32(contextFreeData.length);
          try {
            for (var contextFreeData_1 = __values(contextFreeData), contextFreeData_1_1 = contextFreeData_1.next(); !contextFreeData_1_1.done; contextFreeData_1_1 = contextFreeData_1.next()) {
              var data = contextFreeData_1_1.value;
              buffer.pushBytes(data);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (contextFreeData_1_1 && !contextFreeData_1_1.done && (_a = contextFreeData_1.return))
                _a.call(contextFreeData_1);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          return buffer.asUint8Array();
        };
        Api2.prototype.deserializeTransaction = function(transaction) {
          var buffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
          buffer.pushArray(transaction);
          return this.deserialize(buffer, "transaction");
        };
        Api2.prototype.serializeActions = function(actions) {
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, Promise.all(actions.map(function(action) {
                    return __awaiter(_this, void 0, void 0, function() {
                      var account, name, authorization, data, contract;
                      return __generator(this, function(_a2) {
                        switch (_a2.label) {
                          case 0:
                            account = action.account, name = action.name, authorization = action.authorization, data = action.data;
                            return [4, this.getContract(account)];
                          case 1:
                            contract = _a2.sent();
                            if (typeof data !== "object") {
                              return [2, action];
                            }
                            return [2, ser.serializeAction(contract, account, name, authorization, data, this.textEncoder, this.textDecoder)];
                        }
                      });
                    });
                  }))];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        Api2.prototype.deserializeActions = function(actions) {
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, Promise.all(actions.map(function(_a2) {
                    var account = _a2.account, name = _a2.name, authorization = _a2.authorization, data = _a2.data;
                    return __awaiter(_this, void 0, void 0, function() {
                      var contract;
                      return __generator(this, function(_b) {
                        switch (_b.label) {
                          case 0:
                            return [4, this.getContract(account)];
                          case 1:
                            contract = _b.sent();
                            return [2, ser.deserializeAction(contract, account, name, authorization, data, this.textEncoder, this.textDecoder)];
                        }
                      });
                    });
                  }))];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        Api2.prototype.deserializeTransactionWithActions = function(transaction) {
          return __awaiter(this, void 0, void 0, function() {
            var deserializedTransaction, deserializedCFActions, deserializedActions;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (typeof transaction === "string") {
                    transaction = ser.hexToUint8Array(transaction);
                  }
                  deserializedTransaction = this.deserializeTransaction(transaction);
                  return [4, this.deserializeActions(deserializedTransaction.context_free_actions)];
                case 1:
                  deserializedCFActions = _a.sent();
                  return [4, this.deserializeActions(deserializedTransaction.actions)];
                case 2:
                  deserializedActions = _a.sent();
                  return [2, __assign(__assign({}, deserializedTransaction), { context_free_actions: deserializedCFActions, actions: deserializedActions })];
              }
            });
          });
        };
        Api2.prototype.deflateSerializedArray = function(serializedArray) {
          return pako_1.deflate(serializedArray, { level: 9 });
        };
        Api2.prototype.inflateSerializedArray = function(compressedSerializedArray) {
          return pako_1.inflate(compressedSerializedArray);
        };
        Api2.prototype.transact = function(transaction, _a) {
          var _b = _a === void 0 ? {} : _a, _c = _b.broadcast, broadcast = _c === void 0 ? true : _c, _d = _b.sign, sign = _d === void 0 ? true : _d, requiredKeys = _b.requiredKeys, compression = _b.compression, blocksBehind = _b.blocksBehind, useLastIrreversible = _b.useLastIrreversible, expireSeconds = _b.expireSeconds;
          return __awaiter(this, void 0, void 0, function() {
            var info, abis, _e, serializedTransaction, serializedContextFreeData, pushTransactionArgs, availableKeys, result;
            var _f;
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  if (typeof blocksBehind === "number" && useLastIrreversible) {
                    throw new Error("Use either blocksBehind or useLastIrreversible");
                  }
                  if (!!this.chainId)
                    return [3, 2];
                  return [4, this.rpc.get_info()];
                case 1:
                  info = _g.sent();
                  this.chainId = info.chain_id;
                  _g.label = 2;
                case 2:
                  if (!((typeof blocksBehind === "number" || useLastIrreversible) && expireSeconds))
                    return [3, 4];
                  return [4, this.generateTapos(info, transaction, blocksBehind, useLastIrreversible, expireSeconds)];
                case 3:
                  transaction = _g.sent();
                  _g.label = 4;
                case 4:
                  if (!this.hasRequiredTaposFields(transaction)) {
                    throw new Error("Required configuration or TAPOS fields are not present");
                  }
                  return [4, this.getTransactionAbis(transaction)];
                case 5:
                  abis = _g.sent();
                  _e = [__assign({}, transaction)];
                  _f = {};
                  return [4, this.serializeActions(transaction.context_free_actions || [])];
                case 6:
                  _f.context_free_actions = _g.sent();
                  return [4, this.serializeActions(transaction.actions)];
                case 7:
                  transaction = __assign.apply(void 0, _e.concat([(_f.actions = _g.sent(), _f)]));
                  serializedTransaction = this.serializeTransaction(transaction);
                  serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);
                  pushTransactionArgs = {
                    serializedTransaction,
                    serializedContextFreeData,
                    signatures: []
                  };
                  if (!sign)
                    return [3, 12];
                  if (!!requiredKeys)
                    return [3, 10];
                  return [4, this.signatureProvider.getAvailableKeys()];
                case 8:
                  availableKeys = _g.sent();
                  return [4, this.authorityProvider.getRequiredKeys({ transaction, availableKeys })];
                case 9:
                  requiredKeys = _g.sent();
                  _g.label = 10;
                case 10:
                  return [4, this.signatureProvider.sign({
                    chainId: this.chainId,
                    requiredKeys,
                    serializedTransaction,
                    serializedContextFreeData,
                    abis
                  })];
                case 11:
                  pushTransactionArgs = _g.sent();
                  _g.label = 12;
                case 12:
                  if (broadcast) {
                    result = void 0;
                    if (compression) {
                      return [2, this.pushCompressedSignedTransaction(pushTransactionArgs)];
                    }
                    return [2, this.pushSignedTransaction(pushTransactionArgs)];
                  }
                  return [2, pushTransactionArgs];
              }
            });
          });
        };
        Api2.prototype.query = function(account, short, query, _a) {
          var sign = _a.sign, requiredKeys = _a.requiredKeys, _b = _a.authorization, authorization = _b === void 0 ? [] : _b;
          return __awaiter(this, void 0, void 0, function() {
            var info, refBlock, queryBuffer, transaction, serializedTransaction, signatures, abis, availableKeys, signResponse, response, returnBuffer;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [4, this.rpc.get_info()];
                case 1:
                  info = _c.sent();
                  return [4, this.tryRefBlockFromGetInfo(info)];
                case 2:
                  refBlock = _c.sent();
                  queryBuffer = new ser.SerialBuffer({ textEncoder: this.textEncoder, textDecoder: this.textDecoder });
                  ser.serializeQuery(queryBuffer, query);
                  transaction = __assign(__assign({}, ser.transactionHeader(refBlock, 60 * 30)), { context_free_actions: [], actions: [{
                    account,
                    name: "queryit",
                    authorization,
                    data: ser.arrayToHex(queryBuffer.asUint8Array())
                  }] });
                  serializedTransaction = this.serializeTransaction(transaction);
                  signatures = [];
                  if (!sign)
                    return [3, 8];
                  return [4, this.getTransactionAbis(transaction)];
                case 3:
                  abis = _c.sent();
                  if (!!requiredKeys)
                    return [3, 6];
                  return [4, this.signatureProvider.getAvailableKeys()];
                case 4:
                  availableKeys = _c.sent();
                  return [4, this.authorityProvider.getRequiredKeys({ transaction, availableKeys })];
                case 5:
                  requiredKeys = _c.sent();
                  _c.label = 6;
                case 6:
                  return [4, this.signatureProvider.sign({
                    chainId: this.chainId,
                    requiredKeys,
                    serializedTransaction,
                    serializedContextFreeData: null,
                    abis
                  })];
                case 7:
                  signResponse = _c.sent();
                  signatures = signResponse.signatures;
                  _c.label = 8;
                case 8:
                  return [4, this.rpc.send_transaction({
                    signatures,
                    compression: 0,
                    serializedTransaction
                  })];
                case 9:
                  response = _c.sent();
                  returnBuffer = new ser.SerialBuffer({
                    textEncoder: this.textEncoder,
                    textDecoder: this.textDecoder,
                    array: ser.hexToUint8Array(response.processed.action_traces[0][1].return_value)
                  });
                  if (short) {
                    return [2, ser.deserializeAnyvarShort(returnBuffer)];
                  } else {
                    return [2, ser.deserializeAnyvar(returnBuffer)];
                  }
                  return [2];
              }
            });
          });
        };
        Api2.prototype.pushSignedTransaction = function(_a) {
          var signatures = _a.signatures, serializedTransaction = _a.serializedTransaction, serializedContextFreeData = _a.serializedContextFreeData;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_b) {
              return [2, this.rpc.push_transaction({
                signatures,
                serializedTransaction,
                serializedContextFreeData
              })];
            });
          });
        };
        Api2.prototype.pushCompressedSignedTransaction = function(_a) {
          var signatures = _a.signatures, serializedTransaction = _a.serializedTransaction, serializedContextFreeData = _a.serializedContextFreeData;
          return __awaiter(this, void 0, void 0, function() {
            var compressedSerializedTransaction, compressedSerializedContextFreeData;
            return __generator(this, function(_b) {
              compressedSerializedTransaction = this.deflateSerializedArray(serializedTransaction);
              compressedSerializedContextFreeData = this.deflateSerializedArray(serializedContextFreeData || new Uint8Array(0));
              return [2, this.rpc.push_transaction({
                signatures,
                compression: 1,
                serializedTransaction: compressedSerializedTransaction,
                serializedContextFreeData: compressedSerializedContextFreeData
              })];
            });
          });
        };
        Api2.prototype.generateTapos = function(info, transaction, blocksBehind, useLastIrreversible, expireSeconds) {
          return __awaiter(this, void 0, void 0, function() {
            var block, taposBlockNumber, refBlock, _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!!info)
                    return [3, 2];
                  return [4, this.rpc.get_info()];
                case 1:
                  info = _b.sent();
                  _b.label = 2;
                case 2:
                  if (!useLastIrreversible)
                    return [3, 4];
                  return [4, this.tryRefBlockFromGetInfo(info)];
                case 3:
                  block = _b.sent();
                  return [2, __assign(__assign({}, ser.transactionHeader(block, expireSeconds)), transaction)];
                case 4:
                  taposBlockNumber = info.head_block_num - blocksBehind;
                  if (!(taposBlockNumber <= info.last_irreversible_block_num))
                    return [3, 6];
                  return [4, this.tryGetBlockInfo(taposBlockNumber)];
                case 5:
                  _a = _b.sent();
                  return [3, 8];
                case 6:
                  return [4, this.tryGetBlockHeaderState(taposBlockNumber)];
                case 7:
                  _a = _b.sent();
                  _b.label = 8;
                case 8:
                  refBlock = _a;
                  return [2, __assign(__assign({}, ser.transactionHeader(refBlock, expireSeconds)), transaction)];
              }
            });
          });
        };
        Api2.prototype.hasRequiredTaposFields = function(_a) {
          var expiration = _a.expiration, ref_block_num = _a.ref_block_num, ref_block_prefix = _a.ref_block_prefix;
          return !!(expiration && typeof ref_block_num === "number" && typeof ref_block_prefix === "number");
        };
        Api2.prototype.tryGetBlockHeaderState = function(taposBlockNumber) {
          return __awaiter(this, void 0, void 0, function() {
            var error_1;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 2, , 4]);
                  return [4, this.rpc.get_block_header_state(taposBlockNumber)];
                case 1:
                  return [2, _a.sent()];
                case 2:
                  error_1 = _a.sent();
                  return [4, this.tryGetBlockInfo(taposBlockNumber)];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  return [2];
              }
            });
          });
        };
        Api2.prototype.tryGetBlockInfo = function(blockNumber) {
          return __awaiter(this, void 0, void 0, function() {
            var error_2;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 2, , 4]);
                  return [4, this.rpc.get_block_info(blockNumber)];
                case 1:
                  return [2, _a.sent()];
                case 2:
                  error_2 = _a.sent();
                  return [4, this.rpc.get_block(blockNumber)];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  return [2];
              }
            });
          });
        };
        Api2.prototype.tryRefBlockFromGetInfo = function(info) {
          return __awaiter(this, void 0, void 0, function() {
            var block;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!(info.hasOwnProperty("last_irreversible_block_id") && info.hasOwnProperty("last_irreversible_block_num") && info.hasOwnProperty("last_irreversible_block_time")))
                    return [3, 1];
                  return [2, {
                    block_num: info.last_irreversible_block_num,
                    id: info.last_irreversible_block_id,
                    timestamp: info.last_irreversible_block_time
                  }];
                case 1:
                  return [4, this.tryGetBlockInfo(info.last_irreversible_block_num)];
                case 2:
                  block = _a.sent();
                  return [2, {
                    block_num: block.block_num,
                    id: block.id,
                    timestamp: block.timestamp
                  }];
              }
            });
          });
        };
        Api2.prototype.with = function(accountName) {
          return new ActionBuilder(this, accountName);
        };
        Api2.prototype.buildTransaction = function(cb) {
          var tx = new TransactionBuilder(this);
          if (cb) {
            return cb(tx);
          }
          return tx;
        };
        return Api2;
      }();
      exports.Api = Api;
      var TransactionBuilder = function() {
        function TransactionBuilder2(api) {
          this.actions = [];
          this.contextFreeGroups = [];
          this.api = api;
        }
        TransactionBuilder2.prototype.with = function(accountName) {
          var actionBuilder = new ActionBuilder(this.api, accountName);
          this.actions.push(actionBuilder);
          return actionBuilder;
        };
        TransactionBuilder2.prototype.associateContextFree = function(contextFreeGroup) {
          this.contextFreeGroups.push(contextFreeGroup);
          return this;
        };
        TransactionBuilder2.prototype.send = function(config) {
          return __awaiter(this, void 0, void 0, function() {
            var contextFreeDataSet, contextFreeActions, actions;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  contextFreeDataSet = [];
                  contextFreeActions = [];
                  actions = this.actions.map(function(actionBuilder) {
                    return actionBuilder.serializedData;
                  });
                  return [4, Promise.all(this.contextFreeGroups.map(function(contextFreeCallback) {
                    return __awaiter(_this, void 0, void 0, function() {
                      var _a2, action, contextFreeAction, contextFreeData;
                      return __generator(this, function(_b) {
                        _a2 = contextFreeCallback({
                          cfd: contextFreeDataSet.length,
                          cfa: contextFreeActions.length
                        }), action = _a2.action, contextFreeAction = _a2.contextFreeAction, contextFreeData = _a2.contextFreeData;
                        if (action) {
                          actions.push(action);
                        }
                        if (contextFreeAction) {
                          contextFreeActions.push(contextFreeAction);
                        }
                        if (contextFreeData) {
                          contextFreeDataSet.push(contextFreeData);
                        }
                        return [2];
                      });
                    });
                  }))];
                case 1:
                  _a.sent();
                  this.contextFreeGroups = [];
                  this.actions = [];
                  return [4, this.api.transact({
                    context_free_data: contextFreeDataSet,
                    context_free_actions: contextFreeActions,
                    actions
                  }, config)];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return TransactionBuilder2;
      }();
      exports.TransactionBuilder = TransactionBuilder;
      var ActionBuilder = function() {
        function ActionBuilder2(api, accountName) {
          this.api = api;
          this.accountName = accountName;
        }
        ActionBuilder2.prototype.as = function(actorName) {
          if (actorName === void 0) {
            actorName = [];
          }
          var authorization = [];
          if (actorName && typeof actorName === "string") {
            authorization = [{ actor: actorName, permission: "active" }];
          } else {
            authorization = actorName;
          }
          return new ActionSerializer(this, this.api, this.accountName, authorization);
        };
        return ActionBuilder2;
      }();
      exports.ActionBuilder = ActionBuilder;
      var ActionSerializer = function() {
        function ActionSerializer2(parent, api, accountName, authorization) {
          var e_4, _a;
          var _this = this;
          var jsonAbi = api.cachedAbis.get(accountName);
          if (!jsonAbi) {
            throw new Error("ABI must be cached before using ActionBuilder, run api.getAbi()");
          }
          var types = ser.getTypesFromAbi(ser.createInitialTypes(), jsonAbi.abi);
          var actions = new Map();
          try {
            for (var _b = __values(jsonAbi.abi.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
              var _d = _c.value, name_2 = _d.name, type = _d.type;
              actions.set(name_2, ser.getType(types, type));
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_4)
                throw e_4.error;
            }
          }
          actions.forEach(function(type2, name) {
            var _a2;
            Object.assign(_this, (_a2 = {}, _a2[name] = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var data = {};
              args.forEach(function(arg, index) {
                var field = type2.fields[index];
                data[field.name] = arg;
              });
              var serializedData = ser.serializeAction({ types, actions }, accountName, name, authorization, data, api.textEncoder, api.textDecoder);
              parent.serializedData = serializedData;
              return serializedData;
            }, _a2));
          });
        }
        return ActionSerializer2;
      }();
    }
  });

  // node_modules/eosjs/dist/eosjs-api-interfaces.js
  var require_eosjs_api_interfaces2 = __commonJS({
    "node_modules/eosjs/dist/eosjs-api-interfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/eosjs/dist/eosjs-rpcerror.js
  var require_eosjs_rpcerror2 = __commonJS({
    "node_modules/eosjs/dist/eosjs-rpcerror.js"(exports) {
      "use strict";
      var __extends = exports && exports.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RpcError = void 0;
      var RpcError = function(_super) {
        __extends(RpcError2, _super);
        function RpcError2(json) {
          var _this = this;
          if (json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
            _this = _super.call(this, json.error.details[0].message) || this;
          } else if (json.processed && json.processed.except && json.processed.except.message) {
            _this = _super.call(this, json.processed.except.message) || this;
          } else {
            _this = _super.call(this, json.message) || this;
          }
          Object.setPrototypeOf(_this, RpcError2.prototype);
          _this.json = json;
          return _this;
        }
        return RpcError2;
      }(Error);
      exports.RpcError = RpcError;
    }
  });

  // node_modules/eosjs/dist/eosjs-jsonrpc.js
  var require_eosjs_jsonrpc2 = __commonJS({
    "node_modules/eosjs/dist/eosjs-jsonrpc.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f2, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f2 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __values = exports && exports.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JsonRpc = void 0;
      var eosjs_numeric_1 = require_eosjs_numeric2();
      var eosjs_rpcerror_1 = require_eosjs_rpcerror2();
      var arrayToHex = function(data) {
        var e_1, _a;
        var result = "";
        try {
          for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var x = data_1_1.value;
            result += ("00" + x.toString(16)).slice(-2);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (data_1_1 && !data_1_1.done && (_a = data_1.return))
              _a.call(data_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return result;
      };
      var JsonRpc = function() {
        function JsonRpc2(endpoint, args) {
          if (args === void 0) {
            args = {};
          }
          this.endpoint = endpoint.replace(/\/$/, "");
          if (args.fetch) {
            this.fetchBuiltin = args.fetch;
          } else {
            this.fetchBuiltin = global.fetch;
          }
        }
        JsonRpc2.prototype.fetch = function(path, body) {
          return __awaiter(this, void 0, void 0, function() {
            var response, json, f2, e_2;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 3, , 4]);
                  f2 = this.fetchBuiltin;
                  return [4, f2(this.endpoint + path, {
                    body: JSON.stringify(body),
                    method: "POST"
                  })];
                case 1:
                  response = _a.sent();
                  return [4, response.json()];
                case 2:
                  json = _a.sent();
                  if (json.processed && json.processed.except) {
                    throw new eosjs_rpcerror_1.RpcError(json);
                  }
                  return [3, 4];
                case 3:
                  e_2 = _a.sent();
                  e_2.isFetchError = true;
                  throw e_2;
                case 4:
                  if (!response.ok) {
                    throw new eosjs_rpcerror_1.RpcError(json);
                  }
                  return [2, json];
              }
            });
          });
        };
        JsonRpc2.prototype.abi_bin_to_json = function(code, action, binargs) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/abi_bin_to_json", { code, action, binargs })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.abi_json_to_bin = function(code, action, args) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/abi_json_to_bin", { code, action, args })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_abi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_abi", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_account = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_account", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_accounts_by_authorizers = function(accounts, keys) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_accounts_by_authorizers", { accounts, keys })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_activated_protocol_features = function(_a) {
          var _b = _a.limit, limit = _b === void 0 ? 10 : _b, _c = _a.search_by_block_num, search_by_block_num = _c === void 0 ? false : _c, _d = _a.reverse, reverse = _d === void 0 ? false : _d, _e = _a.lower_bound, lower_bound = _e === void 0 ? null : _e, _f = _a.upper_bound, upper_bound = _f === void 0 ? null : _f;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_activated_protocol_features", { lower_bound, upper_bound, limit, search_by_block_num, reverse })];
                case 1:
                  return [2, _g.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_block_header_state = function(blockNumOrId) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_block_header_state", { block_num_or_id: blockNumOrId })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_block_info = function(blockNum) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_block_info", { block_num: blockNum })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_block = function(blockNumOrId) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_block", { block_num_or_id: blockNumOrId })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_code = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_code", {
                    account_name: accountName,
                    code_as_wasm: true
                  })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_code_hash = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_code_hash", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_currency_balance = function(code, account, symbol) {
          if (symbol === void 0) {
            symbol = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_currency_balance", { code, account, symbol })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_currency_stats = function(code, symbol) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_currency_stats", { code, symbol })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_info = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_info", {})];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_producer_schedule = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_producer_schedule", {})];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_producers = function(json, lowerBound, limit) {
          if (json === void 0) {
            json = true;
          }
          if (lowerBound === void 0) {
            lowerBound = "";
          }
          if (limit === void 0) {
            limit = 50;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_producers", { json, lower_bound: lowerBound, limit })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_raw_code_and_abi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_raw_code_and_abi", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.getRawAbi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            var rawAbi, abi;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.get_raw_abi(accountName)];
                case 1:
                  rawAbi = _a.sent();
                  abi = eosjs_numeric_1.base64ToBinary(rawAbi.abi);
                  return [2, { accountName: rawAbi.account_name, abi }];
              }
            });
          });
        };
        JsonRpc2.prototype.get_raw_abi = function(accountName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_raw_abi", { account_name: accountName })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_scheduled_transactions = function(json, lowerBound, limit) {
          if (json === void 0) {
            json = true;
          }
          if (lowerBound === void 0) {
            lowerBound = "";
          }
          if (limit === void 0) {
            limit = 50;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_scheduled_transactions", { json, lower_bound: lowerBound, limit })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_table_rows = function(_a) {
          var _b = _a.json, json = _b === void 0 ? true : _b, code = _a.code, scope = _a.scope, table = _a.table, _c = _a.lower_bound, lower_bound = _c === void 0 ? "" : _c, _d = _a.upper_bound, upper_bound = _d === void 0 ? "" : _d, _e = _a.index_position, index_position = _e === void 0 ? 1 : _e, _f = _a.key_type, key_type = _f === void 0 ? "" : _f, _g = _a.limit, limit = _g === void 0 ? 10 : _g, _h = _a.reverse, reverse = _h === void 0 ? false : _h, _j = _a.show_payer, show_payer = _j === void 0 ? false : _j;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_k) {
              switch (_k.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_table_rows", {
                    json,
                    code,
                    scope,
                    table,
                    lower_bound,
                    upper_bound,
                    index_position,
                    key_type,
                    limit,
                    reverse,
                    show_payer
                  })];
                case 1:
                  return [2, _k.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_kv_table_rows = function(_a) {
          var _b = _a.json, json = _b === void 0 ? true : _b, code = _a.code, table = _a.table, index_name = _a.index_name, _c = _a.encode_type, encode_type = _c === void 0 ? "bytes" : _c, index_value = _a.index_value, lower_bound = _a.lower_bound, upper_bound = _a.upper_bound, _d = _a.limit, limit = _d === void 0 ? 10 : _d, _e = _a.reverse, reverse = _e === void 0 ? false : _e, _f = _a.show_payer, show_payer = _f === void 0 ? false : _f;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_kv_table_rows", {
                    json,
                    code,
                    table,
                    index_name,
                    encode_type,
                    index_value,
                    lower_bound,
                    upper_bound,
                    limit,
                    reverse,
                    show_payer
                  })];
                case 1:
                  return [2, _g.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.get_table_by_scope = function(_a) {
          var code = _a.code, table = _a.table, _b = _a.lower_bound, lower_bound = _b === void 0 ? "" : _b, _c = _a.upper_bound, upper_bound = _c === void 0 ? "" : _c, _d = _a.limit, limit = _d === void 0 ? 10 : _d;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/get_table_by_scope", {
                    code,
                    table,
                    lower_bound,
                    upper_bound,
                    limit
                  })];
                case 1:
                  return [2, _e.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.getRequiredKeys = function(args) {
          return __awaiter(this, void 0, void 0, function() {
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a = eosjs_numeric_1.convertLegacyPublicKeys;
                  return [4, this.fetch("/v1/chain/get_required_keys", {
                    transaction: args.transaction,
                    available_keys: args.availableKeys
                  })];
                case 1:
                  return [2, _a.apply(void 0, [_b.sent().required_keys])];
              }
            });
          });
        };
        JsonRpc2.prototype.push_transaction = function(_a) {
          var signatures = _a.signatures, _b = _a.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a.serializedTransaction, serializedContextFreeData = _a.serializedContextFreeData;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/push_transaction", {
                    signatures,
                    compression,
                    packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),
                    packed_trx: arrayToHex(serializedTransaction)
                  })];
                case 1:
                  return [2, _c.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.push_transactions = function(transactions) {
          return __awaiter(this, void 0, void 0, function() {
            var packedTrxs;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  packedTrxs = transactions.map(function(_a2) {
                    var signatures = _a2.signatures, _b = _a2.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a2.serializedTransaction, serializedContextFreeData = _a2.serializedContextFreeData;
                    return {
                      signatures,
                      compression,
                      packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),
                      packed_trx: arrayToHex(serializedTransaction)
                    };
                  });
                  return [4, this.fetch("/v1/chain/push_transactions", packedTrxs)];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.send_transaction = function(_a) {
          var signatures = _a.signatures, _b = _a.compression, compression = _b === void 0 ? 0 : _b, serializedTransaction = _a.serializedTransaction, serializedContextFreeData = _a.serializedContextFreeData;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [4, this.fetch("/v1/chain/send_transaction", {
                    signatures,
                    compression,
                    packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),
                    packed_trx: arrayToHex(serializedTransaction)
                  })];
                case 1:
                  return [2, _c.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.db_size_get = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/db_size/get", {})];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.trace_get_block = function(block_num) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/trace_api/get_block", { block_num })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_actions = function(accountName, pos, offset) {
          if (pos === void 0) {
            pos = null;
          }
          if (offset === void 0) {
            offset = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_actions", { account_name: accountName, pos, offset })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_transaction = function(id, blockNumHint) {
          if (blockNumHint === void 0) {
            blockNumHint = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_transaction", { id, block_num_hint: blockNumHint })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_key_accounts = function(publicKey) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_key_accounts", { public_key: publicKey })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        JsonRpc2.prototype.history_get_controlled_accounts = function(controllingAccount) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetch("/v1/history/get_controlled_accounts", { controlling_account: controllingAccount })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return JsonRpc2;
      }();
      exports.JsonRpc = JsonRpc;
    }
  });

  // node_modules/eosjs/dist/eosjs-rpc-interfaces.js
  var require_eosjs_rpc_interfaces2 = __commonJS({
    "node_modules/eosjs/dist/eosjs-rpc-interfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/eosjs/dist/index.js
  var require_dist3 = __commonJS({
    "node_modules/eosjs/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Serialize = exports.RpcError = exports.RpcInterfaces = exports.Numeric = exports.JsonRpc = exports.ApiInterfaces = exports.Api = void 0;
      var eosjs_api_1 = require_eosjs_api2();
      Object.defineProperty(exports, "Api", { enumerable: true, get: function() {
        return eosjs_api_1.Api;
      } });
      var ApiInterfaces = require_eosjs_api_interfaces2();
      exports.ApiInterfaces = ApiInterfaces;
      var eosjs_jsonrpc_1 = require_eosjs_jsonrpc2();
      Object.defineProperty(exports, "JsonRpc", { enumerable: true, get: function() {
        return eosjs_jsonrpc_1.JsonRpc;
      } });
      var Numeric = require_eosjs_numeric2();
      exports.Numeric = Numeric;
      var RpcInterfaces = require_eosjs_rpc_interfaces2();
      exports.RpcInterfaces = RpcInterfaces;
      var eosjs_rpcerror_1 = require_eosjs_rpcerror2();
      Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
        return eosjs_rpcerror_1.RpcError;
      } });
      var Serialize = require_eosjs_serialize2();
      exports.Serialize = Serialize;
    }
  });

  // node_modules/elliptic/package.json
  var require_package = __commonJS({
    "node_modules/elliptic/package.json"(exports, module) {
      module.exports = {
        name: "elliptic",
        version: "6.5.4",
        description: "EC cryptography",
        main: "lib/elliptic.js",
        files: [
          "lib"
        ],
        scripts: {
          lint: "eslint lib test",
          "lint:fix": "npm run lint -- --fix",
          unit: "istanbul test _mocha --reporter=spec test/index.js",
          test: "npm run lint && npm run unit",
          version: "grunt dist && git add dist/"
        },
        repository: {
          type: "git",
          url: "git@github.com:indutny/elliptic"
        },
        keywords: [
          "EC",
          "Elliptic",
          "curve",
          "Cryptography"
        ],
        author: "Fedor Indutny <fedor@indutny.com>",
        license: "MIT",
        bugs: {
          url: "https://github.com/indutny/elliptic/issues"
        },
        homepage: "https://github.com/indutny/elliptic",
        devDependencies: {
          brfs: "^2.0.2",
          coveralls: "^3.1.0",
          eslint: "^7.6.0",
          grunt: "^1.2.1",
          "grunt-browserify": "^5.3.0",
          "grunt-cli": "^1.3.2",
          "grunt-contrib-connect": "^3.0.0",
          "grunt-contrib-copy": "^1.0.0",
          "grunt-contrib-uglify": "^5.0.0",
          "grunt-mocha-istanbul": "^5.0.2",
          "grunt-saucelabs": "^9.0.1",
          istanbul: "^0.4.5",
          mocha: "^8.0.1"
        },
        dependencies: {
          "bn.js": "^4.11.9",
          brorand: "^1.1.0",
          "hash.js": "^1.0.0",
          "hmac-drbg": "^1.0.1",
          inherits: "^2.0.4",
          "minimalistic-assert": "^1.0.1",
          "minimalistic-crypto-utils": "^1.0.1"
        }
      };
    }
  });

  // (disabled):buffer
  var require_buffer = __commonJS({
    "(disabled):buffer"() {
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN;
        } else {
          exports2.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = require_buffer().Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(a.red && a.red === b.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/minimalistic-crypto-utils/lib/utils.js
  var require_utils2 = __commonJS({
    "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
      "use strict";
      var utils = exports;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        } else {
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            var hi = c >> 8;
            var lo = c & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      utils.toHex = toHex;
      utils.encode = function encode(arr, enc) {
        if (enc === "hex")
          return toHex(arr);
        else
          return arr;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/utils.js
  var require_utils3 = __commonJS({
    "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
      "use strict";
      var utils = exports;
      var BN = require_bn();
      var minAssert = require_minimalistic_assert();
      var minUtils = require_utils2();
      utils.assert = minAssert;
      utils.toArray = minUtils.toArray;
      utils.zero2 = minUtils.zero2;
      utils.toHex = minUtils.toHex;
      utils.encode = minUtils.encode;
      function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws = 1 << w + 1;
        var k = num.clone();
        for (var i = 0; i < naf.length; i++) {
          var z;
          var mod = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod > (ws >> 1) - 1)
              z = (ws >> 1) - mod;
            else
              z = mod;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF;
      function getJSF(k1, k2) {
        var jsf = [
          [],
          []
        ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF;
      function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty2() {
          return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new BN(bytes, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/brorand/index.js
  var require_brorand = __commonJS({
    "node_modules/brorand/index.js"(exports, module) {
      var r;
      module.exports = function rand(len) {
        if (!r)
          r = new Rand(null);
        return r.generate(len);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      module.exports.Rand = Rand;
      Rand.prototype.generate = function generate(len) {
        return this._rand(len);
      };
      Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++)
          res[i] = this.rand.getByte();
        return res;
      };
      if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.crypto.getRandomValues(arr);
            return arr;
          };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.msCrypto.getRandomValues(arr);
            return arr;
          };
        } else if (typeof window === "object") {
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      } else {
        try {
          crypto2 = require_crypto();
          if (typeof crypto2.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n) {
            return crypto2.randomBytes(n);
          };
        } catch (e) {
        }
      }
      var crypto2;
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/base.js
  var require_base = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var utils = require_utils3();
      var getNAF = utils.getNAF;
      var getJSF = utils.getJSF;
      var assert = utils.assert;
      function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN(conf.p, 16);
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.zero = new BN(0).toRed(this.red);
        this.one = new BN(1).toRed(this.red);
        this.two = new BN(2).toRed(this.red);
        this.n = conf.n && new BN(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
          this.redN = null;
        } else {
          this._maxwellTrick = true;
          this.redN = this.n.toRed(this.red);
        }
      }
      module.exports = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate2() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1, this._bitLength);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        var j;
        var nafW;
        for (j = 0; j < naf.length; j += doubles.step) {
          nafW = 0;
          for (var l = j + doubles.step - 1; l >= j; l--)
            nafW = (nafW << 1) + naf[l];
          repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
          for (j = 0; j < repr.length; j++) {
            nafW = repr[j];
            if (nafW === i)
              b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i)
              b = b.mixedAdd(doubles.points[j].neg());
          }
          a = a.add(b);
        }
        return a.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
          for (var l = 0; i >= 0 && naf[i] === 0; i--)
            l++;
          if (i >= 0)
            l++;
          acc = acc.dblp(l);
          if (i < 0)
            break;
          var z = naf[i];
          assert(z !== 0);
          if (p.type === "affine") {
            if (z > 0)
              acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
          } else {
            if (z > 0)
              acc = acc.add(wnd[z - 1 >> 1]);
            else
              acc = acc.add(wnd[-z - 1 >> 1].neg());
          }
        }
        return p.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        var i;
        var j;
        var p;
        for (i = 0; i < len; i++) {
          p = points[i];
          var nafPoints = p._getNAFPoints(defW);
          wndWidth[i] = nafPoints.wnd;
          wnd[i] = nafPoints.points;
        }
        for (i = len - 1; i >= 1; i -= 2) {
          var a = i - 1;
          var b = i;
          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
          }
          var comb = [
            points[a],
            null,
            null,
            points[b]
          ];
          if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          }
          var index = [
            -3,
            -1,
            -5,
            -7,
            0,
            7,
            5,
            1,
            3
          ];
          var jsf = getJSF(coeffs[a], coeffs[b]);
          max = Math.max(jsf[0].length, max);
          naf[a] = new Array(max);
          naf[b] = new Array(max);
          for (j = 0; j < max; j++) {
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
          }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (i = max; i >= 0; i--) {
          var k = 0;
          while (i >= 0) {
            var zero = true;
            for (j = 0; j < len; j++) {
              tmp[j] = naf[j][i] | 0;
              if (tmp[j] !== 0)
                zero = false;
            }
            if (!zero)
              break;
            k++;
            i--;
          }
          if (i >= 0)
            k++;
          acc = acc.dblp(k);
          if (i < 0)
            break;
          for (j = 0; j < len; j++) {
            var z = tmp[j];
            p;
            if (z === 0)
              continue;
            else if (z > 0)
              p = wnd[j][z - 1 >> 1];
            else if (z < 0)
              p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine")
              acc = acc.mixedAdd(p);
            else
              acc = acc.add(p);
          }
        }
        for (i = 0; i < len; i++)
          wnd[i] = null;
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate2() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils.toArray(bytes, enc);
        var len = this.p.byteLength();
        if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
          if (bytes[0] === 6)
            assert(bytes[bytes.length - 1] % 2 === 0);
          else if (bytes[0] === 7)
            assert(bytes[bytes.length - 1] % 2 === 1);
          var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
          return res;
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
          return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
        }
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact)
          return [this.getY().isEven() ? 2 : 3].concat(x);
        return [4].concat(x, this.getY().toArray("be", len));
      };
      BasePoint.prototype.encode = function encode(enc, compact) {
        return utils.encode(this._encode(compact), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = {
          doubles: null,
          naf: null,
          beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this];
        var acc = this;
        for (var i = 0; i < power; i += step) {
          for (var j = 0; j < step; j++)
            acc = acc.dbl();
          doubles.push(acc);
        }
        return {
          step,
          points: doubles
        };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++)
          res[i] = res[i - 1].add(dbl);
        return {
          wnd,
          points: res
        };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++)
          r = r.dbl();
        return r;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/short.js
  var require_short = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
      "use strict";
      var utils = require_utils3();
      var BN = require_bn();
      var inherits = require_inherits_browser();
      var Base = require_base();
      var assert = utils.assert;
      function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
      }
      inherits(ShortCurve, Base);
      module.exports = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta;
        var lambda;
        if (conf.beta) {
          beta = new BN(conf.beta, 16).toRed(this.red);
        } else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
          beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
          lambda = new BN(conf.lambda, 16);
        } else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
            lambda = lambdas[0];
          } else {
            lambda = lambdas[1];
            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
          }
        }
        var basis;
        if (conf.basis) {
          basis = conf.basis.map(function(vec) {
            return {
              a: new BN(vec.a, 16),
              b: new BN(vec.b, 16)
            };
          });
        } else {
          basis = this._getEndoBasis(lambda);
        }
        return {
          beta,
          lambda,
          basis
        };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num);
        var tinv = new BN(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new BN(1);
        var y1 = new BN(0);
        var x2 = new BN(0);
        var y2 = new BN(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
          var q = v.div(u);
          r = v.sub(q.mul(u));
          x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1));
          if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
          } else if (a1 && ++i === 2) {
            break;
          }
          prevR = r;
          v = u;
          u = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
          a2 = a0;
          b2 = b0;
        }
        if (a1.negative) {
          a1 = a1.neg();
          b1 = b1.neg();
        }
        if (a2.negative) {
          a2 = a2.neg();
          b2 = b2.neg();
        }
        return [
          { a: a1, b: b1 },
          { a: a2, b: b2 }
        ];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v12 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v12.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v12.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v12.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return { k1, k2 };
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      ShortCurve.prototype.validate = function validate2(point) {
        if (point.inf)
          return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();
          if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
          }
          if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split.k1;
          ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };
      function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
          this.x = null;
          this.y = null;
          this.inf = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
          }
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits(Point, Base.BasePoint);
      ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
      };
      Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve = this.curve;
          var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
          };
          pre.beta = beta;
          beta.precomputed = {
            beta: null,
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(endoMul)
            }
          };
        }
        return beta;
      };
      Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
          }
        }];
      };
      Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve.point(obj2[0], obj2[1], red);
        }
        var pre = obj[2];
        res.precomputed = {
          beta: null,
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [res].concat(pre.doubles.points.map(obj2point))
          },
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [res].concat(pre.naf.points.map(obj2point))
          }
        };
        return res;
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point.prototype.add = function add(p) {
        if (this.inf)
          return p;
        if (p.inf)
          return this;
        if (this.eq(p))
          return this.dbl();
        if (this.neg().eq(p))
          return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0)
          return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
          c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point.prototype.mul = function mul(k) {
        k = new BN(k, 16);
        if (this.isInfinity())
          return this;
        else if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k]);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
      };
      Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed;
          var negate = function(p) {
            return p.neg();
          };
          res.precomputed = {
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(negate)
            }
          };
        }
        return res;
      };
      Point.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
          this.x = this.curve.one;
          this.y = this.curve.one;
          this.z = new BN(0);
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = new BN(z, 16);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits(JPoint, Base.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity())
          return p.toJ();
        if (p.isInfinity())
          return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow)
          return this.dbl();
        var i;
        if (this.curve.zeroA || this.curve.threeA) {
          var r = this;
          for (i = 0; i < pow; i++)
            r = r.dbl();
          return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (i = 0; i < pow; i++) {
          var jx2 = jx.redSqr();
          var jyd2 = jyd.redSqr();
          var jyd4 = jyd2.redSqr();
          var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
          var t1 = jx.redMul(jyd2);
          var nx = c.redSqr().redISub(t1.redAdd(t1));
          var t2 = t1.redISub(nx);
          var dny = c.redMul(t2);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i + 1 < pow)
            jz4 = jz4.redMul(jyd4);
          jx = nx;
          jz = nz;
          jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx);
          var t = m.redSqr().redISub(s).redISub(s);
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          nx = t;
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var a = this.x.redSqr();
          var b = this.y.redSqr();
          var c = b.redSqr();
          var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
          d = d.redIAdd(d);
          var e = a.redAdd(a).redIAdd(a);
          var f2 = e.redSqr();
          var c8 = c.redIAdd(c);
          c8 = c8.redIAdd(c8);
          c8 = c8.redIAdd(c8);
          nx = f2.redISub(d).redISub(d);
          ny = e.redMul(d.redISub(nx)).redISub(c8);
          nz = this.y.redMul(this.z);
          nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
          var t = m.redSqr().redISub(s).redISub(s);
          nx = t;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr();
          var gamma = this.y.redSqr();
          var beta = this.x.redMul(gamma);
          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8);
          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN(k, kbase);
        return this.curve._wnafMul(this, k);
      };
      JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine")
          return this.eq(p.toJ());
        if (this === p)
          return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
          return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(zs);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/mont.js
  var require_mont = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var inherits = require_inherits_browser();
      var Base = require_base();
      var utils = require_utils3();
      function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.i4 = new BN(4).toRed(this.red).redInvm();
        this.two = new BN(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits(MontCurve, Base);
      module.exports = MontCurve;
      MontCurve.prototype.validate = function validate2(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
      };
      function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
          this.x = this.curve.one;
          this.z = this.curve.zero;
        } else {
          this.x = new BN(x, 16);
          this.z = new BN(z, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits(Point, Base.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils.toArray(bytes, enc), 1);
      };
      MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      Point.prototype.precompute = function precompute() {
      };
      Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
      };
      Point.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
          bits.push(t.andln(1));
        for (var i = bits.length - 1; i >= 0; i--) {
          if (bits[i] === 0) {
            a = a.diffAdd(b, c);
            b = b.dbl();
          } else {
            b = a.diffAdd(b, c);
            a = a.dbl();
          }
        }
        return b;
      };
      Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/edwards.js
  var require_edwards = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
      "use strict";
      var utils = require_utils3();
      var BN = require_bn();
      var inherits = require_inherits_browser();
      var Base = require_base();
      var assert = utils.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
      }
      inherits(EdwardsCurve, Base);
      module.exports = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN(y, 16);
        if (!y.red)
          y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.c2);
        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd)
          x = x.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.validate = function validate2(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
      };
      function Point(curve, x, y, z, t) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
          this.x = this.curve.zero;
          this.y = this.curve.one;
          this.z = this.curve.one;
          this.t = this.curve.zero;
          this.zOne = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = z ? new BN(z, 16) : this.curve.one;
          this.t = t && new BN(t, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          this.zOne = this.z === this.curve.one;
          if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits(Point, Base.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f2 = g.redSub(c);
        var h = d.redSub(b);
        var nx = e.redMul(f2);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f2.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        var e;
        var h;
        var j;
        if (this.curve.twisted) {
          e = this.curve._mulA(c);
          var f2 = e.redAdd(d);
          if (this.zOne) {
            nx = b.redSub(c).redSub(d).redMul(f2.redSub(this.curve.two));
            ny = f2.redMul(e.redSub(d));
            nz = f2.redSqr().redSub(f2).redSub(f2);
          } else {
            h = this.z.redSqr();
            j = f2.redSub(h).redISub(h);
            nx = b.redSub(c).redISub(d).redMul(j);
            ny = f2.redMul(e.redSub(d));
            nz = f2.redMul(j);
          }
        } else {
          e = c.redAdd(d);
          h = this.curve._mulC(this.z).redSqr();
          j = e.redSub(h).redSub(h);
          nx = this.curve._mulC(b.redISub(e)).redMul(j);
          ny = this.curve._mulC(e).redMul(c.redISub(d));
          nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f2 = d.redSub(c);
        var g = d.redAdd(c);
        var h = b.redAdd(a);
        var nx = e.redMul(f2);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f2.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f2 = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f2).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
          nz = f2.redMul(g);
        } else {
          ny = a.redMul(g).redMul(d.redSub(c));
          nz = this.curve._mulC(f2).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p);
        else
          return this._projAdd(p);
      };
      Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
      };
      Point.prototype.normalize = function normalize() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
          this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
      };
      Point.prototype.neg = function neg() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
      };
      Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(this.z);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point.prototype.toP = Point.prototype.normalize;
      Point.prototype.mixedAdd = Point.prototype.add;
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/index.js
  var require_curve = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
      "use strict";
      var curve = exports;
      curve.base = require_base();
      curve.short = require_short();
      curve.mont = require_mont();
      curve.edwards = require_edwards();
    }
  });

  // node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
  var require_secp256k1 = __commonJS({
    "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
      module.exports = {
        doubles: {
          step: 4,
          points: [
            [
              "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
              "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
              "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
              "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
              "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
              "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
              "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
              "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
              "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
              "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
              "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
              "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
              "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
              "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
              "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
              "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
              "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
              "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
              "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
              "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
              "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
              "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
              "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
              "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
              "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
              "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
              "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
              "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
              "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
              "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
              "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
              "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
              "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
              "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
              "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
              "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
              "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
              "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
              "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
              "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
              "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
              "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
              "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
              "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
              "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
              "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
              "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
              "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
              "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
              "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
              "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
              "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
              "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
              "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
              "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
              "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
              "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
              "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
              "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
              "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
              "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
              "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
              "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
              "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
              "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
              "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
              "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
              "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
              "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
              "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
              "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
              "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
              "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
              "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
              "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
              "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
              "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
              "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
              "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
              "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
              "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
              "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
              "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
              "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
              "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
              "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
              "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
              "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
              "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
              "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
              "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
              "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
              "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
              "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
              "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
              "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
              "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
              "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
              "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
              "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
              "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
              "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
              "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
              "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
              "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
              "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
              "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
              "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
              "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
              "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
              "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
              "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
              "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
              "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
              "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
              "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
              "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
              "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
              "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
              "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
              "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
              "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
              "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
              "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
              "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
              "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
              "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
              "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
              "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
              "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
          ]
        },
        naf: {
          wnd: 7,
          points: [
            [
              "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
              "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
              "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
              "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
              "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
              "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
              "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
              "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
              "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
              "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
              "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
              "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
              "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
              "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
              "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
              "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
              "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
              "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
              "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
              "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
              "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
              "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
              "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
              "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
              "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
              "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
              "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
              "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
              "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
              "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
              "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
              "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
              "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
              "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
              "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
              "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
              "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
              "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
              "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
              "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
              "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
              "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
              "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
              "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
              "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
              "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
              "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
              "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
              "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
              "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
              "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
              "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
              "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
              "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
              "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
              "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
              "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
              "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
              "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
              "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
              "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
              "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
              "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
              "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
              "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
              "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
              "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
              "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
              "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
              "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
              "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
              "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
              "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
              "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
              "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
              "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
              "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
              "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
              "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
              "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
              "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
              "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
              "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
              "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
              "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
              "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
              "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
              "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
              "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
              "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
              "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
              "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
              "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
              "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
              "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
              "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
              "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
              "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
              "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
              "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
              "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
              "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
              "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
              "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
              "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
              "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
              "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
              "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
              "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
              "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
              "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
              "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
              "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
              "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
              "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
              "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
              "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
              "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
              "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
              "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
              "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
              "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
              "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
              "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
              "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
              "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
              "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
              "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
              "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
              "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
              "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
              "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
              "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
              "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
              "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
              "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
              "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
              "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
              "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
              "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
              "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
              "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
              "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
              "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
              "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
              "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
              "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
              "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
              "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
              "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
              "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
              "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
              "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
              "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
              "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
              "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
              "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
              "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
              "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
              "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
              "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
              "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
              "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
              "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
              "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
              "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
              "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
              "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
              "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
              "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
              "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
              "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
              "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
              "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
              "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
              "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
              "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
              "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
              "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
              "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
              "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
              "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
              "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
              "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
              "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
              "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
              "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
              "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
              "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
              "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
              "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
              "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
              "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
              "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
              "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
              "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
              "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
              "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
              "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
              "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
              "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
              "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
              "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
              "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
              "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
              "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
              "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
              "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
              "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
              "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
              "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
              "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
              "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
              "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
              "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
              "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
              "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
              "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
              "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
              "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
              "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
              "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
              "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
              "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
              "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
              "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
              "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
              "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
              "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
              "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
              "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
              "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
              "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
              "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
              "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
              "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
              "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
              "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
              "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
              "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
              "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
              "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
              "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
              "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
              "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
              "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
              "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
              "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
              "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
              "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
              "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
              "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
              "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
              "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
          ]
        }
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curves.js
  var require_curves = __commonJS({
    "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
      "use strict";
      var curves = exports;
      var hash = require_hash();
      var curve = require_curve();
      var utils = require_utils3();
      var assert = utils.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve.short(options);
        else if (options.type === "edwards")
          this.curve = new curve.edwards(options);
        else
          this.curve = new curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert(this.g.validate(), "Invalid curve");
        assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve2 = new PresetCurve(options);
            Object.defineProperty(curves, name, {
              configurable: true,
              enumerable: true,
              value: curve2
            });
            return curve2;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: hash.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: hash.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: hash.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: hash.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: hash.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = require_secp256k1();
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre
        ]
      });
    }
  });

  // node_modules/hmac-drbg/lib/hmac-drbg.js
  var require_hmac_drbg = __commonJS({
    "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
      "use strict";
      var hash = require_hash();
      var utils = require_utils2();
      var assert = require_minimalistic_assert();
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils.toArray(options.pers, options.persEnc || "hex");
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._init(entropy, nonce, pers);
      }
      module.exports = HmacDRBG;
      HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
          this.K[i] = 0;
          this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac() {
        return new hash.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        if (typeof entropyEnc !== "string") {
          addEnc = add;
          add = entropyEnc;
          entropyEnc = null;
        }
        entropy = utils.toArray(entropy, entropyEnc);
        add = utils.toArray(add, addEnc);
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._update(entropy.concat(add || []));
        this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string") {
          addEnc = add;
          add = enc;
          enc = null;
        }
        if (add) {
          add = utils.toArray(add, addEnc || "hex");
          this._update(add);
        }
        var temp = [];
        while (temp.length < len) {
          this.V = this._hmac().update(this.V).digest();
          temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add);
        this._reseed++;
        return utils.encode(res, enc);
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/key.js
  var require_key = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var utils = require_utils3();
      var assert = utils.assert;
      function KeyPair(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      module.exports = KeyPair;
      KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(ec, {
          pub,
          pubEnc: enc
        });
      };
      KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair)
          return priv;
        return new KeyPair(ec, {
          priv,
          privEnc: enc
        });
      };
      KeyPair.prototype.validate = function validate2() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return { result: false, reason: "Invalid public key" };
        if (!pub.validate())
          return { result: false, reason: "Public key is not a point" };
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return { result: false, reason: "Public key * N != O" };
        return { result: true, reason: null };
      };
      KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
          enc = compact;
          compact = null;
        }
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact);
      };
      KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
          if (this.ec.curve.type === "mont") {
            assert(key.x, "Need x coordinate");
          } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
            assert(key.x && key.y, "Need both x and y coordinate");
          }
          this.pub = this.ec.curve.point(key.x, key.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
      };
      KeyPair.prototype.derive = function derive(pub) {
        if (!pub.validate()) {
          assert(pub.validate(), "public point not validated");
        }
        return pub.mul(this.priv).getX();
      };
      KeyPair.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair.prototype.verify = function verify(msg, signature) {
        return this.ec.verify(msg, signature, this);
      };
      KeyPair.prototype.inspect = function inspect() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/signature.js
  var require_signature = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var utils = require_utils3();
      var assert = utils.assert;
      function Signature(options, enc) {
        if (options instanceof Signature)
          return options;
        if (this._importDER(options, enc))
          return;
        assert(options.r && options.s, "Signature without r or s");
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
        if (options.recoveryParam === void 0)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      module.exports = Signature;
      function Position() {
        this.place = 0;
      }
      function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
          return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
          return false;
        }
        var val = 0;
        for (var i = 0, off = p.place; i < octetLen; i++, off++) {
          val <<= 8;
          val |= buf[off];
          val >>>= 0;
        }
        if (val <= 127) {
          return false;
        }
        p.place = off;
        return val;
      }
      function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
          i++;
        }
        if (i === 0) {
          return buf;
        }
        return buf.slice(i);
      }
      Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p = new Position();
        if (data[p.place++] !== 48) {
          return false;
        }
        var len = getLength(data, p);
        if (len === false) {
          return false;
        }
        if (len + p.place !== data.length) {
          return false;
        }
        if (data[p.place++] !== 2) {
          return false;
        }
        var rlen = getLength(data, p);
        if (rlen === false) {
          return false;
        }
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
          return false;
        }
        var slen = getLength(data, p);
        if (slen === false) {
          return false;
        }
        if (data.length !== slen + p.place) {
          return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0) {
          if (r[1] & 128) {
            r = r.slice(1);
          } else {
            return false;
          }
        }
        if (s[0] === 0) {
          if (s[1] & 128) {
            s = s.slice(1);
          } else {
            return false;
          }
        }
        this.r = new BN(r);
        this.s = new BN(s);
        this.recoveryParam = null;
        return true;
      };
      function constructLength(arr, len) {
        if (len < 128) {
          arr.push(len);
          return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
          arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
      }
      Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
          s = s.slice(1);
        }
        var arr = [2];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [48];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils.encode(res, enc);
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/index.js
  var require_ec = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var HmacDRBG = require_hmac_drbg();
      var utils = require_utils3();
      var curves = require_curves();
      var rand = require_brorand();
      var assert = utils.assert;
      var KeyPair = require_key();
      var Signature = require_signature();
      function EC(options) {
        if (!(this instanceof EC))
          return new EC(options);
        if (typeof options === "string") {
          assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
          options = curves[options];
        }
        if (options instanceof curves.PresetCurve)
          options = { curve: options };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
      }
      module.exports = EC;
      EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
      };
      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
      };
      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
      };
      EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({
          hash: this.hash,
          pers: options.pers,
          persEnc: options.persEnc || "utf8",
          entropy: options.entropy || rand(this.hash.hmacStrength),
          entropyEnc: options.entropy && options.entropyEnc || "utf8",
          nonce: this.n.toArray()
        });
        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new BN(2));
        for (; ; ) {
          var priv = new BN(drbg.generate(bytes));
          if (priv.cmp(ns2) > 0)
            continue;
          priv.iaddn(1);
          return this.keyFromPrivate(priv);
        }
      };
      EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC.prototype.sign = function sign(msg, key, enc, options) {
        if (typeof enc === "object") {
          options = enc;
          enc = null;
        }
        if (!options)
          options = {};
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(new BN(msg, 16));
        var bytes = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes);
        var nonce = msg.toArray("be", bytes);
        var drbg = new HmacDRBG({
          hash: this.hash,
          entropy: bkey,
          nonce,
          pers: options.pers,
          persEnc: options.persEnc || "utf8"
        });
        var ns1 = this.n.sub(new BN(1));
        for (var iter = 0; ; iter++) {
          var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
          k = this._truncateToN(k, true);
          if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX();
          var r = kpX.umod(this.n);
          if (r.cmpn(0) === 0)
            continue;
          var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
          s = s.umod(this.n);
          if (s.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
          if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
          }
          return new Signature({ r, s, recoveryParam });
        }
      };
      EC.prototype.verify = function verify(msg, signature, key, enc) {
        msg = this._truncateToN(new BN(msg, 16));
        key = this.keyFromPublic(key, enc);
        signature = new Signature(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
          return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
          return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        var p;
        if (!this.curve._maxwellTrick) {
          p = this.g.mulAdd(u1, key.getPublic(), u2);
          if (p.isInfinity())
            return false;
          return p.getX().umod(this.n).cmp(r) === 0;
        }
        p = this.g.jmulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.eqXToP(r);
      };
      EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature(signature, enc);
        var n = this.n;
        var e = new BN(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
        else
          r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
      };
      EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature(signature, enc);
        if (signature.recoveryParam !== null)
          return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature, i);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q))
            return i;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/key.js
  var require_key2 = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
      "use strict";
      var utils = require_utils3();
      var assert = utils.assert;
      var parseBytes = utils.parseBytes;
      var cachedProperty = utils.cachedProperty;
      function KeyPair(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params.secret);
        if (eddsa.isPoint(params.pub))
          this._pub = params.pub;
        else
          this._pubBytes = parseBytes(params.pub);
      }
      KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(eddsa, { pub });
      };
      KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair)
          return secret;
        return new KeyPair(eddsa, { secret });
      };
      KeyPair.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa = this.eddsa;
        var hash = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
      });
      cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair, "hash", function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair.prototype.sign = function sign(message) {
        assert(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
      };
      KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair.prototype.getSecret = function getSecret(enc) {
        assert(this._secret, "KeyPair is public only");
        return utils.encode(this.secret(), enc);
      };
      KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
      };
      module.exports = KeyPair;
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/signature.js
  var require_signature2 = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var utils = require_utils3();
      var assert = utils.assert;
      var cachedProperty = utils.cachedProperty;
      var parseBytes = utils.parseBytes;
      function Signature(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig)) {
          sig = {
            R: sig.slice(0, eddsa.encodingLength),
            S: sig.slice(eddsa.encodingLength)
          };
        }
        assert(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature.prototype.toHex = function toHex() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
      };
      module.exports = Signature;
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/index.js
  var require_eddsa = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
      "use strict";
      var hash = require_hash();
      var curves = require_curves();
      var utils = require_utils3();
      var assert = utils.assert;
      var parseBytes = utils.parseBytes;
      var KeyPair = require_key2();
      var Signature = require_signature2();
      function EDDSA(curve) {
        assert(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA))
          return new EDDSA(curve);
        curve = curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash.sha512;
      }
      module.exports = EDDSA;
      EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({ R, S, Rencoded });
      };
      EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        var key = this.keyFromPublic(pub);
        var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash2 = this.hash();
        for (var i = 0; i < arguments.length; i++)
          hash2.update(arguments[i]);
        return utils.intFromLE(hash2.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature)
          return sig;
        return new Signature(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils.parseBytes(bytes);
        var lastIx = bytes.length - 1;
        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
        var xIsOdd = (bytes[lastIx] & 128) !== 0;
        var y = utils.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils.intFromLE(bytes);
      };
      EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic.js
  var require_elliptic = __commonJS({
    "node_modules/elliptic/lib/elliptic.js"(exports) {
      "use strict";
      var elliptic = exports;
      elliptic.version = require_package().version;
      elliptic.utils = require_utils3();
      elliptic.rand = require_brorand();
      elliptic.curve = require_curve();
      elliptic.curves = require_curves();
      elliptic.ec = require_ec();
      elliptic.eddsa = require_eddsa();
    }
  });

  // node_modules/eosjs/dist/PublicKey.js
  var require_PublicKey = __commonJS({
    "node_modules/eosjs/dist/PublicKey.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PublicKey = void 0;
      var eosjs_numeric_1 = require_eosjs_numeric2();
      var eosjs_key_conversions_1 = require_eosjs_key_conversions();
      var PublicKey = function() {
        function PublicKey2(key, ec) {
          this.key = key;
          this.ec = ec;
        }
        PublicKey2.fromString = function(publicKeyStr, ec) {
          var key = eosjs_numeric_1.stringToPublicKey(publicKeyStr);
          if (!ec) {
            ec = eosjs_key_conversions_1.constructElliptic(key.type);
          }
          return new PublicKey2(key, ec);
        };
        PublicKey2.fromElliptic = function(publicKey, keyType, ec) {
          var x = publicKey.getPublic().getX().toArray("be", 32);
          var y = publicKey.getPublic().getY().toArray("be", 32);
          if (!ec) {
            ec = eosjs_key_conversions_1.constructElliptic(keyType);
          }
          return new PublicKey2({
            type: keyType,
            data: new Uint8Array([y[31] & 1 ? 3 : 2].concat(x))
          }, ec);
        };
        PublicKey2.prototype.toString = function() {
          return eosjs_numeric_1.publicKeyToString(this.key);
        };
        PublicKey2.prototype.toLegacyString = function() {
          return eosjs_numeric_1.publicKeyToLegacyString(this.key);
        };
        PublicKey2.prototype.toElliptic = function() {
          return this.ec.keyPair({
            pub: Buffer.from(this.key.data)
          });
        };
        PublicKey2.prototype.getType = function() {
          return this.key.type;
        };
        PublicKey2.prototype.isValid = function() {
          try {
            var ellipticPublicKey = this.toElliptic();
            var validationObj = ellipticPublicKey.validate();
            return validationObj.result;
          } catch (_a) {
            return false;
          }
        };
        return PublicKey2;
      }();
      exports.PublicKey = PublicKey;
    }
  });

  // node_modules/eosjs/dist/PrivateKey.js
  var require_PrivateKey = __commonJS({
    "node_modules/eosjs/dist/PrivateKey.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PrivateKey = void 0;
      var eosjs_numeric_1 = require_eosjs_numeric2();
      var eosjs_key_conversions_1 = require_eosjs_key_conversions();
      var PrivateKey = function() {
        function PrivateKey2(key, ec) {
          this.key = key;
          this.ec = ec;
        }
        PrivateKey2.fromElliptic = function(privKey, keyType, ec) {
          if (!ec) {
            ec = eosjs_key_conversions_1.constructElliptic(keyType);
          }
          return new PrivateKey2({
            type: keyType,
            data: privKey.getPrivate().toArrayLike(Buffer, "be", 32)
          }, ec);
        };
        PrivateKey2.fromString = function(keyString, ec) {
          var privateKey = eosjs_numeric_1.stringToPrivateKey(keyString);
          if (!ec) {
            ec = eosjs_key_conversions_1.constructElliptic(privateKey.type);
          }
          return new PrivateKey2(privateKey, ec);
        };
        PrivateKey2.prototype.toElliptic = function() {
          return this.ec.keyFromPrivate(this.key.data);
        };
        PrivateKey2.prototype.toLegacyString = function() {
          return eosjs_numeric_1.privateKeyToLegacyString(this.key);
        };
        PrivateKey2.prototype.toString = function() {
          return eosjs_numeric_1.privateKeyToString(this.key);
        };
        PrivateKey2.prototype.getType = function() {
          return this.key.type;
        };
        PrivateKey2.prototype.getPublicKey = function() {
          var ellipticPrivateKey = this.toElliptic();
          return eosjs_key_conversions_1.PublicKey.fromElliptic(ellipticPrivateKey, this.getType(), this.ec);
        };
        PrivateKey2.prototype.sign = function(data, shouldHash, encoding) {
          var _this = this;
          if (shouldHash === void 0) {
            shouldHash = true;
          }
          if (encoding === void 0) {
            encoding = "utf8";
          }
          if (shouldHash) {
            if (typeof data === "string") {
              data = Buffer.from(data, encoding);
            }
            data = this.ec.hash().update(data).digest();
          }
          var tries = 0;
          var signature;
          var isCanonical = function(sigData) {
            return !(sigData[1] & 128) && !(sigData[1] === 0 && !(sigData[2] & 128)) && !(sigData[33] & 128) && !(sigData[33] === 0 && !(sigData[34] & 128));
          };
          var constructSignature = function(options) {
            var ellipticPrivateKey = _this.toElliptic();
            var ellipticSignature = ellipticPrivateKey.sign(data, options);
            return eosjs_key_conversions_1.Signature.fromElliptic(ellipticSignature, _this.getType(), _this.ec);
          };
          if (this.key.type === eosjs_numeric_1.KeyType.k1) {
            do {
              signature = constructSignature({ canonical: true, pers: [++tries] });
            } while (!isCanonical(signature.toBinary()));
          } else {
            signature = constructSignature({ canonical: true });
          }
          return signature;
        };
        PrivateKey2.prototype.isValid = function() {
          try {
            var ellipticPrivateKey = this.toElliptic();
            var validationObj = ellipticPrivateKey.validate();
            return validationObj.result;
          } catch (_a) {
            return false;
          }
        };
        return PrivateKey2;
      }();
      exports.PrivateKey = PrivateKey;
    }
  });

  // node_modules/eosjs/node_modules/bn.js/lib/bn.js
  var require_bn2 = __commonJS({
    "node_modules/eosjs/node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN;
        } else {
          exports2.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = require_buffer().Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert(false, "Invalid character in " + string);
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN.prototype.inspect = inspect;
          }
        } else {
          BN.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(a.red && a.red === b.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/eosjs/dist/Signature.js
  var require_Signature = __commonJS({
    "node_modules/eosjs/dist/Signature.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signature = void 0;
      var BN = require_bn2();
      var eosjs_numeric_1 = require_eosjs_numeric2();
      var eosjs_key_conversions_1 = require_eosjs_key_conversions();
      var Signature = function() {
        function Signature2(signature, ec) {
          this.signature = signature;
          this.ec = ec;
        }
        Signature2.fromString = function(sig, ec) {
          var signature = eosjs_numeric_1.stringToSignature(sig);
          if (!ec) {
            ec = eosjs_key_conversions_1.constructElliptic(signature.type);
          }
          return new Signature2(signature, ec);
        };
        Signature2.fromElliptic = function(ellipticSig, keyType, ec) {
          var r = ellipticSig.r.toArray("be", 32);
          var s = ellipticSig.s.toArray("be", 32);
          var eosioRecoveryParam;
          if (keyType === eosjs_numeric_1.KeyType.k1 || keyType === eosjs_numeric_1.KeyType.r1) {
            eosioRecoveryParam = ellipticSig.recoveryParam + 27;
            if (ellipticSig.recoveryParam <= 3) {
              eosioRecoveryParam += 4;
            }
          } else if (keyType === eosjs_numeric_1.KeyType.wa) {
            eosioRecoveryParam = ellipticSig.recoveryParam;
          }
          var sigData = new Uint8Array([eosioRecoveryParam].concat(r, s));
          if (!ec) {
            ec = eosjs_key_conversions_1.constructElliptic(keyType);
          }
          return new Signature2({
            type: keyType,
            data: sigData
          }, ec);
        };
        Signature2.prototype.toElliptic = function() {
          var lengthOfR = 32;
          var lengthOfS = 32;
          var r = new BN(this.signature.data.slice(1, lengthOfR + 1));
          var s = new BN(this.signature.data.slice(lengthOfR + 1, lengthOfR + lengthOfS + 1));
          var ellipticRecoveryBitField;
          if (this.signature.type === eosjs_numeric_1.KeyType.k1 || this.signature.type === eosjs_numeric_1.KeyType.r1) {
            ellipticRecoveryBitField = this.signature.data[0] - 27;
            if (ellipticRecoveryBitField > 3) {
              ellipticRecoveryBitField -= 4;
            }
          } else if (this.signature.type === eosjs_numeric_1.KeyType.wa) {
            ellipticRecoveryBitField = this.signature.data[0];
          }
          var recoveryParam = ellipticRecoveryBitField & 3;
          return { r, s, recoveryParam };
        };
        Signature2.prototype.toString = function() {
          return eosjs_numeric_1.signatureToString(this.signature);
        };
        Signature2.prototype.toBinary = function() {
          return this.signature.data;
        };
        Signature2.prototype.getType = function() {
          return this.signature.type;
        };
        Signature2.prototype.verify = function(data, publicKey, shouldHash, encoding) {
          if (shouldHash === void 0) {
            shouldHash = true;
          }
          if (encoding === void 0) {
            encoding = "utf8";
          }
          if (shouldHash) {
            if (typeof data === "string") {
              data = Buffer.from(data, encoding);
            }
            data = this.ec.hash().update(data).digest();
          }
          var ellipticSignature = this.toElliptic();
          var ellipticPublicKey = publicKey.toElliptic();
          return this.ec.verify(data, ellipticSignature, ellipticPublicKey, encoding);
        };
        Signature2.prototype.recover = function(data, shouldHash, encoding) {
          if (shouldHash === void 0) {
            shouldHash = true;
          }
          if (encoding === void 0) {
            encoding = "utf8";
          }
          if (shouldHash) {
            if (typeof data === "string") {
              data = Buffer.from(data, encoding);
            }
            data = this.ec.hash().update(data).digest();
          }
          var ellipticSignature = this.toElliptic();
          var recoveredPublicKey = this.ec.recoverPubKey(data, ellipticSignature, ellipticSignature.recoveryParam, encoding);
          var ellipticKPub = this.ec.keyFromPublic(recoveredPublicKey);
          return eosjs_key_conversions_1.PublicKey.fromElliptic(ellipticKPub, this.getType(), this.ec);
        };
        return Signature2;
      }();
      exports.Signature = Signature;
    }
  });

  // node_modules/eosjs/dist/eosjs-key-conversions.js
  var require_eosjs_key_conversions = __commonJS({
    "node_modules/eosjs/dist/eosjs-key-conversions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha256 = exports.generateKeyPair = exports.constructElliptic = exports.Signature = exports.PublicKey = exports.PrivateKey = void 0;
      var elliptic_1 = require_elliptic();
      var hash = require_hash();
      var eosjs_numeric_1 = require_eosjs_numeric2();
      var PublicKey_1 = require_PublicKey();
      var PrivateKey_1 = require_PrivateKey();
      var PrivateKey_2 = require_PrivateKey();
      Object.defineProperty(exports, "PrivateKey", { enumerable: true, get: function() {
        return PrivateKey_2.PrivateKey;
      } });
      var PublicKey_2 = require_PublicKey();
      Object.defineProperty(exports, "PublicKey", { enumerable: true, get: function() {
        return PublicKey_2.PublicKey;
      } });
      var Signature_1 = require_Signature();
      Object.defineProperty(exports, "Signature", { enumerable: true, get: function() {
        return Signature_1.Signature;
      } });
      var constructElliptic = function(type) {
        if (type === eosjs_numeric_1.KeyType.k1) {
          return new elliptic_1.ec("secp256k1");
        }
        return new elliptic_1.ec("p256");
      };
      exports.constructElliptic = constructElliptic;
      var generateKeyPair = function(type, options) {
        if (options === void 0) {
          options = {};
        }
        if (!options.secureEnv) {
          throw new Error("Key generation is completely INSECURE in production environments in the browser. If you are absolutely certain this does NOT describe your environment, set `secureEnv` in your options to `true`.  If this does describe your environment and you set `secureEnv` to `true`, YOU DO SO AT YOUR OWN RISK AND THE RISK OF YOUR USERS.");
        }
        var ec;
        if (type === eosjs_numeric_1.KeyType.k1) {
          ec = new elliptic_1.ec("secp256k1");
        } else {
          ec = new elliptic_1.ec("p256");
        }
        var ellipticKeyPair = ec.genKeyPair(options.ecOptions);
        var publicKey = PublicKey_1.PublicKey.fromElliptic(ellipticKeyPair, type, ec);
        var privateKey = PrivateKey_1.PrivateKey.fromElliptic(ellipticKeyPair, type, ec);
        return { publicKey, privateKey };
      };
      exports.generateKeyPair = generateKeyPair;
      var sha256 = function(data) {
        return hash.sha256().update(data).digest();
      };
      exports.sha256 = sha256;
    }
  });

  // node_modules/eosjs/dist/eosjs-jssig.js
  var require_eosjs_jssig = __commonJS({
    "node_modules/eosjs/dist/eosjs-jssig.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f2, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f2 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __values = exports && exports.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JsSignatureProvider = exports.digestFromSerializedData = exports.Signature = exports.PublicKey = exports.PrivateKey = void 0;
      var elliptic_1 = require_elliptic();
      var eosjs_key_conversions_1 = require_eosjs_key_conversions();
      Object.defineProperty(exports, "PrivateKey", { enumerable: true, get: function() {
        return eosjs_key_conversions_1.PrivateKey;
      } });
      Object.defineProperty(exports, "PublicKey", { enumerable: true, get: function() {
        return eosjs_key_conversions_1.PublicKey;
      } });
      Object.defineProperty(exports, "Signature", { enumerable: true, get: function() {
        return eosjs_key_conversions_1.Signature;
      } });
      var eosjs_numeric_1 = require_eosjs_numeric2();
      var defaultEc = new elliptic_1.ec("secp256k1");
      var digestFromSerializedData = function(chainId, serializedTransaction, serializedContextFreeData, e) {
        if (e === void 0) {
          e = defaultEc;
        }
        var signBuf = Buffer.concat([
          Buffer.from(chainId, "hex"),
          Buffer.from(serializedTransaction),
          Buffer.from(serializedContextFreeData ? new Uint8Array(e.hash().update(serializedContextFreeData).digest()) : new Uint8Array(32))
        ]);
        return e.hash().update(signBuf).digest();
      };
      exports.digestFromSerializedData = digestFromSerializedData;
      var JsSignatureProvider = function() {
        function JsSignatureProvider2(privateKeys) {
          var e_1, _a;
          this.keys = new Map();
          this.availableKeys = [];
          try {
            for (var privateKeys_1 = __values(privateKeys), privateKeys_1_1 = privateKeys_1.next(); !privateKeys_1_1.done; privateKeys_1_1 = privateKeys_1.next()) {
              var k = privateKeys_1_1.value;
              var priv = eosjs_key_conversions_1.PrivateKey.fromString(k);
              var privElliptic = priv.toElliptic();
              var pubStr = priv.getPublicKey().toString();
              this.keys.set(pubStr, privElliptic);
              this.availableKeys.push(pubStr);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (privateKeys_1_1 && !privateKeys_1_1.done && (_a = privateKeys_1.return))
                _a.call(privateKeys_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
        JsSignatureProvider2.prototype.getAvailableKeys = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.availableKeys];
            });
          });
        };
        JsSignatureProvider2.prototype.sign = function(_a) {
          var chainId = _a.chainId, requiredKeys = _a.requiredKeys, serializedTransaction = _a.serializedTransaction, serializedContextFreeData = _a.serializedContextFreeData;
          return __awaiter(this, void 0, void 0, function() {
            var digest, signatures, requiredKeys_1, requiredKeys_1_1, key, publicKey, ellipticPrivateKey, privateKey, signature;
            var e_2, _b;
            return __generator(this, function(_c) {
              digest = digestFromSerializedData(chainId, serializedTransaction, serializedContextFreeData, defaultEc);
              signatures = [];
              try {
                for (requiredKeys_1 = __values(requiredKeys), requiredKeys_1_1 = requiredKeys_1.next(); !requiredKeys_1_1.done; requiredKeys_1_1 = requiredKeys_1.next()) {
                  key = requiredKeys_1_1.value;
                  publicKey = eosjs_key_conversions_1.PublicKey.fromString(key);
                  ellipticPrivateKey = this.keys.get(eosjs_numeric_1.convertLegacyPublicKey(key));
                  privateKey = eosjs_key_conversions_1.PrivateKey.fromElliptic(ellipticPrivateKey, publicKey.getType());
                  signature = privateKey.sign(digest, false);
                  signatures.push(signature.toString());
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (requiredKeys_1_1 && !requiredKeys_1_1.done && (_b = requiredKeys_1.return))
                    _b.call(requiredKeys_1);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
              return [2, { signatures, serializedTransaction, serializedContextFreeData }];
            });
          });
        };
        return JsSignatureProvider2;
      }();
      exports.JsSignatureProvider = JsSignatureProvider;
    }
  });

  // node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/tslib/tslib.js"(exports, module) {
      var __extends;
      var __assign;
      var __rest;
      var __decorate;
      var __param;
      var __metadata;
      var __awaiter;
      var __generator;
      var __exportStar;
      var __values;
      var __read;
      var __spread;
      var __spreadArrays;
      var __spreadArray;
      var __await;
      var __asyncGenerator;
      var __asyncDelegator;
      var __asyncValues;
      var __makeTemplateObject;
      var __importStar;
      var __importDefault;
      var __classPrivateFieldGet;
      var __classPrivateFieldSet;
      var __createBinding;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f2, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f2)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f2 = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar = function(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding(o, m, p);
        };
        __createBinding = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
          return ar;
        };
        __spreadArrays = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || from);
        };
        __await = function(v) {
          return this instanceof __await ? (this.v = v, this) : new __await(v);
        };
        __asyncGenerator = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f2, v) {
            if (f2(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f2) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f2 ? f2(v) : v;
            } : f2;
          }
        };
        __asyncValues = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        __importDefault = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet = function(receiver, state, kind, f2) {
          if (kind === "a" && !f2)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
        };
        __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f2)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends);
        exporter("__assign", __assign);
        exporter("__rest", __rest);
        exporter("__decorate", __decorate);
        exporter("__param", __param);
        exporter("__metadata", __metadata);
        exporter("__awaiter", __awaiter);
        exporter("__generator", __generator);
        exporter("__exportStar", __exportStar);
        exporter("__createBinding", __createBinding);
        exporter("__values", __values);
        exporter("__read", __read);
        exporter("__spread", __spread);
        exporter("__spreadArrays", __spreadArrays);
        exporter("__spreadArray", __spreadArray);
        exporter("__await", __await);
        exporter("__asyncGenerator", __asyncGenerator);
        exporter("__asyncDelegator", __asyncDelegator);
        exporter("__asyncValues", __asyncValues);
        exporter("__makeTemplateObject", __makeTemplateObject);
        exporter("__importStar", __importStar);
        exporter("__importDefault", __importDefault);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      });
    }
  });

  // node_modules/@greymass/eosio/lib/eosio-core.js
  var require_eosio_core = __commonJS({
    "node_modules/@greymass/eosio/lib/eosio-core.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var rand = require_brorand();
      var hash_js = require_hash();
      var BN = require_bn();
      var elliptic = require_elliptic();
      var tslib = require_tslib();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var rand__default = /* @__PURE__ */ _interopDefaultLegacy(rand);
      var BN__default = /* @__PURE__ */ _interopDefaultLegacy(BN);
      function arrayEquals(a, b) {
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        for (let i = 0; i < len; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      function arrayEquatableEquals(a, b) {
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        for (let i = 0; i < len; i++) {
          if (!a[i].equals(b[i])) {
            return false;
          }
        }
        return true;
      }
      var hexLookup = {};
      function buildHexLookup() {
        hexLookup.enc = new Array(255);
        hexLookup.dec = {};
        for (let i = 0; i <= 255; ++i) {
          const b = i.toString(16).padStart(2, "0");
          hexLookup.enc[i] = b;
          hexLookup.dec[b] = i;
        }
      }
      function arrayToHex(array) {
        if (!hexLookup.enc) {
          buildHexLookup();
        }
        const len = array.length;
        const rv = new Array(len);
        for (let i = 0; i < len; ++i) {
          rv[i] = hexLookup.enc[array[i]];
        }
        return rv.join("");
      }
      function hexToArray(hex) {
        if (!hexLookup.dec) {
          buildHexLookup();
        }
        if (typeof hex !== "string") {
          throw new Error("Expected string containing hex digits");
        }
        if (hex.length % 2) {
          throw new Error("Odd number of hex digits");
        }
        hex = hex.toLowerCase();
        const len = hex.length / 2;
        const result = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          const b = hexLookup.dec[hex[i * 2] + hex[i * 2 + 1]];
          if (b === void 0) {
            throw new Error("Expected hex string");
          }
          result[i] = b;
        }
        return result;
      }
      function secureRandom(length) {
        return rand__default["default"](length);
      }
      var didWarn = false;
      function isInstanceOf(object, someClass) {
        if (object instanceof someClass) {
          return true;
        }
        if (object == null || typeof object !== "object") {
          return false;
        }
        const className = someClass["__className"] || someClass["abiName"];
        if (!className) {
          return false;
        }
        let instanceClass = object.constructor;
        let isAlienInstance = false;
        while (instanceClass && !isAlienInstance) {
          const instanceClassName = instanceClass["__className"] || instanceClass["abiName"];
          if (!instanceClassName) {
            break;
          }
          isAlienInstance = className == instanceClassName;
          instanceClass = Object.getPrototypeOf(instanceClass);
        }
        if (isAlienInstance && !didWarn) {
          console.warn(`Detected alien instance of ${className}, this usually means more than one version of @greymass/eosio has been included in your bundle.`);
          didWarn = true;
        }
        return isAlienInstance;
      }
      var Bytes = class {
        constructor(array = new Uint8Array()) {
          this.array = array;
        }
        static from(value, encoding) {
          if (isInstanceOf(value, this)) {
            return value;
          }
          if (typeof value === "string") {
            return this.fromString(value, encoding);
          }
          if (isInstanceOf(value, Uint8Array)) {
            return new this(value);
          }
          return new this(new Uint8Array(value));
        }
        static fromString(value, encoding = "hex") {
          if (encoding === "hex") {
            const array = hexToArray(value);
            return new this(array);
          } else if (encoding == "utf8") {
            const encoder = new TextEncoder();
            return new this(encoder.encode(value));
          } else {
            throw new Error(`Unknown encoding: ${encoding}`);
          }
        }
        static fromABI(decoder) {
          const len = decoder.readVaruint32();
          return new this(decoder.readArray(len));
        }
        static equal(a, b) {
          return this.from(a).equals(this.from(b));
        }
        static random(length) {
          return new this(secureRandom(length));
        }
        static isBytes(value) {
          if (isInstanceOf(value, Bytes) || isInstanceOf(value, Uint8Array)) {
            return true;
          }
          if (Array.isArray(value) && value.every((v) => typeof v === "number")) {
            return true;
          }
          if (typeof value === "string" && (/[\da-f]/i.test(value) || value === "")) {
            return true;
          }
          return false;
        }
        get hexString() {
          return arrayToHex(this.array);
        }
        get utf8String() {
          return new TextDecoder().decode(this.array);
        }
        appending(other) {
          other = Bytes.from(other);
          const newSize = this.array.byteLength + other.array.byteLength;
          const buffer = new ArrayBuffer(newSize);
          const array = new Uint8Array(buffer);
          array.set(this.array);
          array.set(other.array, this.array.byteLength);
          return new Bytes(array);
        }
        droppingFirst(n = 1) {
          return new Bytes(this.array.subarray(n));
        }
        copy() {
          const buffer = new ArrayBuffer(this.array.byteLength);
          const array = new Uint8Array(buffer);
          array.set(this.array);
          return new Bytes(array);
        }
        equals(other) {
          return arrayEquals(this.array, Bytes.from(other).array);
        }
        toString(encoding = "hex") {
          if (encoding === "hex") {
            return this.hexString;
          } else if (encoding === "utf8") {
            return this.utf8String;
          } else {
            throw new Error(`Unknown encoding: ${encoding}`);
          }
        }
        toABI(encoder) {
          encoder.writeVaruint32(this.array.byteLength);
          encoder.writeArray(this.array);
        }
        toJSON() {
          return this.hexString;
        }
      };
      Bytes.abiName = "bytes";
      var Checksum = class {
        constructor(array) {
          const byteSize = this.constructor.byteSize;
          if (array.byteLength !== byteSize) {
            throw new Error(`Checksum size mismatch, expected ${byteSize} bytes got ${array.byteLength}`);
          }
          this.array = array;
        }
        static from(value) {
          if (isInstanceOf(value, this)) {
            return value;
          }
          if (isInstanceOf(value, Checksum)) {
            return new this(value.array);
          }
          return new this(Bytes.from(value).array);
        }
        static fromABI(decoder) {
          return new this(decoder.readArray(this.byteSize));
        }
        equals(other) {
          const self2 = this.constructor;
          try {
            return arrayEquals(this.array, self2.from(other).array);
          } catch (_a) {
            return false;
          }
        }
        get hexString() {
          return arrayToHex(this.array);
        }
        toABI(encoder) {
          encoder.writeArray(this.array);
        }
        toString() {
          return this.hexString;
        }
        toJSON() {
          return this.toString();
        }
      };
      Checksum.abiName = "__checksum";
      var Checksum256 = class extends Checksum {
        static from(value) {
          return super.from(value);
        }
        static hash(data) {
          const digest = new Uint8Array(hash_js.sha256().update(Bytes.from(data).array).digest());
          return new Checksum256(digest);
        }
      };
      Checksum256.abiName = "checksum256";
      Checksum256.byteSize = 32;
      var Checksum512 = class extends Checksum {
        static from(value) {
          return super.from(value);
        }
        static hash(data) {
          const digest = new Uint8Array(hash_js.sha512().update(Bytes.from(data).array).digest());
          return new Checksum512(digest);
        }
      };
      Checksum512.abiName = "checksum512";
      Checksum512.byteSize = 64;
      var Checksum160 = class extends Checksum {
        static from(value) {
          return super.from(value);
        }
        static hash(data) {
          const digest = new Uint8Array(hash_js.ripemd160().update(Bytes.from(data).array).digest());
          return new Checksum160(digest);
        }
      };
      Checksum160.abiName = "checksum160";
      Checksum160.byteSize = 20;
      exports.CurveType = void 0;
      (function(CurveType) {
        CurveType["K1"] = "K1";
        CurveType["R1"] = "R1";
        CurveType["WA"] = "WA";
      })(exports.CurveType || (exports.CurveType = {}));
      (function(CurveType) {
        function indexFor(value) {
          switch (value) {
            case CurveType.K1:
              return 0;
            case CurveType.R1:
              return 1;
            case CurveType.WA:
              return 2;
            default:
              throw new Error(`Unknown curve type: ${value}`);
          }
        }
        CurveType.indexFor = indexFor;
        function from(value) {
          let index;
          if (typeof value !== "number") {
            index = CurveType.indexFor(value);
          } else {
            index = value;
          }
          switch (index) {
            case 0:
              return CurveType.K1;
            case 1:
              return CurveType.R1;
            case 2:
              return CurveType.WA;
            default:
              throw new Error("Unknown curve type");
          }
        }
        CurveType.from = from;
      })(exports.CurveType || (exports.CurveType = {}));
      var Int = class {
        constructor(value) {
          const self2 = this.constructor;
          if (self2.isSigned === void 0 || self2.byteWidth === void 0) {
            throw new Error("Cannot instantiate abstract class Int");
          }
          if (value.gt(self2.max)) {
            throw new Error(`Number ${value} overflows ${self2.abiName}`);
          }
          if (value.lt(self2.min)) {
            throw new Error(`Number ${value} underflows ${self2.abiName}`);
          }
          this.value = value;
        }
        static get max() {
          return new BN__default["default"](2).pow(new BN__default["default"](this.byteWidth * 8 - (this.isSigned ? 1 : 0))).isubn(1);
        }
        static get min() {
          return this.isSigned ? this.max.ineg().isubn(1) : new BN__default["default"](0);
        }
        static add(lhs, rhs, overflow = "truncate") {
          return Int.operator(lhs, rhs, overflow, (a, b) => a.add(b));
        }
        static sub(lhs, rhs, overflow) {
          return Int.operator(lhs, rhs, overflow, (a, b) => a.sub(b));
        }
        static mul(lhs, rhs, overflow) {
          return Int.operator(lhs, rhs, overflow, (a, b) => a.mul(b));
        }
        static div(lhs, rhs, overflow) {
          return Int.operator(lhs, rhs, overflow, (a, b) => {
            if (b.isZero()) {
              throw new Error("Division by zero");
            }
            return a.div(b);
          });
        }
        static divRound(lhs, rhs, overflow) {
          return Int.operator(lhs, rhs, overflow, (a, b) => {
            if (b.isZero()) {
              throw new Error("Division by zero");
            }
            return a.divRound(b);
          });
        }
        static divCeil(lhs, rhs, overflow) {
          return Int.operator(lhs, rhs, overflow, (a, b) => {
            if (b.isZero()) {
              throw new Error("Division by zero");
            }
            const dm = a.divmod(b);
            if (dm.mod.isZero())
              return dm.div;
            return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
          });
        }
        static operator(lhs, rhs, overflow = "truncate", fn) {
          const { a, b } = convert(lhs, rhs);
          const type = a.constructor;
          const result = fn(a.value, b.value);
          return type.from(result, overflow);
        }
        static from(value, overflow) {
          if (isInstanceOf(value, this)) {
            return value;
          }
          let fromType = this;
          let bn;
          if (isInstanceOf(value, Int)) {
            fromType = value.constructor;
            bn = value.value.clone();
          } else if (value instanceof Uint8Array) {
            bn = new BN__default["default"](value, void 0, "le");
            if (fromType.isSigned) {
              bn = bn.fromTwos(fromType.byteWidth * 8);
            }
          } else {
            if (typeof value === "string" && !/[0-9]+/.test(value) || typeof value === "number" && !Number.isFinite(value)) {
              throw new Error("Invalid number");
            }
            bn = BN__default["default"].isBN(value) ? value.clone() : new BN__default["default"](value, 10);
            if (bn.isNeg() && !fromType.isSigned) {
              fromType = { byteWidth: fromType.byteWidth, isSigned: true };
            }
          }
          switch (overflow) {
            case "clamp":
              bn = clamp(bn, this.min, this.max);
              break;
            case "truncate":
              bn = truncate(bn, fromType, this);
              break;
          }
          return new this(bn);
        }
        static fromABI(decoder) {
          return this.from(decoder.readArray(this.byteWidth));
        }
        static random() {
          return this.from(secureRandom(this.byteWidth));
        }
        cast(type, overflow = "truncate") {
          if (this.constructor === type) {
            return this;
          }
          return type.from(this, overflow);
        }
        get byteArray() {
          const self2 = this.constructor;
          const value = self2.isSigned ? this.value.toTwos(self2.byteWidth * 8) : this.value;
          return value.toArrayLike(Uint8Array, "le", self2.byteWidth);
        }
        equals(other, strict = false) {
          const self2 = this.constructor;
          if (strict === true && isInstanceOf(other, Int)) {
            const otherType = other.constructor;
            if (self2.byteWidth !== otherType.byteWidth || self2.isSigned !== otherType.isSigned) {
              return false;
            }
          }
          try {
            return this.value.eq(self2.from(other).value);
          } catch (_a) {
            return false;
          }
        }
        add(num) {
          this.value = this.operator(num, Int.add).value;
        }
        adding(num) {
          return this.operator(num, Int.add);
        }
        subtract(num) {
          this.value = this.operator(num, Int.sub).value;
        }
        subtracting(num) {
          return this.operator(num, Int.sub);
        }
        multiply(by) {
          this.value = this.operator(by, Int.mul).value;
        }
        multiplying(by) {
          return this.operator(by, Int.mul);
        }
        divide(by, behavior) {
          this.value = this.dividing(by, behavior).value;
        }
        dividing(by, behavior) {
          let op = Int.div;
          switch (behavior) {
            case "ceil":
              op = Int.divCeil;
              break;
            case "round":
              op = Int.divRound;
              break;
          }
          return this.operator(by, op);
        }
        operator(other, fn) {
          let rhs;
          if (isInstanceOf(other, Int)) {
            rhs = other;
          } else {
            rhs = Int64.from(other, "truncate");
          }
          return fn(this, rhs).cast(this.constructor);
        }
        toNumber() {
          return this.value.toNumber();
        }
        toString() {
          return this.value.toString();
        }
        [Symbol.toPrimitive](type) {
          if (type === "number") {
            return this.toNumber();
          } else {
            return this.toString();
          }
        }
        toABI(encoder) {
          encoder.writeArray(this.byteArray);
        }
        toJSON() {
          if (this.value.bitLength() > 32) {
            return this.value.toString();
          } else {
            return this.value.toNumber();
          }
        }
      };
      Int.abiName = "__int";
      var Int8 = class extends Int {
      };
      Int8.abiName = "int8";
      Int8.byteWidth = 1;
      Int8.isSigned = true;
      var Int16 = class extends Int {
      };
      Int16.abiName = "int16";
      Int16.byteWidth = 2;
      Int16.isSigned = true;
      var Int32 = class extends Int {
      };
      Int32.abiName = "int32";
      Int32.byteWidth = 4;
      Int32.isSigned = true;
      var Int64 = class extends Int {
      };
      Int64.abiName = "int64";
      Int64.byteWidth = 8;
      Int64.isSigned = true;
      var Int128 = class extends Int {
      };
      Int128.abiName = "int128";
      Int128.byteWidth = 16;
      Int128.isSigned = true;
      var UInt8 = class extends Int {
      };
      UInt8.abiName = "uint8";
      UInt8.byteWidth = 1;
      UInt8.isSigned = false;
      var UInt16 = class extends Int {
      };
      UInt16.abiName = "uint16";
      UInt16.byteWidth = 2;
      UInt16.isSigned = false;
      var UInt32 = class extends Int {
      };
      UInt32.abiName = "uint32";
      UInt32.byteWidth = 4;
      UInt32.isSigned = false;
      var UInt64 = class extends Int {
      };
      UInt64.abiName = "uint64";
      UInt64.byteWidth = 8;
      UInt64.isSigned = false;
      var UInt128 = class extends Int {
      };
      UInt128.abiName = "uint128";
      UInt128.byteWidth = 16;
      UInt128.isSigned = false;
      var VarInt = class extends Int {
        static fromABI(decoder) {
          return new this(new BN__default["default"](decoder.readVarint32()));
        }
        toABI(encoder) {
          encoder.writeVarint32(Number(this));
        }
      };
      VarInt.abiName = "varint32";
      VarInt.byteWidth = 32;
      VarInt.isSigned = true;
      var VarUInt = class extends Int {
        static fromABI(decoder) {
          return new this(new BN__default["default"](decoder.readVaruint32()));
        }
        toABI(encoder) {
          encoder.writeVaruint32(Number(this));
        }
      };
      VarUInt.abiName = "varuint32";
      VarUInt.byteWidth = 32;
      VarUInt.isSigned = false;
      function clamp(num, min, max) {
        return BN__default["default"].min(BN__default["default"].max(num, min), max);
      }
      function truncate(value, from, to) {
        const fill = value.isNeg() ? 255 : 0;
        const fromValue = from.isSigned ? value.toTwos(from.byteWidth * 8) : value;
        const fromBytes = fromValue.toArrayLike(Uint8Array, "le");
        const toBytes = new Uint8Array(to.byteWidth);
        toBytes.fill(fill);
        toBytes.set(fromBytes.slice(0, to.byteWidth));
        const toValue = new BN__default["default"](toBytes, void 0, "le");
        return to.isSigned ? toValue.fromTwos(to.byteWidth * 8) : toValue;
      }
      function convert(a, b) {
        a = promote(a);
        b = promote(b);
        const aType = a.constructor;
        const bType = b.constructor;
        if (aType !== bType) {
          if (aType.isSigned === bType.isSigned) {
            if (aType.byteWidth > bType.byteWidth) {
              b = b.cast(aType);
            } else if (bType.byteWidth > aType.byteWidth) {
              a = a.cast(bType);
            }
          } else {
            if (aType.isSigned === false && aType.byteWidth >= bType.byteWidth) {
              b = b.cast(aType);
            } else if (bType.isSigned === false && bType.byteWidth >= aType.byteWidth) {
              a = a.cast(bType);
            } else {
              if (aType.isSigned === true && aType.max.gte(bType.max) && aType.min.lte(bType.min)) {
                b = b.cast(aType);
              } else if (bType.isSigned === true && bType.max.gte(aType.max) && bType.min.lte(aType.min)) {
                a = a.cast(bType);
              } else
                ;
            }
          }
        }
        return { a, b };
      }
      function promote(n) {
        let rv = n;
        const type = n.constructor;
        if (type.byteWidth < 4) {
          rv = n.cast(Int32);
        }
        return rv;
      }
      function synthesizeABI(type) {
        const structs = [];
        const variants = [];
        const aliases = [];
        const seen = new Set();
        const resolveAbiType = (t) => {
          let typeName;
          if (typeof t.type !== "string") {
            typeName = resolve(t.type);
          } else {
            typeName = t.type;
          }
          if (t.array === true) {
            typeName += "[]";
          }
          if (t.extension === true) {
            typeName += "$";
          }
          if (t.optional === true) {
            typeName += "?";
          }
          return typeName;
        };
        const resolve = (t) => {
          if (!t.abiName) {
            throw new Error("Encountered non-conforming type");
          } else if (t.abiName === "__struct") {
            throw new Error("Misconfigured Struct subclass, did you forget @Struct.type?");
          }
          if (seen.has(t)) {
            return t.abiName;
          }
          seen.add(t);
          if (t.abiAlias) {
            aliases.push({
              new_type_name: t.abiName,
              type: resolveAbiType(t.abiAlias)
            });
          } else if (t.abiFields) {
            const fields = t.abiFields.map((field) => {
              return {
                name: field.name,
                type: resolveAbiType(field)
              };
            });
            const struct = {
              base: t.abiBase ? resolve(t.abiBase) : "",
              name: t.abiName,
              fields
            };
            structs.push(struct);
          } else if (t.abiVariant) {
            const variant = {
              name: t.abiName,
              types: t.abiVariant.map(resolveAbiType)
            };
            variants.push(variant);
          }
          return t.abiName;
        };
        const root = resolve(type);
        return { abi: ABI.from({ structs, variants, types: aliases }), types: Array.from(seen), root };
      }
      function abiTypeString(type) {
        let typeName = typeof type.type === "string" ? type.type : type.type.abiName;
        if (type.array === true) {
          typeName += "[]";
        }
        if (type.extension === true) {
          typeName += "$";
        }
        if (type.optional === true) {
          typeName += "?";
        }
        return typeName;
      }
      function isTypeDescriptor(type) {
        return typeof type !== "string" && type.abiName === void 0 && type.type !== void 0;
      }
      function toTypeDescriptor(type) {
        if (typeof type === "string") {
          return { type };
        }
        if (typeof type.abiName !== "undefined") {
          return { type };
        }
        return type;
      }
      var StringType = {
        abiName: "string",
        fromABI: (decoder) => {
          return decoder.readString();
        },
        from: (string) => string,
        toABI: (string, encoder) => {
          encoder.writeString(string);
        }
      };
      var BoolType = {
        abiName: "bool",
        fromABI: (decoder) => {
          return decoder.readByte() === 1;
        },
        from: (value) => value,
        toABI: (value, encoder) => {
          encoder.writeByte(value === true ? 1 : 0);
        }
      };
      function getBuiltins() {
        return [
          BoolType,
          StringType,
          Asset,
          Asset.Symbol,
          Asset.SymbolCode,
          BlockTimestamp,
          Bytes,
          Checksum160,
          Checksum256,
          Checksum512,
          ExtendedAsset,
          Float128,
          Float32,
          Float64,
          Int128,
          Int16,
          Int32,
          Int64,
          Int8,
          Name,
          PublicKey,
          Signature,
          TimePoint,
          TimePointSec,
          UInt128,
          UInt16,
          UInt32,
          UInt64,
          UInt8,
          VarInt,
          VarUInt
        ];
      }
      function buildTypeLookup(additional = []) {
        const rv = {};
        const builtins = getBuiltins();
        for (const type of builtins) {
          rv[type.abiName] = type;
        }
        for (const type of additional) {
          if (!type.abiName) {
            throw new Error("Invalid type");
          }
          rv[type.abiName] = type;
        }
        return rv;
      }
      function getTypeName(object) {
        if (object.constructor && object.constructor.abiName !== void 0) {
          return object.constructor.abiName;
        }
        if (Array.isArray(object)) {
          const types2 = object.map(getTypeName);
          const type = types2[0];
          if (!type || !types2.every((t) => t === type)) {
            return;
          }
          return type + "[]";
        }
        switch (typeof object) {
          case "boolean":
            return "bool";
          case "string":
            return "string";
        }
      }
      function getType(object, name = "jsobj") {
        var _a;
        if (object.constructor && object.constructor.abiName !== void 0) {
          return object.constructor;
        }
        if (Array.isArray(object)) {
          const types2 = object.map((v) => {
            return getType(v, name);
          });
          const type = types2[0];
          if (!type) {
            return;
          }
          if (!types2.every((t) => t && t.abiName === type.abiName)) {
            return;
          }
          return type;
        }
        const objectType = typeof object;
        if (objectType === "object" && object !== null) {
          const fields = Object.keys(object).map((key) => {
            return { name: key, type: getType(object[key], name + "_nested") };
          });
          if (fields.find((field) => !field.type)) {
            return;
          }
          return _a = class extends Struct {
          }, _a.abiName = name, _a.abiFields = fields, _a;
        }
        switch (objectType) {
          case "boolean":
            return BoolType;
          case "string":
            return StringType;
        }
      }
      var DecodingError = class extends Error {
        constructor(ctx, underlyingError) {
          const path = ctx.codingPath.map(({ field, type }) => {
            if (typeof field === "number") {
              return field;
            } else {
              return `${field}<${type.typeName}>`;
            }
          }).join(".");
          super(`Decoding error at ${path}: ${underlyingError.message}`);
          this.stack = underlyingError.stack;
          this.ctx = ctx;
          this.underlyingError = underlyingError;
        }
      };
      DecodingError.__className = "DecodingError";
      function abiDecode(args) {
        const descriptor = toTypeDescriptor(args.type);
        const typeName = abiTypeString(descriptor);
        const customTypes = args.customTypes || [];
        let abi;
        if (args.abi) {
          abi = ABI.from(args.abi);
        } else {
          try {
            let type;
            if (typeof descriptor.type === "string") {
              const lookup = buildTypeLookup(customTypes);
              const rName = new ABI.ResolvedType(descriptor.type).name;
              type = lookup[rName];
              if (!type) {
                throw new Error(`Unknown type: ${descriptor.type}`);
              }
            } else {
              type = descriptor.type;
            }
            const synthesized = synthesizeABI(type);
            abi = synthesized.abi;
            customTypes.push(...synthesized.types);
          } catch (error) {
            throw Error(`Unable to synthesize ABI for: ${typeName} (${error.message}). To decode non-class types you need to pass the ABI definition manually.`);
          }
        }
        const resolved = abi.resolveType(typeName);
        if (typeof descriptor.type !== "string") {
          customTypes.unshift(descriptor.type);
        }
        const ctx = {
          types: buildTypeLookup(customTypes),
          codingPath: [{ field: "root", type: resolved }]
        };
        try {
          if (args.data) {
            let decoder;
            if (isInstanceOf(args.data, ABIDecoder)) {
              decoder = args.data;
            } else {
              const bytes = Bytes.from(args.data);
              decoder = new ABIDecoder(bytes.array);
            }
            if (args.metadata) {
              decoder.metadata = args.metadata;
            }
            return decodeBinary(resolved, decoder, ctx);
          } else if (args.object !== void 0) {
            return decodeObject(args.object, resolved, ctx);
          } else if (args.json) {
            return decodeObject(JSON.parse(args.json), resolved, ctx);
          } else {
            throw new Error("Nothing to decode, you must set one of data, json, object");
          }
        } catch (error) {
          throw new DecodingError(ctx, error);
        }
      }
      var Resolved = Symbol("Resolved");
      function decodeBinary(type, decoder, ctx) {
        if (ctx.codingPath.length > 32) {
          throw new Error("Maximum decoding depth exceeded");
        }
        if (type.isExtension) {
          if (!decoder.canRead()) {
            return void 0;
          }
        }
        if (type.isOptional) {
          if (decoder.readByte() === 0) {
            return null;
          }
        }
        if (type.isArray) {
          const len = decoder.readVaruint32();
          const rv = [];
          for (let i = 0; i < len; i++) {
            ctx.codingPath.push({ field: i, type });
            rv.push(decodeInner());
            ctx.codingPath.pop();
          }
          return rv;
        } else {
          return decodeInner();
        }
        function decodeInner() {
          const abiType = ctx.types[type.name];
          if (abiType && abiType.fromABI) {
            return abiType.fromABI(decoder);
          } else {
            if (type.ref) {
              ctx.codingPath.push({ field: "", type: type.ref });
              const rv = decodeBinary(type.ref, decoder, ctx);
              ctx.codingPath.pop();
              return rv;
            } else if (type.fields) {
              const fields = type.allFields;
              if (!fields) {
                throw new Error("Invalid struct fields");
              }
              const rv = {};
              for (const field of fields) {
                ctx.codingPath.push({ field: field.name, type: field.type });
                rv[field.name] = decodeBinary(field.type, decoder, ctx);
                ctx.codingPath.pop();
              }
              if (abiType) {
                rv[Resolved] = true;
                return abiType.from(rv);
              } else {
                return rv;
              }
            } else if (type.variant) {
              const vIdx = decoder.readByte();
              const vType = type.variant[vIdx];
              if (!vType) {
                throw new Error(`Unknown variant idx: ${vIdx}`);
              }
              ctx.codingPath.push({ field: `v${vIdx}`, type: vType });
              const rv = [vType.typeName, decodeBinary(vType, decoder, ctx)];
              ctx.codingPath.pop();
              if (abiType) {
                return abiType.from(rv);
              } else {
                return rv;
              }
            } else if (abiType) {
              throw new Error("Invalid type");
            } else {
              throw new Error(type.name === "any" ? "Unable to decode 'any' type from binary" : "Unknown type");
            }
          }
        }
      }
      function decodeObject(value, type, ctx) {
        if (value === null || value === void 0) {
          if (type.isOptional || type.isExtension) {
            return null;
          } else {
            throw new Error(`Unexpectedly encountered ${value} for non-optional`);
          }
        } else if (type.isArray) {
          if (!Array.isArray(value)) {
            throw new Error("Expected array");
          }
          const rv = [];
          const len = value.length;
          for (let i = 0; i < len; i++) {
            ctx.codingPath.push({ field: i, type });
            rv.push(decodeInner(value[i]));
            ctx.codingPath.pop();
          }
          return rv;
        } else {
          return decodeInner(value);
        }
        function decodeInner(value2) {
          const abiType = ctx.types[type.name];
          if (type.ref && !abiType) {
            return decodeObject(value2, type.ref, ctx);
          } else if (type.fields) {
            if (typeof value2 !== "object") {
              throw new Error("Expected object");
            }
            if (typeof abiType === "function" && isInstanceOf(value2, abiType)) {
              return value2;
            }
            const fields = type.allFields;
            if (!fields) {
              throw new Error("Invalid struct fields");
            }
            const struct = {};
            for (const field of fields) {
              ctx.codingPath.push({ field: field.name, type: field.type });
              struct[field.name] = decodeObject(value2[field.name], field.type, ctx);
              ctx.codingPath.pop();
            }
            if (abiType) {
              struct[Resolved] = true;
              return abiType.from(struct);
            } else {
              return struct;
            }
          } else if (type.variant) {
            let vName;
            if (Array.isArray(value2) && value2.length === 2 && typeof value2[0] === "string") {
              vName = value2[0];
              value2 = value2[1];
            } else if (isInstanceOf(value2, Variant)) {
              vName = value2.variantName;
              value2 = value2.value;
            } else {
              vName = getTypeName(value2);
            }
            const vIdx = type.variant.findIndex((t) => t.typeName === vName);
            if (vIdx === -1) {
              throw new Error(`Unknown variant type: ${vName}`);
            }
            const vType = type.variant[vIdx];
            ctx.codingPath.push({ field: `v${vIdx}`, type: vType });
            const rv = [vType.typeName, decodeObject(value2, vType, ctx)];
            ctx.codingPath.pop();
            if (abiType) {
              rv[Resolved] = true;
              return abiType.from(rv);
            } else {
              return rv;
            }
          } else {
            if (!abiType) {
              if (type.name === "any") {
                return value2;
              }
              throw new Error("Unknown type");
            }
            return abiType.from(value2);
          }
        }
      }
      var ABIDecoder = class {
        constructor(array) {
          this.array = array;
          this.pos = 0;
          this.textDecoder = new TextDecoder("utf-8", { fatal: true });
          this.metadata = {};
          this.data = new DataView(array.buffer, array.byteOffset, array.byteLength);
        }
        canRead(bytes = 1) {
          return !(this.pos + bytes > this.array.byteLength);
        }
        ensure(bytes) {
          if (!this.canRead(bytes)) {
            throw new Error("Read past end of buffer");
          }
        }
        readByte() {
          this.ensure(1);
          return this.array[this.pos++];
        }
        readFloat(byteWidth) {
          this.ensure(byteWidth);
          let rv;
          switch (byteWidth) {
            case 4:
              rv = this.data.getFloat32(this.pos, true);
              break;
            case 8:
              rv = this.data.getFloat64(this.pos, true);
              break;
            default:
              throw new Error("Invalid float size");
          }
          this.pos += byteWidth;
          return rv;
        }
        readVaruint32() {
          let v = 0;
          let bit = 0;
          for (; ; ) {
            const b = this.readByte();
            v |= (b & 127) << bit;
            bit += 7;
            if (!(b & 128)) {
              break;
            }
          }
          return v >>> 0;
        }
        readVarint32() {
          const v = this.readVaruint32();
          if (v & 1) {
            return ~v >> 1 | 2147483648;
          } else {
            return v >>> 1;
          }
        }
        readArray(length) {
          this.ensure(length);
          const rv = this.array.subarray(this.pos, this.pos + length);
          this.pos += length;
          return rv;
        }
        readString() {
          const length = this.readVaruint32();
          return this.textDecoder.decode(this.readArray(length));
        }
      };
      ABIDecoder.__className = "ABIDecoder";
      var EncodingError = class extends Error {
        constructor(ctx, underlyingError) {
          const path = ctx.codingPath.map(({ field, type }) => {
            if (typeof field === "number") {
              return field;
            } else {
              return `${field}<${type.typeName}>`;
            }
          }).join(".");
          super(`Encoding error at ${path}: ${underlyingError.message}`);
          this.stack = underlyingError.stack;
          this.ctx = ctx;
          this.underlyingError = underlyingError;
        }
      };
      EncodingError.__className = "EncodingError";
      function abiEncode(args) {
        let type;
        let typeName;
        if (typeof args.type === "string") {
          typeName = args.type;
        } else if (args.type && isTypeDescriptor(args.type)) {
          if (typeof args.type.type !== "string") {
            type = args.type.type;
          }
          typeName = abiTypeString(args.type);
        } else if (args.type && args.type.abiName !== void 0) {
          type = args.type;
          typeName = args.type.abiName;
        } else {
          type = getType(args.object);
          if (type) {
            typeName = type.abiName;
            if (Array.isArray(args.object)) {
              typeName += "[]";
            }
          }
        }
        const customTypes = args.customTypes ? args.customTypes.slice() : [];
        if (type) {
          customTypes.unshift(type);
        } else if (typeName) {
          const rootName = new ABI.ResolvedType(typeName).name;
          type = customTypes.find((t) => t.abiName === rootName);
        }
        let rootType;
        if (args.abi && typeName) {
          rootType = ABI.from(args.abi).resolveType(typeName);
        } else if (type) {
          const synthesized = synthesizeABI(type);
          rootType = synthesized.abi.resolveType(typeName || type.abiName);
          customTypes.push(...synthesized.types);
        } else if (typeName) {
          rootType = new ABI.ResolvedType(typeName);
        } else {
          throw new Error("Unable to determine the type of the object to be encoded. To encode custom ABI types you must pass the type argument.");
        }
        const types2 = buildTypeLookup(customTypes);
        const encoder = args.encoder || new ABIEncoder();
        if (args.metadata) {
          encoder.metadata = args.metadata;
        }
        const ctx = {
          types: types2,
          encoder,
          codingPath: [{ field: "root", type: rootType }]
        };
        try {
          encodeAny(args.object, rootType, ctx);
        } catch (error) {
          throw new EncodingError(ctx, error);
        }
        return Bytes.from(encoder.getData());
      }
      function encodeAny(value, type, ctx) {
        const valueExists = value !== void 0 && value !== null;
        if (type.isOptional) {
          ctx.encoder.writeByte(valueExists ? 1 : 0);
          if (!valueExists) {
            return;
          }
        }
        if (type.isArray) {
          if (!Array.isArray(value)) {
            throw new Error(`Expected array for: ${type.typeName}`);
          }
          const len = value.length;
          ctx.encoder.writeVaruint32(len);
          for (let i = 0; i < len; i++) {
            ctx.codingPath.push({ field: i, type });
            encodeInner(value[i]);
            ctx.codingPath.pop();
          }
        } else {
          encodeInner(value);
        }
        function encodeInner(value2) {
          const abiType = ctx.types[type.name];
          if (type.ref && !abiType) {
            encodeAny(value2, type.ref, ctx);
            return;
          }
          if (!valueExists) {
            if (type.isExtension) {
              return;
            }
            throw new Error(`Found ${value2} for non-optional type: ${type.typeName}`);
          }
          if (abiType && abiType.toABI) {
            abiType.toABI(value2, ctx.encoder);
          } else if (typeof value2.toABI === "function" && value2.constructor.abiName === type.name) {
            value2.toABI(ctx.encoder);
          } else {
            if (type.fields) {
              if (typeof value2 !== "object") {
                throw new Error(`Expected object for: ${type.name}`);
              }
              const fields = type.allFields;
              if (!fields) {
                throw new Error("Invalid struct fields");
              }
              for (const field of fields) {
                ctx.codingPath.push({ field: field.name, type: field.type });
                encodeAny(value2[field.name], field.type, ctx);
                ctx.codingPath.pop();
              }
            } else if (type.variant) {
              let vName;
              if (Array.isArray(value2) && value2.length === 2 && typeof value2[0] === "string") {
                vName = value2[0];
                value2 = value2[1];
              } else if (isInstanceOf(value2, Variant)) {
                vName = value2.variantName;
                value2 = value2.value;
              } else {
                vName = getTypeName(value2);
              }
              const vIdx = type.variant.findIndex((t) => t.typeName === vName);
              if (vIdx === -1) {
                const types2 = type.variant.map((t) => `'${t.typeName}'`).join(", ");
                throw new Error(`Unknown variant type '${vName}', expected one of ${types2}`);
              }
              const vType = type.variant[vIdx];
              ctx.encoder.writeVaruint32(vIdx);
              ctx.codingPath.push({ field: `v${vIdx}`, type: vType });
              encodeAny(value2, vType, ctx);
              ctx.codingPath.pop();
            } else {
              if (!abiType) {
                throw new Error(type.name === "any" ? "Unable to encode any type to binary" : "Unknown type");
              }
              const instance = abiType.from(value2);
              if (!instance.toABI) {
                throw new Error(`Invalid type ${type.name}, no encoding methods implemented`);
              }
              instance.toABI(ctx.encoder);
            }
          }
        }
      }
      var ABIEncoder = class {
        constructor(pageSize = 1024) {
          this.pageSize = pageSize;
          this.pos = 0;
          this.textEncoder = new TextEncoder();
          this.metadata = {};
          const buffer = new ArrayBuffer(pageSize);
          this.data = new DataView(buffer);
          this.array = new Uint8Array(buffer);
        }
        ensure(bytes) {
          if (this.data.byteLength >= this.pos + bytes) {
            return;
          }
          const pages = Math.ceil(bytes / this.pageSize);
          const newSize = this.data.byteLength + this.pageSize * pages;
          const buffer = new ArrayBuffer(newSize);
          const data = new DataView(buffer);
          const array = new Uint8Array(buffer);
          array.set(this.array);
          this.data = data;
          this.array = array;
        }
        writeByte(byte) {
          this.ensure(1);
          this.array[this.pos++] = byte;
        }
        writeArray(bytes) {
          const size = bytes.length;
          this.ensure(size);
          this.array.set(bytes, this.pos);
          this.pos += size;
        }
        writeFloat(value, byteWidth) {
          this.ensure(byteWidth);
          switch (byteWidth) {
            case 4:
              this.data.setFloat32(this.pos, value, true);
              break;
            case 8:
              this.data.setFloat64(this.pos, value, true);
              break;
            default:
              throw new Error("Invalid float size");
          }
          this.pos += byteWidth;
        }
        writeVaruint32(v) {
          this.ensure(4);
          for (; ; ) {
            if (v >>> 7) {
              this.array[this.pos++] = 128 | v & 127;
              v = v >>> 7;
            } else {
              this.array[this.pos++] = v;
              break;
            }
          }
        }
        writeVarint32(v) {
          this.writeVaruint32(v << 1 ^ v >> 31);
        }
        writeString(v) {
          const data = this.textEncoder.encode(v);
          this.writeVaruint32(data.byteLength);
          this.writeArray(data);
        }
        getData() {
          return new Uint8Array(this.array.buffer, this.array.byteOffset, this.pos);
        }
      };
      ABIEncoder.__className = "ABIEncoder";
      var Struct = class {
        constructor(object) {
          const self2 = this.constructor;
          for (const field of self2.structFields) {
            this[field.name] = object[field.name];
          }
        }
        static from(value) {
          if (value[Resolved] === true) {
            return new this(value);
          }
          if (isInstanceOf(value, this)) {
            return value;
          }
          const object = {};
          for (const field of this.structFields) {
            const v = value[field.name] === void 0 ? field.default : value[field.name];
            if (v === void 0 && !(field.optional === true || field.name.includes("?"))) {
              throw new Error(`Missing value for non optional field: ${field.name}`);
            }
            object[field.name] = v;
          }
          return abiDecode({ object, type: this });
        }
        static get structFields() {
          const rv = [];
          const walk = (t) => {
            if (t.abiBase) {
              walk(t.abiBase);
            }
            for (const field of t.abiFields || []) {
              rv.push(field);
            }
          };
          walk(this);
          return rv;
        }
        equals(other) {
          const self2 = this.constructor;
          if (other.constructor && typeof other.constructor.abiName === "string" && other.constructor.abiName !== self2.abiName) {
            return false;
          }
          return abiEncode({ object: this }).equals(abiEncode({ object: self2.from(other) }));
        }
        toJSON() {
          const self2 = this.constructor;
          const rv = {};
          for (const field of self2.structFields) {
            rv[field.name] = this[field.name];
          }
          return rv;
        }
      };
      Struct.abiName = "__struct";
      (function(Struct2) {
        const FieldsOwner = Symbol("FieldsOwner");
        function type(name) {
          return function(struct) {
            struct.abiName = name;
            return struct;
          };
        }
        Struct2.type = type;
        function field(type2, options) {
          if (!options)
            options = {};
          return (target, name) => {
            const ctor = target.constructor;
            if (!ctor.abiFields) {
              ctor.abiFields = [];
              ctor.abiFields[FieldsOwner] = ctor;
            } else if (ctor.abiFields[FieldsOwner] !== ctor) {
              ctor.abiBase = ctor.abiFields[FieldsOwner];
              ctor.abiFields = [];
              ctor.abiFields[FieldsOwner] = ctor;
            }
            ctor.abiFields.push(Object.assign(Object.assign({}, options), { name, type: type2 }));
          };
        }
        Struct2.field = field;
      })(Struct || (Struct = {}));
      function TypeAlias(name) {
        return function(typeAlias) {
          typeAlias.abiAlias = { type: Object.getPrototypeOf(typeAlias.prototype).constructor };
          typeAlias.abiName = name;
          return typeAlias;
        };
      }
      var Variant = class {
        constructor(variant) {
          const abiVariant = this.constructor.abiVariant;
          this.value = variant[1];
          const variantIdx = abiVariant.map(abiTypeString).findIndex((t) => t === variant[0]);
          if (0 > variantIdx || abiVariant.length <= variantIdx) {
            throw new Error(`Unknown variant ${variant[0]}`);
          }
          this.variantIdx = variantIdx;
        }
        static from(object) {
          if (object[Resolved]) {
            return new this(object);
          }
          if (isInstanceOf(object, this)) {
            return object;
          }
          return abiDecode({ object, type: this });
        }
        equals(other) {
          const self2 = this.constructor;
          const otherVariant = self2.from(other);
          if (this.variantIdx !== otherVariant.variantIdx) {
            return false;
          }
          return abiEncode({ object: this }).equals(abiEncode({ object: otherVariant }));
        }
        get variantName() {
          const variant = this.constructor.abiVariant[this.variantIdx];
          return abiTypeString(variant);
        }
        toJSON() {
          return [this.variantName, this.value];
        }
      };
      Variant.abiName = "__variant";
      Variant.abiVariant = [];
      (function(Variant2) {
        function type(name, types2) {
          return function(variant) {
            variant.abiName = name;
            variant.abiVariant = types2.map(toTypeDescriptor);
            return variant;
          };
        }
        Variant2.type = type;
      })(Variant || (Variant = {}));
      var Float = class {
        constructor(value) {
          if (!Number.isFinite(value)) {
            throw new Error("Invalid number");
          }
          this.value = value;
        }
        static from(value) {
          if (isInstanceOf(value, this)) {
            return value;
          }
          if (typeof value === "string") {
            value = Number.parseFloat(value);
          } else if (isInstanceOf(value, Float)) {
            value = value.value;
          }
          return new this(value);
        }
        static fromABI(decoder) {
          return new this(decoder.readFloat(this.byteWidth));
        }
        static random() {
          const bytes = secureRandom(this.byteWidth);
          const decoder = new ABIDecoder(bytes);
          return this.fromABI(decoder);
        }
        equals(other) {
          const self2 = this.constructor;
          return this.value === self2.from(other).value;
        }
        toABI(encoder) {
          const self2 = this.constructor;
          encoder.writeFloat(this.value, self2.byteWidth);
        }
        toString() {
          return this.value.toString();
        }
        toJSON() {
          return this.toString();
        }
      };
      Float.abiName = "__float";
      var Float32 = class extends Float {
        toString() {
          return this.value.toFixed(7);
        }
      };
      Float32.abiName = "float32";
      Float32.byteWidth = 4;
      var Float64 = class extends Float {
      };
      Float64.abiName = "float64";
      Float64.byteWidth = 8;
      var Float128 = class {
        constructor(data) {
          if (data.array.length !== 16) {
            throw new Error("Invalid float128");
          }
          this.data = data;
        }
        static from(value) {
          if (isInstanceOf(value, this)) {
            return value;
          }
          if (typeof value === "string" && value.startsWith("0x")) {
            value = value.slice(2);
          }
          return new this(Bytes.from(value));
        }
        static fromABI(decoder) {
          return new this(new Bytes(decoder.readArray(this.byteWidth)));
        }
        static random() {
          const bytes = secureRandom(16);
          const decoder = new ABIDecoder(bytes);
          return this.fromABI(decoder);
        }
        equals(other) {
          const self2 = this.constructor;
          return this.data.equals(self2.from(other).data);
        }
        toABI(encoder) {
          encoder.writeArray(this.data.array);
        }
        toString() {
          return "0x" + this.data.hexString;
        }
        toJSON() {
          return this.toString();
        }
      };
      Float128.abiName = "float128";
      Float128.byteWidth = 16;
      var Name = class {
        constructor(value) {
          this.value = value;
        }
        get rawValue() {
          return this.value;
        }
        static from(value) {
          if (isInstanceOf(value, Name)) {
            return value;
          } else if (typeof value === "string") {
            return new Name(stringToName(value));
          } else if (isInstanceOf(value, UInt64)) {
            return new Name(value);
          } else {
            throw new Error("Invalid name");
          }
        }
        static fromABI(decoder) {
          return new Name(UInt64.fromABI(decoder));
        }
        equals(other) {
          return this.value.equals(Name.from(other).value);
        }
        toString() {
          return nameToString(this.value);
        }
        toABI(encoder) {
          this.value.toABI(encoder);
        }
        toJSON() {
          return this.toString();
        }
      };
      Name.abiName = "name";
      Name.pattern = /^[a-z1-5.]{0,13}$/;
      function stringToName(s) {
        function charToSymbol(c) {
          if (c >= "a".charCodeAt(0) && c <= "z".charCodeAt(0)) {
            return c - "a".charCodeAt(0) + 6;
          }
          if (c >= "1".charCodeAt(0) && c <= "5".charCodeAt(0)) {
            return c - "1".charCodeAt(0) + 1;
          }
          return 0;
        }
        const a = new Uint8Array(8);
        let bit = 63;
        for (let i = 0; i < s.length; ++i) {
          let c = charToSymbol(s.charCodeAt(i));
          if (bit < 5) {
            c = c << 1;
          }
          for (let j = 4; j >= 0; --j) {
            if (bit >= 0) {
              a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;
              --bit;
            }
          }
        }
        return UInt64.from(a);
      }
      function nameToString(n) {
        const a = n.value.toArray("le", 8);
        let result = "";
        for (let bit = 63; bit >= 0; ) {
          let c = 0;
          for (let i = 0; i < 5; ++i) {
            if (bit >= 0) {
              c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;
              --bit;
            }
          }
          if (c >= 6) {
            result += String.fromCharCode(c + "a".charCodeAt(0) - 6);
          } else if (c >= 1) {
            result += String.fromCharCode(c + "1".charCodeAt(0) - 1);
          } else {
            result += ".";
          }
        }
        while (result.endsWith(".")) {
          result = result.substr(0, result.length - 1);
        }
        return result;
      }
      var TimePointBase = class {
        static from(value) {
          if (isInstanceOf(value, this)) {
            return value;
          }
          if (isInstanceOf(value, TimePointBase)) {
            return this.fromMilliseconds(value.toMilliseconds());
          }
          if (isInstanceOf(value, Date)) {
            return this.fromDate(value);
          }
          if (typeof value === "string") {
            return this.fromString(value);
          }
          return this.fromInteger(value);
        }
        static fromString(string) {
          const value = Date.parse(string + "Z");
          if (!Number.isFinite(value)) {
            throw new Error("Invalid date string");
          }
          return this.fromMilliseconds(value);
        }
        static fromDate(date) {
          return this.fromMilliseconds(date.getTime());
        }
        toABI(encoder) {
          const self2 = this;
          self2.value.toABI(encoder);
        }
        equals(other) {
          const self2 = this.constructor;
          return this.toMilliseconds() === self2.from(other).toMilliseconds();
        }
        toMilliseconds() {
          throw new Error("Not implemented");
        }
        toDate() {
          return new Date(this.toMilliseconds());
        }
        toJSON() {
          return this.toString();
        }
      };
      TimePointBase.abiName = "__time_point_base";
      var TimePoint = class extends TimePointBase {
        constructor(value) {
          super();
          this.value = value;
        }
        static fromMilliseconds(ms) {
          return new TimePoint(Int64.from(Math.round(ms * 1e3)));
        }
        static fromInteger(value) {
          return new TimePoint(Int64.from(value));
        }
        static fromABI(decoder) {
          return new this(Int64.fromABI(decoder));
        }
        toString() {
          return this.toDate().toISOString().slice(0, -1);
        }
        toMilliseconds() {
          return Number(this.value.dividing(1e3, "round"));
        }
      };
      TimePoint.abiName = "time_point";
      var TimePointSec = class extends TimePointBase {
        constructor(value) {
          super();
          this.value = value;
        }
        static fromMilliseconds(ms) {
          return new TimePointSec(UInt32.from(Math.round(ms / 1e3)));
        }
        static fromInteger(value) {
          return new TimePointSec(UInt32.from(value));
        }
        static fromABI(decoder) {
          return new this(UInt32.fromABI(decoder));
        }
        toString() {
          return this.toDate().toISOString().slice(0, -5);
        }
        toMilliseconds() {
          return Number(this.value.cast(UInt64).multiplying(1e3));
        }
      };
      TimePointSec.abiName = "time_point_sec";
      var BlockTimestamp = class extends TimePointBase {
        constructor(value) {
          super();
          this.value = value;
        }
        static fromMilliseconds(ms) {
          return new TimePointSec(UInt32.from(Math.round((ms - 9466848e5) / 500)));
        }
        static fromInteger(value) {
          return new TimePointSec(UInt32.from(value));
        }
        static fromABI(decoder) {
          return new this(UInt32.fromABI(decoder));
        }
        toString() {
          return this.toDate().toISOString().slice(0, -1);
        }
        toMilliseconds() {
          return Number(this.value.cast(UInt64).multiplying(500).adding(9466848e5));
        }
      };
      BlockTimestamp.abiName = "block_timestamp_type";
      var ABI = class {
        constructor(args) {
          this.version = args.version || ABI.version;
          this.types = args.types || [];
          this.variants = args.variants || [];
          this.structs = args.structs || [];
          this.actions = args.actions || [];
          this.tables = args.tables || [];
          this.ricardian_clauses = args.ricardian_clauses || [];
        }
        static from(value) {
          if (isInstanceOf(value, ABI)) {
            return value;
          }
          if (typeof value === "string") {
            return new ABI(JSON.parse(value));
          }
          return new ABI(value);
        }
        resolveType(name) {
          const types2 = {};
          return this.resolve({ name, types: types2 }, { id: 0 });
        }
        resolveAll() {
          const types2 = {};
          const ctx = { id: 0 };
          return {
            types: this.types.map((t) => this.resolve({ name: t.new_type_name, types: types2 }, ctx)),
            variants: this.variants.map((t) => this.resolve({ name: t.name, types: types2 }, ctx)),
            structs: this.structs.map((t) => this.resolve({ name: t.name, types: types2 }, ctx))
          };
        }
        resolve({ name, types: types2 }, ctx) {
          const existing = types2[name];
          if (existing) {
            return existing;
          }
          const type = new ABI.ResolvedType(name, ++ctx.id);
          types2[type.typeName] = type;
          const alias = this.types.find((typeDef) => typeDef.new_type_name == type.name);
          if (alias) {
            type.ref = this.resolve({ name: alias.type, types: types2 }, ctx);
            return type;
          }
          const struct = this.getStruct(type.name);
          if (struct) {
            if (struct.base) {
              type.base = this.resolve({ name: struct.base, types: types2 }, ctx);
            }
            type.fields = struct.fields.map((field) => {
              return {
                name: field.name,
                type: this.resolve({ name: field.type, types: types2 }, ctx)
              };
            });
            return type;
          }
          const variant = this.getVariant(type.name);
          if (variant) {
            type.variant = variant.types.map((name2) => this.resolve({ name: name2, types: types2 }, ctx));
            return type;
          }
          return type;
        }
        getStruct(name) {
          return this.structs.find((struct) => struct.name == name);
        }
        getVariant(name) {
          return this.variants.find((variant) => variant.name == name);
        }
        getActionType(actionName) {
          const name = Name.from(actionName).toString();
          const action = this.actions.find((a) => a.name.toString() === name);
          if (action) {
            return action.type;
          }
        }
      };
      ABI.__className = "ABI";
      ABI.version = "eosio::abi/1.1";
      (function(ABI2) {
        class ResolvedType {
          constructor(fullName, id = 0) {
            let name = fullName;
            if (name.endsWith("$")) {
              name = name.slice(0, -1);
              this.isExtension = true;
            } else {
              this.isExtension = false;
            }
            if (name.endsWith("?")) {
              name = name.slice(0, -1);
              this.isOptional = true;
            } else {
              this.isOptional = false;
            }
            if (name.endsWith("[]")) {
              name = name.slice(0, -2);
              this.isArray = true;
            } else {
              this.isArray = false;
            }
            this.id = id;
            this.name = name;
          }
          get typeName() {
            let rv = this.name;
            if (this.isArray) {
              rv += "[]";
            }
            if (this.isOptional) {
              rv += "?";
            }
            if (this.isExtension) {
              rv += "$";
            }
            return rv;
          }
          get allFields() {
            let current = this;
            const rv = [];
            const seen = new Set();
            do {
              if (!current.fields) {
                return;
              }
              if (seen.has(current.name)) {
                return;
              }
              for (let i = current.fields.length - 1; i >= 0; i--) {
                rv.unshift(current.fields[i]);
              }
              seen.add(current.name);
              current = current.base;
            } while (current !== void 0);
            return rv;
          }
        }
        ABI2.ResolvedType = ResolvedType;
      })(ABI || (ABI = {}));
      var Asset = class {
        constructor(units, symbol) {
          this.units = units;
          this.symbol = symbol;
        }
        static from(value, symbol) {
          if (isInstanceOf(value, Asset)) {
            return value;
          }
          switch (typeof value) {
            case "number":
              if (!symbol) {
                throw new Error("Symbol is required when creating Asset from number");
              }
              return this.fromFloat(value, symbol);
            case "string":
              return this.fromString(value);
            default:
              throw new Error("Invalid asset");
          }
        }
        static fromString(value) {
          const parts = (typeof value === "string" ? value : "").split(" ");
          if (parts.length !== 2) {
            throw new Error("Invalid asset string");
          }
          const amount = parts[0].replace(".", "");
          const precision = (parts[0].split(".")[1] || "").length;
          const symbol = Asset.Symbol.fromParts(parts[1], precision);
          return new Asset(Int64.from(amount), symbol);
        }
        static fromFloat(value, symbol) {
          const s = Asset.Symbol.from(symbol);
          return new Asset(s.convertFloat(value), s);
        }
        static fromUnits(value, symbol) {
          return new Asset(Int64.from(value), Asset.Symbol.from(symbol));
        }
        static fromABI(decoder) {
          const units = Int64.fromABI(decoder);
          const symbol = Asset.Symbol.fromABI(decoder);
          return new Asset(units, symbol);
        }
        equals(other) {
          const { symbol, units } = Asset.from(other);
          return this.symbol.value.equals(symbol.value) && this.units.equals(units);
        }
        get value() {
          return this.symbol.convertUnits(this.units);
        }
        set value(newValue) {
          this.units = this.symbol.convertFloat(newValue);
        }
        toABI(encoder) {
          this.units.toABI(encoder);
          this.symbol.toABI(encoder);
        }
        toString() {
          const digits = this.units.toString().split("");
          let negative = false;
          if (digits[0] === "-") {
            negative = true;
            digits.shift();
          }
          const p = this.symbol.precision;
          while (digits.length <= p) {
            digits.unshift("0");
          }
          if (p > 0) {
            digits.splice(digits.length - p, 0, ".");
          }
          let rv = digits.join("");
          if (negative) {
            rv = "-" + rv;
          }
          return rv + " " + this.symbol.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      Asset.abiName = "asset";
      (function(Asset2) {
        class Symbol2 {
          constructor(value) {
            if (toSymbolPrecision(value) > Symbol2.maxPrecision) {
              throw new Error("Invalid asset symbol, precision too large");
            }
            if (!Symbol2.symbolNamePattern.test(toSymbolName(value))) {
              throw new Error("Invalid asset symbol, name must be uppercase A-Z");
            }
            this.value = value;
          }
          static from(value) {
            if (isInstanceOf(value, Symbol2)) {
              return value;
            }
            if (isInstanceOf(value, UInt64)) {
              return new Symbol2(value);
            }
            const parts = value.split(",");
            if (parts.length !== 2) {
              throw new Error("Invalid symbol string");
            }
            const precision = Number.parseInt(parts[0]);
            return Symbol2.fromParts(parts[1], precision);
          }
          static fromParts(name, precision) {
            return new Symbol2(toRawSymbol(name, precision));
          }
          static fromABI(decoder) {
            return new Symbol2(UInt64.fromABI(decoder));
          }
          equals(other) {
            return this.value.equals(Symbol2.from(other).value);
          }
          get name() {
            return toSymbolName(this.value);
          }
          get precision() {
            return toSymbolPrecision(this.value);
          }
          get code() {
            return new SymbolCode(UInt64.from(this.value.value.clone().iushrn(8)));
          }
          toABI(encoder) {
            this.value.toABI(encoder);
          }
          convertUnits(units) {
            return units.value.toNumber() / Math.pow(10, this.precision);
          }
          convertFloat(float) {
            return Int64.from(float.toFixed(this.precision).replace(".", ""));
          }
          toString() {
            return `${this.precision},${this.name}`;
          }
          toJSON() {
            return this.toString();
          }
        }
        Symbol2.abiName = "symbol";
        Symbol2.symbolNamePattern = /^[A-Z]{1,7}$/;
        Symbol2.maxPrecision = 18;
        Asset2.Symbol = Symbol2;
        class SymbolCode {
          constructor(value) {
            this.value = value;
          }
          static from(value) {
            if (isInstanceOf(value, SymbolCode)) {
              return value;
            }
            if (typeof value === "string") {
              value = UInt64.from(toRawSymbolCode(value));
            }
            return new this(UInt64.from(value));
          }
          static fromABI(decoder) {
            return new SymbolCode(UInt64.fromABI(decoder));
          }
          equals(other) {
            return this.value.equals(SymbolCode.from(other).value);
          }
          toABI(encoder) {
            this.value.toABI(encoder);
          }
          toString() {
            return charsToSymbolName(this.value.value.toArray("be"));
          }
          toJSON() {
            return this.toString();
          }
        }
        SymbolCode.abiName = "symbol_code";
        Asset2.SymbolCode = SymbolCode;
      })(Asset || (Asset = {}));
      var ExtendedAsset = class {
        constructor(quantity, contract) {
          this.quantity = quantity;
          this.contract = contract;
        }
        static from(value) {
          if (isInstanceOf(value, ExtendedAsset)) {
            return value;
          }
          return new this(Asset.from(value.quantity), Name.from(value.contract));
        }
        static fromABI(decoder) {
          return new ExtendedAsset(Asset.fromABI(decoder), Name.fromABI(decoder));
        }
        equals(other) {
          return this.quantity.equals(other.quantity) && this.contract.equals(other.contract);
        }
        toABI(encoder) {
          this.quantity.toABI(encoder);
          this.contract.toABI(encoder);
        }
        toJSON() {
          return {
            quantity: this.quantity,
            contract: this.contract
          };
        }
      };
      ExtendedAsset.abiName = "extended_asset";
      function toSymbolPrecision(rawSymbol) {
        return rawSymbol.value.and(UInt64.from(255).value).toNumber();
      }
      function toSymbolName(rawSymbol) {
        const chars = rawSymbol.value.toArray("be").slice(0, -1);
        return charsToSymbolName(chars);
      }
      function charsToSymbolName(chars) {
        return chars.map((char) => String.fromCharCode(char)).reverse().join("");
      }
      function toRawSymbol(name, precision) {
        const code = toRawSymbolCode(name);
        const bytes = new Uint8Array(code.length + 1);
        bytes[0] = precision;
        bytes.set(code, 1);
        return UInt64.from(bytes);
      }
      function toRawSymbolCode(name) {
        const length = Math.min(name.length, 7);
        const bytes = new Uint8Array(length);
        for (let i = 0; i < length; i++) {
          bytes[i] = name.charCodeAt(i);
        }
        return bytes;
      }
      exports.Base58 = void 0;
      (function(Base58) {
        let ErrorCode;
        (function(ErrorCode2) {
          ErrorCode2["E_CHECKSUM"] = "E_CHECKSUM";
          ErrorCode2["E_INVALID"] = "E_INVALID";
        })(ErrorCode = Base58.ErrorCode || (Base58.ErrorCode = {}));
        class DecodingError2 extends Error {
          constructor(message, code, info = {}) {
            super(message);
            this.code = code;
            this.info = info;
          }
        }
        DecodingError2.__className = "DecodingError";
        Base58.DecodingError = DecodingError2;
        const chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        const charMap = new Int16Array(255).fill(-1);
        for (let i = 0; i < 58; ++i) {
          charMap[chars.charCodeAt(i)] = i;
        }
        function decode(s, size) {
          if (size == null) {
            return decodeVar(s);
          }
          const result = new Uint8Array(size);
          for (let i = 0; i < s.length; ++i) {
            let carry = charMap[s.charCodeAt(i)];
            if (carry < 0) {
              throw new DecodingError2("Invalid Base58 character encountered", ErrorCode.E_INVALID, { char: s[i] });
            }
            for (let j = 0; j < size; ++j) {
              const x = result[j] * 58 + carry;
              result[j] = x;
              carry = x >> 8;
            }
            if (carry) {
              throw new DecodingError2("Base58 value is out of range", ErrorCode.E_INVALID);
            }
          }
          result.reverse();
          return new Bytes(result);
        }
        Base58.decode = decode;
        function decodeCheck(encoded, size) {
          const decoded = decode(encoded, size != null ? size + 4 : size);
          const data = decoded.array.subarray(0, -4);
          const expected = decoded.array.subarray(-4);
          const actual = dsha256Checksum(data);
          if (!arrayEquals(expected, actual)) {
            throw new DecodingError2("Checksum mismatch", ErrorCode.E_CHECKSUM, {
              actual,
              expected,
              data,
              hash: "double_sha256"
            });
          }
          return new Bytes(data);
        }
        Base58.decodeCheck = decodeCheck;
        function decodeRipemd160Check(encoded, size, suffix) {
          const decoded = decode(encoded, size != null ? size + 4 : size);
          const data = decoded.array.subarray(0, -4);
          const expected = decoded.array.subarray(-4);
          const actual = ripemd160Checksum(data, suffix);
          if (!arrayEquals(expected, actual)) {
            throw new DecodingError2("Checksum mismatch", ErrorCode.E_CHECKSUM, {
              actual,
              expected,
              data,
              hash: "ripemd160"
            });
          }
          return new Bytes(data);
        }
        Base58.decodeRipemd160Check = decodeRipemd160Check;
        function encode(data) {
          data = Bytes.from(data);
          const result = [];
          for (const byte of data.array) {
            let carry = byte;
            for (let j = 0; j < result.length; ++j) {
              const x = (charMap[result[j]] << 8) + carry;
              result[j] = chars.charCodeAt(x % 58);
              carry = x / 58 | 0;
            }
            while (carry) {
              result.push(chars.charCodeAt(carry % 58));
              carry = carry / 58 | 0;
            }
          }
          for (const byte of data.array) {
            if (byte) {
              break;
            } else {
              result.push("1".charCodeAt(0));
            }
          }
          result.reverse();
          return String.fromCharCode(...result);
        }
        Base58.encode = encode;
        function encodeCheck(data) {
          data = Bytes.from(data);
          data = data.appending(dsha256Checksum(data.array));
          return encode(data);
        }
        Base58.encodeCheck = encodeCheck;
        function encodeRipemd160Check(data, suffix) {
          data = Bytes.from(data);
          data = data.appending(ripemd160Checksum(data.array, suffix));
          return encode(data);
        }
        Base58.encodeRipemd160Check = encodeRipemd160Check;
        function decodeVar(s) {
          const result = [];
          for (let i = 0; i < s.length; ++i) {
            let carry = charMap[s.charCodeAt(i)];
            if (carry < 0) {
              throw new DecodingError2("Invalid Base58 character encountered", ErrorCode.E_INVALID, { char: s[i] });
            }
            for (let j = 0; j < result.length; ++j) {
              const x = result[j] * 58 + carry;
              result[j] = x & 255;
              carry = x >> 8;
            }
            if (carry) {
              result.push(carry);
            }
          }
          for (const ch of s) {
            if (ch === "1") {
              result.push(0);
            } else {
              break;
            }
          }
          result.reverse();
          return Bytes.from(result);
        }
        function ripemd160Checksum(data, suffix) {
          const hash = hash_js.ripemd160().update(data);
          if (suffix) {
            hash.update(suffix);
          }
          return new Uint8Array(hash.digest().slice(0, 4));
        }
        function dsha256Checksum(data) {
          const round1 = hash_js.sha256().update(data).digest();
          const round2 = hash_js.sha256().update(round1).digest();
          return new Uint8Array(round2.slice(0, 4));
        }
      })(exports.Base58 || (exports.Base58 = {}));
      var PublicKey = class {
        constructor(type, data) {
          this.type = type;
          this.data = data;
        }
        static from(value) {
          if (isInstanceOf(value, PublicKey)) {
            return value;
          }
          if (typeof value === "object" && value.type && value.compressed) {
            return new PublicKey(exports.CurveType.from(value.type), new Bytes(value.compressed));
          }
          if (typeof value !== "string") {
            throw new Error("Invalid public key");
          }
          if (value.startsWith("PUB_")) {
            const parts = value.split("_");
            if (parts.length !== 3) {
              throw new Error("Invalid public key string");
            }
            const type = exports.CurveType.from(parts[1]);
            const size = type === exports.CurveType.K1 || type === exports.CurveType.R1 ? 33 : void 0;
            const data = exports.Base58.decodeRipemd160Check(parts[2], size, type);
            return new PublicKey(type, data);
          } else if (value.length >= 50) {
            const data = exports.Base58.decodeRipemd160Check(value.slice(-50));
            return new PublicKey(exports.CurveType.K1, data);
          } else {
            throw new Error("Invalid public key string");
          }
        }
        static fromABI(decoder) {
          const type = exports.CurveType.from(decoder.readByte());
          if (type == exports.CurveType.WA) {
            const data = new Bytes(decoder.readArray(33));
            Bytes.fromABI(decoder);
            return new PublicKey(type, data);
          }
          return new PublicKey(type, new Bytes(decoder.readArray(33)));
        }
        equals(other) {
          const otherKey = PublicKey.from(other);
          return this.type === otherKey.type && this.data.equals(otherKey.data);
        }
        toLegacyString(prefix = "EOS") {
          if (this.type !== exports.CurveType.K1) {
            throw new Error("Unable to create legacy formatted string for non-K1 key");
          }
          return `${prefix}${exports.Base58.encodeRipemd160Check(this.data)}`;
        }
        toString() {
          return `PUB_${this.type}_${exports.Base58.encodeRipemd160Check(this.data, this.type)}`;
        }
        toABI(encoder) {
          if (this.type === exports.CurveType.WA) {
            throw new Error("WA keys are not supported yet");
          }
          encoder.writeByte(exports.CurveType.indexFor(this.type));
          encoder.writeArray(this.data.array);
        }
        toJSON() {
          return this.toString();
        }
      };
      PublicKey.abiName = "public_key";
      var curves = {};
      function getCurve(type) {
        let rv = curves[type];
        if (!rv) {
          if (type === "K1") {
            rv = curves[type] = new elliptic.ec("secp256k1");
          } else if (type === "R1") {
            rv = curves[type] = new elliptic.ec("p256");
          } else {
            throw new Error(`Unknown curve type: ${type}`);
          }
        }
        return rv;
      }
      function recover(signature, message, type) {
        const curve = getCurve(type);
        const recid = signature[0] - 31;
        const r = signature.subarray(1, 33);
        const s = signature.subarray(33);
        const point = curve.recoverPubKey(message, { r, s }, recid);
        return new Uint8Array(point.encodeCompressed());
      }
      function verify(signature, message, pubkey, type) {
        const curve = getCurve(type);
        const r = signature.subarray(1, 33);
        const s = signature.subarray(33);
        return curve.verify(message, { r, s }, pubkey);
      }
      var Signature = class {
        constructor(type, data) {
          this.type = type;
          this.data = data;
        }
        static from(value) {
          if (isInstanceOf(value, Signature)) {
            return value;
          }
          if (typeof value === "object" && value.r && value.s) {
            const data = new Uint8Array(1 + 32 + 32);
            let recid = value.recid;
            const type = exports.CurveType.from(value.type);
            if (value.type === exports.CurveType.K1 || value.type === exports.CurveType.R1) {
              recid += 31;
            }
            data[0] = recid;
            data.set(value.r, 1);
            data.set(value.s, 33);
            return new Signature(type, new Bytes(data));
          }
          if (typeof value !== "string") {
            throw new Error("Invalid signature");
          }
          if (value.startsWith("SIG_")) {
            const parts = value.split("_");
            if (parts.length !== 3) {
              throw new Error("Invalid signature string");
            }
            const type = exports.CurveType.from(parts[1]);
            const size = type === exports.CurveType.K1 || type === exports.CurveType.R1 ? 65 : void 0;
            const data = exports.Base58.decodeRipemd160Check(parts[2], size, type);
            return new Signature(type, data);
          } else {
            throw new Error("Invalid signature string");
          }
        }
        static fromABI(decoder) {
          const type = exports.CurveType.from(decoder.readByte());
          if (type === exports.CurveType.WA) {
            const data = new Bytes(decoder.readArray(65));
            Bytes.fromABI(decoder);
            Bytes.fromABI(decoder);
            return new Signature(exports.CurveType.WA, data);
          }
          return new Signature(type, new Bytes(decoder.readArray(65)));
        }
        equals(other) {
          const otherSig = Signature.from(other);
          return this.type === otherSig.type && this.data.equals(otherSig.data);
        }
        recoverDigest(digest) {
          digest = Checksum256.from(digest);
          const compressed = recover(this.data.array, digest.array, this.type);
          return PublicKey.from({ compressed, type: this.type });
        }
        recoverMessage(message) {
          return this.recoverDigest(Checksum256.hash(message));
        }
        verifyDigest(digest, publicKey) {
          digest = Checksum256.from(digest);
          return verify(this.data.array, digest.array, publicKey.data.array, this.type);
        }
        verifyMessage(message, publicKey) {
          return this.verifyDigest(Checksum256.hash(message), publicKey);
        }
        toString() {
          return `SIG_${this.type}_${exports.Base58.encodeRipemd160Check(this.data, this.type)}`;
        }
        toABI(encoder) {
          if (this.type === exports.CurveType.WA) {
            throw new Error("WA signatures are not supported yet");
          }
          encoder.writeByte(exports.CurveType.indexFor(this.type));
          encoder.writeArray(this.data.array);
        }
        toJSON() {
          return this.toString();
        }
      };
      Signature.abiName = "signature";
      function getPublic(privkey, type) {
        const curve = getCurve(type);
        const key = curve.keyFromPrivate(privkey);
        const point = key.getPublic();
        return new Uint8Array(point.encodeCompressed());
      }
      function sharedSecret(privkey, pubkey, type) {
        const curve = getCurve(type);
        const priv = curve.keyFromPrivate(privkey);
        const pub = curve.keyFromPublic(pubkey).getPublic();
        return priv.derive(pub).toArrayLike(Uint8Array, "be");
      }
      function sign(secret, message, type) {
        const curve = getCurve(type);
        const key = curve.keyFromPrivate(secret);
        let sig;
        let r;
        let s;
        if (type === "K1") {
          let attempt = 1;
          do {
            sig = key.sign(message, { canonical: true, pers: [attempt++] });
            r = sig.r.toArrayLike(Uint8Array, "be", 32);
            s = sig.s.toArrayLike(Uint8Array, "be", 32);
          } while (!isCanonical(r, s));
        } else {
          sig = key.sign(message, { canonical: true });
          r = sig.r.toArrayLike(Uint8Array, "be", 32);
          s = sig.s.toArrayLike(Uint8Array, "be", 32);
        }
        return { type, r, s, recid: sig.recoveryParam || 0 };
      }
      function isCanonical(r, s) {
        return !(r[0] & 128) && !(r[0] === 0 && !(r[1] & 128)) && !(s[0] & 128) && !(s[0] === 0 && !(s[1] & 128));
      }
      function generate(type) {
        const curve = getCurve(type);
        const privkey = curve.genKeyPair().getPrivate();
        return privkey.toArrayLike(Uint8Array, "be");
      }
      var PrivateKey = class {
        constructor(type, data) {
          this.type = type;
          this.data = data;
        }
        static from(value) {
          if (isInstanceOf(value, PrivateKey)) {
            return value;
          } else {
            return this.fromString(value);
          }
        }
        static fromString(string, ignoreChecksumError = false) {
          try {
            const { type, data } = decodeKey(string);
            return new this(type, data);
          } catch (error) {
            error.message = `Invalid private key (${error.message})`;
            if (ignoreChecksumError && isInstanceOf(error, exports.Base58.DecodingError) && error.code === exports.Base58.ErrorCode.E_CHECKSUM) {
              const type = string.startsWith("PVT_R1") ? exports.CurveType.R1 : exports.CurveType.K1;
              let data = new Bytes(error.info.data);
              if (data.array.length == 33) {
                data = data.droppingFirst();
              }
              return new this(type, data);
            }
            throw error;
          }
        }
        static generate(type) {
          return new PrivateKey(exports.CurveType.from(type), new Bytes(generate(type)));
        }
        signDigest(digest) {
          digest = Checksum256.from(digest);
          return Signature.from(sign(this.data.array, digest.array, this.type));
        }
        signMessage(message) {
          return this.signDigest(Checksum256.hash(message));
        }
        sharedSecret(publicKey) {
          const shared = sharedSecret(this.data.array, publicKey.data.array, this.type);
          return Checksum512.hash(shared);
        }
        toPublic() {
          const compressed = getPublic(this.data.array, this.type);
          return PublicKey.from({ compressed, type: this.type });
        }
        toWif() {
          if (this.type !== exports.CurveType.K1) {
            throw new Error("Unable to generate WIF for non-k1 key");
          }
          return exports.Base58.encodeCheck(Bytes.from([128]).appending(this.data));
        }
        toString() {
          return `PVT_${this.type}_${exports.Base58.encodeRipemd160Check(this.data, this.type)}`;
        }
        toJSON() {
          return this.toString();
        }
      };
      function decodeKey(value) {
        const type = typeof value;
        if (type !== "string") {
          throw new Error(`Expected string, got ${type}`);
        }
        if (value.startsWith("PVT_")) {
          const parts = value.split("_");
          if (parts.length !== 3) {
            throw new Error("Invalid PVT format");
          }
          const type2 = exports.CurveType.from(parts[1]);
          let size;
          switch (type2) {
            case exports.CurveType.K1:
            case exports.CurveType.R1:
              size = 32;
              break;
          }
          const data = exports.Base58.decodeRipemd160Check(parts[2], size, type2);
          return { type: type2, data };
        } else {
          const type2 = exports.CurveType.K1;
          const data = exports.Base58.decodeCheck(value);
          if (data.array[0] !== 128) {
            throw new Error("Invalid WIF");
          }
          return { type: type2, data: data.droppingFirst() };
        }
      }
      var PermissionLevel_1;
      exports.PermissionLevel = PermissionLevel_1 = class PermissionLevel extends Struct {
        static from(value) {
          if (typeof value === "string") {
            const parts = value.split("@");
            if (parts.length !== 2 && parts[0].length > 0 && parts[1].length > 0) {
              throw new Error("Invalid permission level string, should be in the format <actor>@<permission>");
            }
            value = { actor: parts[0], permission: parts[1] };
          }
          return super.from(value);
        }
        equals(other) {
          const otherPerm = PermissionLevel_1.from(other);
          return this.actor.equals(otherPerm.actor) && this.permission.equals(otherPerm.permission);
        }
        toString() {
          return `${this.actor}@${this.permission}`;
        }
      };
      tslib.__decorate([
        Struct.field("name")
      ], exports.PermissionLevel.prototype, "actor", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], exports.PermissionLevel.prototype, "permission", void 0);
      exports.PermissionLevel = PermissionLevel_1 = tslib.__decorate([
        Struct.type("permission_level")
      ], exports.PermissionLevel);
      var Action_1;
      exports.Action = Action_1 = class Action extends Struct {
        static from(object, abi) {
          const data = object.data;
          if (!Bytes.isBytes(data)) {
            let type;
            if (abi) {
              type = ABI.from(abi).getActionType(object.name);
            } else if (!data.constructor || data.constructor.abiName === void 0) {
              throw new Error("Missing ABI definition when creating action with untyped action data");
            }
            object = Object.assign(Object.assign({}, object), { data: abiEncode({ object: data, type, abi }) });
          }
          return super.from(object);
        }
        equals(other) {
          const otherAction = Action_1.from(other);
          return this.account.equals(otherAction.account) && this.name.equals(otherAction.name) && arrayEquatableEquals(this.authorization, otherAction.authorization) && this.data.equals(otherAction.data);
        }
        decodeData(typeOrAbi) {
          if (typeof typeOrAbi === "string" || typeOrAbi.abiName) {
            return abiDecode({
              data: this.data,
              type: typeOrAbi
            });
          } else {
            const abi = ABI.from(typeOrAbi);
            const type = abi.getActionType(this.name);
            if (!type) {
              throw new Error(`Action ${this.name} does not exist in provided ABI`);
            }
            return abiDecode({ data: this.data, type, abi });
          }
        }
      };
      tslib.__decorate([
        Struct.field("name")
      ], exports.Action.prototype, "account", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], exports.Action.prototype, "name", void 0);
      tslib.__decorate([
        Struct.field(exports.PermissionLevel, { array: true })
      ], exports.Action.prototype, "authorization", void 0);
      tslib.__decorate([
        Struct.field("bytes")
      ], exports.Action.prototype, "data", void 0);
      exports.Action = Action_1 = tslib.__decorate([
        Struct.type("action")
      ], exports.Action);
      var Transaction_1;
      exports.TransactionExtension = class TransactionExtension extends Struct {
      };
      tslib.__decorate([
        Struct.field("uint16")
      ], exports.TransactionExtension.prototype, "type", void 0);
      tslib.__decorate([
        Struct.field("bytes")
      ], exports.TransactionExtension.prototype, "data", void 0);
      exports.TransactionExtension = tslib.__decorate([
        Struct.type("transaction_extension")
      ], exports.TransactionExtension);
      exports.TransactionHeader = class TransactionHeader extends Struct {
        static from(object) {
          return super.from(object);
        }
      };
      tslib.__decorate([
        Struct.field("time_point_sec")
      ], exports.TransactionHeader.prototype, "expiration", void 0);
      tslib.__decorate([
        Struct.field("uint16")
      ], exports.TransactionHeader.prototype, "ref_block_num", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], exports.TransactionHeader.prototype, "ref_block_prefix", void 0);
      tslib.__decorate([
        Struct.field("varuint32", { default: 0 })
      ], exports.TransactionHeader.prototype, "max_net_usage_words", void 0);
      tslib.__decorate([
        Struct.field("uint8", { default: 0 })
      ], exports.TransactionHeader.prototype, "max_cpu_usage_ms", void 0);
      tslib.__decorate([
        Struct.field("varuint32", { default: 0 })
      ], exports.TransactionHeader.prototype, "delay_sec", void 0);
      exports.TransactionHeader = tslib.__decorate([
        Struct.type("transaction_header")
      ], exports.TransactionHeader);
      exports.Transaction = Transaction_1 = class Transaction extends exports.TransactionHeader {
        static from(object, abis) {
          const abiFor = (contract) => {
            if (!abis) {
              return;
            } else if (Array.isArray(abis)) {
              return abis.filter((abi) => Name.from(abi.contract).equals(contract)).map(({ abi }) => abi)[0];
            } else {
              return abis;
            }
          };
          const resolveAction = (action) => exports.Action.from(action, abiFor(action.account));
          const actions = (object.actions || []).map(resolveAction);
          const context_free_actions = (object.context_free_actions || []).map(resolveAction);
          const transaction = Object.assign(Object.assign({}, object), {
            context_free_actions,
            actions
          });
          return super.from(transaction);
        }
        equals(other) {
          const tx = Transaction_1.from(other);
          return this.id.equals(tx.id);
        }
        get id() {
          return Checksum256.hash(abiEncode({ object: this }));
        }
        signingDigest(chainId) {
          let data = Bytes.from(Checksum256.from(chainId).array);
          data = data.appending(abiEncode({ object: this }));
          data = data.appending(new Uint8Array(32));
          return Checksum256.hash(data);
        }
      };
      tslib.__decorate([
        Struct.field(exports.Action, { array: true, default: [] })
      ], exports.Transaction.prototype, "context_free_actions", void 0);
      tslib.__decorate([
        Struct.field(exports.Action, { array: true, default: [] })
      ], exports.Transaction.prototype, "actions", void 0);
      tslib.__decorate([
        Struct.field(exports.TransactionExtension, { array: true, default: [] })
      ], exports.Transaction.prototype, "transaction_extensions", void 0);
      exports.Transaction = Transaction_1 = tslib.__decorate([
        Struct.type("transaction")
      ], exports.Transaction);
      exports.SignedTransaction = class SignedTransaction extends exports.Transaction {
        static from(object) {
          return super.from(object);
        }
      };
      tslib.__decorate([
        Struct.field("signature[]", { default: [] })
      ], exports.SignedTransaction.prototype, "signatures", void 0);
      tslib.__decorate([
        Struct.field("bytes[]", { default: [] })
      ], exports.SignedTransaction.prototype, "context_free_data", void 0);
      exports.SignedTransaction = tslib.__decorate([
        Struct.type("signed_transaction")
      ], exports.SignedTransaction);
      exports.PackedTransaction = class PackedTransaction extends Struct {
        static fromSigned(signed) {
          const tx = exports.Transaction.from(signed);
          return this.from({
            signatures: signed.signatures,
            packed_context_free_data: abiEncode({
              object: signed.context_free_data,
              type: "bytes[]"
            }),
            packed_trx: abiEncode({ object: tx })
          });
        }
        getTransaction() {
          if (Number(this.compression) !== 0) {
            throw new Error("Transaction compression not supported yet");
          }
          return abiDecode({ data: this.packed_trx, type: exports.Transaction });
        }
        getSignedTransaction() {
          const transaction = this.getTransaction();
          return exports.SignedTransaction.from(Object.assign(Object.assign({}, transaction), { signatures: this.signatures }));
        }
      };
      tslib.__decorate([
        Struct.field("signature[]")
      ], exports.PackedTransaction.prototype, "signatures", void 0);
      tslib.__decorate([
        Struct.field("uint8", { default: 0 })
      ], exports.PackedTransaction.prototype, "compression", void 0);
      tslib.__decorate([
        Struct.field("bytes")
      ], exports.PackedTransaction.prototype, "packed_context_free_data", void 0);
      tslib.__decorate([
        Struct.field("bytes")
      ], exports.PackedTransaction.prototype, "packed_trx", void 0);
      exports.PackedTransaction = tslib.__decorate([
        Struct.type("packed_transaction")
      ], exports.PackedTransaction);
      exports.TransactionReceipt = class TransactionReceipt extends Struct {
      };
      tslib.__decorate([
        Struct.field("string")
      ], exports.TransactionReceipt.prototype, "status", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], exports.TransactionReceipt.prototype, "cpu_usage_us", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], exports.TransactionReceipt.prototype, "net_usage_words", void 0);
      exports.TransactionReceipt = tslib.__decorate([
        Struct.type("transaction_receipt")
      ], exports.TransactionReceipt);
      var Authority_1;
      var Weight = class Weight extends UInt16 {
      };
      Weight = tslib.__decorate([
        TypeAlias("weight_type")
      ], Weight);
      var KeyWeight = class KeyWeight extends Struct {
      };
      tslib.__decorate([
        Struct.field(PublicKey)
      ], KeyWeight.prototype, "key", void 0);
      tslib.__decorate([
        Struct.field(Weight)
      ], KeyWeight.prototype, "weight", void 0);
      KeyWeight = tslib.__decorate([
        Struct.type("key_weight")
      ], KeyWeight);
      var PermissionLevelWeight = class PermissionLevelWeight extends Struct {
      };
      tslib.__decorate([
        Struct.field(exports.PermissionLevel)
      ], PermissionLevelWeight.prototype, "permission", void 0);
      tslib.__decorate([
        Struct.field(Weight)
      ], PermissionLevelWeight.prototype, "weight", void 0);
      PermissionLevelWeight = tslib.__decorate([
        Struct.type("permission_level_weight")
      ], PermissionLevelWeight);
      var WaitWeight = class WaitWeight extends Struct {
      };
      tslib.__decorate([
        Struct.field(UInt32)
      ], WaitWeight.prototype, "wait_sec", void 0);
      tslib.__decorate([
        Struct.field(Weight)
      ], WaitWeight.prototype, "weight", void 0);
      WaitWeight = tslib.__decorate([
        Struct.type("wait_weight")
      ], WaitWeight);
      exports.Authority = Authority_1 = class Authority extends Struct {
        static from(value) {
          if (isInstanceOf(value, Authority_1)) {
            return value;
          }
          const rv = super.from(Object.assign({ keys: [], accounts: [], waits: [] }, value));
          rv.sort();
          return rv;
        }
        get waitThreshold() {
          return this.waits.reduce((val, wait) => val + wait.weight.toNumber(), 0);
        }
        get keyThreshold() {
          return this.threshold.toNumber() - this.waitThreshold;
        }
        keyWeight(publicKey) {
          const weight = this.keys.find(({ key }) => key.equals(publicKey));
          return weight ? weight.weight.toNumber() : 0;
        }
        hasPermission(publicKey, includePartial = false) {
          const threshold = includePartial ? 1 : this.keyThreshold;
          const weight = this.keyWeight(publicKey);
          return weight >= threshold;
        }
        sort() {
          this.keys.sort((a, b) => String(a.key).localeCompare(String(b.key)));
          this.accounts.sort((a, b) => String(a.permission).localeCompare(String(b.permission)));
          this.waits.sort((a, b) => String(a.wait_sec).localeCompare(String(b.wait_sec)));
        }
      };
      tslib.__decorate([
        Struct.field(UInt32)
      ], exports.Authority.prototype, "threshold", void 0);
      tslib.__decorate([
        Struct.field(KeyWeight, { array: true })
      ], exports.Authority.prototype, "keys", void 0);
      tslib.__decorate([
        Struct.field(PermissionLevelWeight, { array: true })
      ], exports.Authority.prototype, "accounts", void 0);
      tslib.__decorate([
        Struct.field(WaitWeight, { array: true })
      ], exports.Authority.prototype, "waits", void 0);
      exports.Authority = Authority_1 = tslib.__decorate([
        Struct.type("authority")
      ], exports.Authority);
      exports.Serializer = void 0;
      (function(Serializer) {
        Serializer.encode = abiEncode;
        Serializer.decode = abiDecode;
        function synthesize(type) {
          return synthesizeABI(type).abi;
        }
        Serializer.synthesize = synthesize;
        function stringify2(object) {
          return JSON.stringify(object);
        }
        Serializer.stringify = stringify2;
        function objectify(object) {
          const walk = (v) => {
            switch (typeof v) {
              case "boolean":
              case "number":
              case "string":
                return v;
              case "object": {
                if (v === null) {
                  return v;
                }
                if (typeof v.toJSON === "function") {
                  return walk(v.toJSON());
                }
                if (Array.isArray(v)) {
                  return v.map(walk);
                }
                const rv = {};
                for (const key of Object.keys(v)) {
                  rv[key] = walk(v[key]);
                }
                return rv;
              }
            }
          };
          return walk(object);
        }
        Serializer.objectify = objectify;
      })(exports.Serializer || (exports.Serializer = {}));
      var FetchProvider = class {
        constructor(url, options = {}) {
          url = url.trim();
          if (url.endsWith("/"))
            url = url.slice(0, -1);
          this.url = url;
          if (!options.fetch) {
            if (typeof window !== "undefined" && window.fetch) {
              this.fetch = window.fetch.bind(window);
            } else if (typeof global !== "undefined" && global.fetch) {
              this.fetch = global.fetch.bind(global);
            } else {
              throw new Error("Missing fetch");
            }
          } else {
            this.fetch = options.fetch;
          }
        }
        call(path, params) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            const url = this.url + path;
            const response = yield this.fetch(url, {
              method: "POST",
              body: params !== void 0 ? JSON.stringify(params) : void 0
            });
            try {
              return response.json();
            } catch (error) {
              if (!response.ok) {
                throw Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              error.message = `Unable to parse JSON response from server: ${error.message}`;
              throw error;
            }
          });
        }
      };
      var AccountPermission = class AccountPermission extends Struct {
      };
      tslib.__decorate([
        Struct.field("name")
      ], AccountPermission.prototype, "perm_name", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], AccountPermission.prototype, "parent", void 0);
      tslib.__decorate([
        Struct.field(exports.Authority)
      ], AccountPermission.prototype, "required_auth", void 0);
      AccountPermission = tslib.__decorate([
        Struct.type("account_permission")
      ], AccountPermission);
      var AccountResourceLimit = class AccountResourceLimit extends Struct {
      };
      tslib.__decorate([
        Struct.field("int64")
      ], AccountResourceLimit.prototype, "used", void 0);
      tslib.__decorate([
        Struct.field("int64")
      ], AccountResourceLimit.prototype, "available", void 0);
      tslib.__decorate([
        Struct.field("int64")
      ], AccountResourceLimit.prototype, "max", void 0);
      AccountResourceLimit = tslib.__decorate([
        Struct.type("account_resource_limit")
      ], AccountResourceLimit);
      var AccountTotalResources = class AccountTotalResources extends Struct {
      };
      tslib.__decorate([
        Struct.field("name")
      ], AccountTotalResources.prototype, "owner", void 0);
      tslib.__decorate([
        Struct.field("asset")
      ], AccountTotalResources.prototype, "net_weight", void 0);
      tslib.__decorate([
        Struct.field("asset")
      ], AccountTotalResources.prototype, "cpu_weight", void 0);
      tslib.__decorate([
        Struct.field("uint64")
      ], AccountTotalResources.prototype, "ram_bytes", void 0);
      AccountTotalResources = tslib.__decorate([
        Struct.type("account_total_resources")
      ], AccountTotalResources);
      var AccountSelfDelegatedBandwidth = class AccountSelfDelegatedBandwidth extends Struct {
      };
      tslib.__decorate([
        Struct.field("name")
      ], AccountSelfDelegatedBandwidth.prototype, "from", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], AccountSelfDelegatedBandwidth.prototype, "to", void 0);
      tslib.__decorate([
        Struct.field("asset")
      ], AccountSelfDelegatedBandwidth.prototype, "net_weight", void 0);
      tslib.__decorate([
        Struct.field("asset")
      ], AccountSelfDelegatedBandwidth.prototype, "cpu_weight", void 0);
      AccountSelfDelegatedBandwidth = tslib.__decorate([
        Struct.type("account_self_delegated_bandwidth")
      ], AccountSelfDelegatedBandwidth);
      var AccountRefundRequest = class AccountRefundRequest extends Struct {
      };
      tslib.__decorate([
        Struct.field("name")
      ], AccountRefundRequest.prototype, "owner", void 0);
      tslib.__decorate([
        Struct.field("time_point")
      ], AccountRefundRequest.prototype, "request_time", void 0);
      tslib.__decorate([
        Struct.field("asset")
      ], AccountRefundRequest.prototype, "net_amount", void 0);
      tslib.__decorate([
        Struct.field("asset")
      ], AccountRefundRequest.prototype, "cpu_amount", void 0);
      AccountRefundRequest = tslib.__decorate([
        Struct.type("account_refund_request")
      ], AccountRefundRequest);
      var AccountVoterInfo = class AccountVoterInfo extends Struct {
      };
      tslib.__decorate([
        Struct.field("name")
      ], AccountVoterInfo.prototype, "owner", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], AccountVoterInfo.prototype, "proxy", void 0);
      tslib.__decorate([
        Struct.field("name", { array: true })
      ], AccountVoterInfo.prototype, "producers", void 0);
      tslib.__decorate([
        Struct.field("int64", { optional: true })
      ], AccountVoterInfo.prototype, "staked", void 0);
      tslib.__decorate([
        Struct.field("bool")
      ], AccountVoterInfo.prototype, "is_proxy", void 0);
      tslib.__decorate([
        Struct.field("uint32", { optional: true })
      ], AccountVoterInfo.prototype, "flags1", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], AccountVoterInfo.prototype, "reserved2", void 0);
      tslib.__decorate([
        Struct.field("string")
      ], AccountVoterInfo.prototype, "reserved3", void 0);
      AccountVoterInfo = tslib.__decorate([
        Struct.type("account_voter_info")
      ], AccountVoterInfo);
      var AccountRexInfoMaturities = class AccountRexInfoMaturities extends Struct {
      };
      tslib.__decorate([
        Struct.field("time_point", { optional: true })
      ], AccountRexInfoMaturities.prototype, "key", void 0);
      tslib.__decorate([
        Struct.field("int64", { optional: true })
      ], AccountRexInfoMaturities.prototype, "value", void 0);
      tslib.__decorate([
        Struct.field("time_point", { optional: true })
      ], AccountRexInfoMaturities.prototype, "first", void 0);
      tslib.__decorate([
        Struct.field("int64", { optional: true })
      ], AccountRexInfoMaturities.prototype, "second", void 0);
      AccountRexInfoMaturities = tslib.__decorate([
        Struct.type("account_rex_info_maturities")
      ], AccountRexInfoMaturities);
      var AccountRexInfo = class AccountRexInfo extends Struct {
      };
      tslib.__decorate([
        Struct.field("uint32")
      ], AccountRexInfo.prototype, "version", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], AccountRexInfo.prototype, "owner", void 0);
      tslib.__decorate([
        Struct.field("asset")
      ], AccountRexInfo.prototype, "vote_stake", void 0);
      tslib.__decorate([
        Struct.field("asset")
      ], AccountRexInfo.prototype, "rex_balance", void 0);
      tslib.__decorate([
        Struct.field("int64")
      ], AccountRexInfo.prototype, "matured_rex", void 0);
      tslib.__decorate([
        Struct.field(AccountRexInfoMaturities, { array: true })
      ], AccountRexInfo.prototype, "rex_maturities", void 0);
      AccountRexInfo = tslib.__decorate([
        Struct.type("account_rex_info")
      ], AccountRexInfo);
      var AccountObject = class AccountObject extends Struct {
        getPermission(permission) {
          const name = Name.from(permission);
          const match = this.permissions.find((p) => p.perm_name.equals(name));
          if (!match) {
            throw new Error(`Unknown permission ${name} on account ${this.account_name}.`);
          }
          return match;
        }
      };
      tslib.__decorate([
        Struct.field("name")
      ], AccountObject.prototype, "account_name", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], AccountObject.prototype, "head_block_num", void 0);
      tslib.__decorate([
        Struct.field("time_point")
      ], AccountObject.prototype, "head_block_time", void 0);
      tslib.__decorate([
        Struct.field("bool")
      ], AccountObject.prototype, "privileged", void 0);
      tslib.__decorate([
        Struct.field("time_point")
      ], AccountObject.prototype, "last_code_update", void 0);
      tslib.__decorate([
        Struct.field("time_point")
      ], AccountObject.prototype, "created", void 0);
      tslib.__decorate([
        Struct.field("asset?")
      ], AccountObject.prototype, "core_liquid_balance", void 0);
      tslib.__decorate([
        Struct.field("int64")
      ], AccountObject.prototype, "ram_quota", void 0);
      tslib.__decorate([
        Struct.field("int64")
      ], AccountObject.prototype, "net_weight", void 0);
      tslib.__decorate([
        Struct.field("int64")
      ], AccountObject.prototype, "cpu_weight", void 0);
      tslib.__decorate([
        Struct.field(AccountResourceLimit)
      ], AccountObject.prototype, "net_limit", void 0);
      tslib.__decorate([
        Struct.field(AccountResourceLimit)
      ], AccountObject.prototype, "cpu_limit", void 0);
      tslib.__decorate([
        Struct.field("uint64")
      ], AccountObject.prototype, "ram_usage", void 0);
      tslib.__decorate([
        Struct.field(AccountPermission, { array: true })
      ], AccountObject.prototype, "permissions", void 0);
      tslib.__decorate([
        Struct.field(AccountTotalResources)
      ], AccountObject.prototype, "total_resources", void 0);
      tslib.__decorate([
        Struct.field(AccountSelfDelegatedBandwidth, { optional: true })
      ], AccountObject.prototype, "self_delegated_bandwidth", void 0);
      tslib.__decorate([
        Struct.field(AccountRefundRequest, { optional: true })
      ], AccountObject.prototype, "refund_request", void 0);
      tslib.__decorate([
        Struct.field(AccountVoterInfo, { optional: true })
      ], AccountObject.prototype, "voter_info", void 0);
      tslib.__decorate([
        Struct.field(AccountRexInfo, { optional: true })
      ], AccountObject.prototype, "rex_info", void 0);
      AccountObject = tslib.__decorate([
        Struct.type("account_object")
      ], AccountObject);
      var NewProducersEntry = class NewProducersEntry extends Struct {
      };
      tslib.__decorate([
        Struct.field("name")
      ], NewProducersEntry.prototype, "producer_name", void 0);
      tslib.__decorate([
        Struct.field("public_key")
      ], NewProducersEntry.prototype, "block_signing_key", void 0);
      NewProducersEntry = tslib.__decorate([
        Struct.type("new_producers_entry")
      ], NewProducersEntry);
      var NewProducers = class NewProducers extends Struct {
      };
      tslib.__decorate([
        Struct.field("uint32")
      ], NewProducers.prototype, "version", void 0);
      tslib.__decorate([
        Struct.field(NewProducersEntry, { array: true })
      ], NewProducers.prototype, "producers", void 0);
      NewProducers = tslib.__decorate([
        Struct.type("new_producers")
      ], NewProducers);
      var BlockExtension = class BlockExtension extends Struct {
      };
      tslib.__decorate([
        Struct.field("uint16")
      ], BlockExtension.prototype, "type", void 0);
      tslib.__decorate([
        Struct.field("bytes")
      ], BlockExtension.prototype, "data", void 0);
      BlockExtension = tslib.__decorate([
        Struct.type("block_extension")
      ], BlockExtension);
      var HeaderExtension = class HeaderExtension extends Struct {
      };
      tslib.__decorate([
        Struct.field("uint16")
      ], HeaderExtension.prototype, "type", void 0);
      tslib.__decorate([
        Struct.field("bytes")
      ], HeaderExtension.prototype, "data", void 0);
      HeaderExtension = tslib.__decorate([
        Struct.type("header_extension")
      ], HeaderExtension);
      var TrxVariant = class {
        constructor(id, extra) {
          this.id = id;
          this.extra = extra;
        }
        static from(data) {
          let id;
          let extra;
          if (typeof data === "string") {
            id = Checksum256.from(data);
            extra = {};
          } else {
            id = Checksum256.from(data.id);
            extra = data;
          }
          return new this(id, extra);
        }
        get transaction() {
          if (this.extra.packed_trx) {
            return exports.Serializer.decode({ data: this.extra.packed_trx, type: exports.Transaction });
          }
        }
        get signatures() {
          if (this.extra.signatures) {
            return this.extra.signatures.map(Signature.from);
          }
        }
        equals(other) {
          return this.id.equals(other.id);
        }
        toJSON() {
          return this.id;
        }
      };
      TrxVariant.abiName = "trx_variant";
      var GetBlockResponseTransactionReceipt = class GetBlockResponseTransactionReceipt extends exports.TransactionReceipt {
        get id() {
          return this.trx.id;
        }
      };
      tslib.__decorate([
        Struct.field(TrxVariant)
      ], GetBlockResponseTransactionReceipt.prototype, "trx", void 0);
      GetBlockResponseTransactionReceipt = tslib.__decorate([
        Struct.type("get_block_response_receipt")
      ], GetBlockResponseTransactionReceipt);
      var GetBlockResponse = class GetBlockResponse extends Struct {
      };
      tslib.__decorate([
        Struct.field("time_point")
      ], GetBlockResponse.prototype, "timestamp", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], GetBlockResponse.prototype, "producer", void 0);
      tslib.__decorate([
        Struct.field("uint16")
      ], GetBlockResponse.prototype, "confirmed", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], GetBlockResponse.prototype, "previous", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], GetBlockResponse.prototype, "transaction_mroot", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], GetBlockResponse.prototype, "action_mroot", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], GetBlockResponse.prototype, "schedule_version", void 0);
      tslib.__decorate([
        Struct.field(NewProducers, { optional: true })
      ], GetBlockResponse.prototype, "new_producers", void 0);
      tslib.__decorate([
        Struct.field("header_extension", { optional: true })
      ], GetBlockResponse.prototype, "header_extensions", void 0);
      tslib.__decorate([
        Struct.field("any", { optional: true })
      ], GetBlockResponse.prototype, "new_protocol_features", void 0);
      tslib.__decorate([
        Struct.field("signature")
      ], GetBlockResponse.prototype, "producer_signature", void 0);
      tslib.__decorate([
        Struct.field(GetBlockResponseTransactionReceipt, { array: true })
      ], GetBlockResponse.prototype, "transactions", void 0);
      tslib.__decorate([
        Struct.field("block_extension", { optional: true })
      ], GetBlockResponse.prototype, "block_extensions", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], GetBlockResponse.prototype, "id", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], GetBlockResponse.prototype, "block_num", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], GetBlockResponse.prototype, "ref_block_prefix", void 0);
      GetBlockResponse = tslib.__decorate([
        Struct.type("get_block_response")
      ], GetBlockResponse);
      var ActiveScheduleProducerAuthority = class ActiveScheduleProducerAuthority extends Struct {
      };
      tslib.__decorate([
        Struct.field("name")
      ], ActiveScheduleProducerAuthority.prototype, "producer_name", void 0);
      tslib.__decorate([
        Struct.field("any")
      ], ActiveScheduleProducerAuthority.prototype, "authority", void 0);
      ActiveScheduleProducerAuthority = tslib.__decorate([
        Struct.type("active_schedule_producer_authority")
      ], ActiveScheduleProducerAuthority);
      var ActiveScheduleProducer = class ActiveScheduleProducer extends Struct {
      };
      tslib.__decorate([
        Struct.field("name")
      ], ActiveScheduleProducer.prototype, "producer_name", void 0);
      tslib.__decorate([
        Struct.field(ActiveScheduleProducerAuthority)
      ], ActiveScheduleProducer.prototype, "authority", void 0);
      ActiveScheduleProducer = tslib.__decorate([
        Struct.type("active_schedule_producer")
      ], ActiveScheduleProducer);
      var ActiveSchedule = class ActiveSchedule extends Struct {
      };
      tslib.__decorate([
        Struct.field("uint32")
      ], ActiveSchedule.prototype, "version", void 0);
      tslib.__decorate([
        Struct.field(ActiveScheduleProducer, { array: true })
      ], ActiveSchedule.prototype, "producers", void 0);
      ActiveSchedule = tslib.__decorate([
        Struct.type("active_schedule")
      ], ActiveSchedule);
      var BlockStateHeader = class BlockStateHeader extends Struct {
      };
      tslib.__decorate([
        Struct.field("time_point")
      ], BlockStateHeader.prototype, "timestamp", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], BlockStateHeader.prototype, "producer", void 0);
      tslib.__decorate([
        Struct.field("uint16")
      ], BlockStateHeader.prototype, "confirmed", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], BlockStateHeader.prototype, "previous", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], BlockStateHeader.prototype, "transaction_mroot", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], BlockStateHeader.prototype, "action_mroot", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], BlockStateHeader.prototype, "schedule_version", void 0);
      tslib.__decorate([
        Struct.field(HeaderExtension, { array: true, optional: true })
      ], BlockStateHeader.prototype, "header_extensions", void 0);
      tslib.__decorate([
        Struct.field("signature")
      ], BlockStateHeader.prototype, "producer_signature", void 0);
      BlockStateHeader = tslib.__decorate([
        Struct.type("block_state_header")
      ], BlockStateHeader);
      var GetBlockHeaderStateResponse = class GetBlockHeaderStateResponse extends Struct {
      };
      tslib.__decorate([
        Struct.field("uint32")
      ], GetBlockHeaderStateResponse.prototype, "block_num", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], GetBlockHeaderStateResponse.prototype, "dpos_proposed_irreversible_blocknum", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], GetBlockHeaderStateResponse.prototype, "dpos_irreversible_blocknum", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], GetBlockHeaderStateResponse.prototype, "id", void 0);
      tslib.__decorate([
        Struct.field(BlockStateHeader)
      ], GetBlockHeaderStateResponse.prototype, "header", void 0);
      tslib.__decorate([
        Struct.field("any")
      ], GetBlockHeaderStateResponse.prototype, "active_schedule", void 0);
      tslib.__decorate([
        Struct.field("any")
      ], GetBlockHeaderStateResponse.prototype, "blockroot_merkle", void 0);
      tslib.__decorate([
        Struct.field("any")
      ], GetBlockHeaderStateResponse.prototype, "producer_to_last_produced", void 0);
      tslib.__decorate([
        Struct.field("any")
      ], GetBlockHeaderStateResponse.prototype, "producer_to_last_implied_irb", void 0);
      tslib.__decorate([
        Struct.field("any")
      ], GetBlockHeaderStateResponse.prototype, "valid_block_signing_authority", void 0);
      tslib.__decorate([
        Struct.field("any")
      ], GetBlockHeaderStateResponse.prototype, "confirm_count", void 0);
      tslib.__decorate([
        Struct.field("any")
      ], GetBlockHeaderStateResponse.prototype, "pending_schedule", void 0);
      tslib.__decorate([
        Struct.field("any")
      ], GetBlockHeaderStateResponse.prototype, "activated_protocol_features", void 0);
      tslib.__decorate([
        Struct.field("any")
      ], GetBlockHeaderStateResponse.prototype, "additional_signatures", void 0);
      GetBlockHeaderStateResponse = tslib.__decorate([
        Struct.type("get_block_header_state_response")
      ], GetBlockHeaderStateResponse);
      var GetInfoResponse = class GetInfoResponse extends Struct {
        getTransactionHeader(secondsAhead = 120) {
          const expiration = TimePointSec.fromMilliseconds(this.head_block_time.toMilliseconds() + secondsAhead * 1e3);
          const id = this.last_irreversible_block_id;
          const prefixArray = id.array.subarray(8, 12);
          const prefix = new Uint32Array(prefixArray.buffer, prefixArray.byteOffset, 1)[0];
          return exports.TransactionHeader.from({
            expiration,
            ref_block_num: Number(this.last_irreversible_block_num) & 65535,
            ref_block_prefix: prefix
          });
        }
      };
      tslib.__decorate([
        Struct.field("string")
      ], GetInfoResponse.prototype, "server_version", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], GetInfoResponse.prototype, "chain_id", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], GetInfoResponse.prototype, "head_block_num", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], GetInfoResponse.prototype, "last_irreversible_block_num", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], GetInfoResponse.prototype, "last_irreversible_block_id", void 0);
      tslib.__decorate([
        Struct.field("checksum256")
      ], GetInfoResponse.prototype, "head_block_id", void 0);
      tslib.__decorate([
        Struct.field("time_point")
      ], GetInfoResponse.prototype, "head_block_time", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], GetInfoResponse.prototype, "head_block_producer", void 0);
      tslib.__decorate([
        Struct.field("uint64")
      ], GetInfoResponse.prototype, "virtual_block_cpu_limit", void 0);
      tslib.__decorate([
        Struct.field("uint64")
      ], GetInfoResponse.prototype, "virtual_block_net_limit", void 0);
      tslib.__decorate([
        Struct.field("uint64")
      ], GetInfoResponse.prototype, "block_cpu_limit", void 0);
      tslib.__decorate([
        Struct.field("uint64")
      ], GetInfoResponse.prototype, "block_net_limit", void 0);
      tslib.__decorate([
        Struct.field("string?")
      ], GetInfoResponse.prototype, "server_version_string", void 0);
      tslib.__decorate([
        Struct.field("uint32?")
      ], GetInfoResponse.prototype, "fork_db_head_block_num", void 0);
      tslib.__decorate([
        Struct.field("checksum256?")
      ], GetInfoResponse.prototype, "fork_db_head_block_id", void 0);
      GetInfoResponse = tslib.__decorate([
        Struct.type("get_info_response")
      ], GetInfoResponse);
      var GetTableByScopeResponseRow = class GetTableByScopeResponseRow extends Struct {
      };
      tslib.__decorate([
        Struct.field("name")
      ], GetTableByScopeResponseRow.prototype, "code", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], GetTableByScopeResponseRow.prototype, "scope", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], GetTableByScopeResponseRow.prototype, "table", void 0);
      tslib.__decorate([
        Struct.field("name")
      ], GetTableByScopeResponseRow.prototype, "payer", void 0);
      tslib.__decorate([
        Struct.field("uint32")
      ], GetTableByScopeResponseRow.prototype, "count", void 0);
      GetTableByScopeResponseRow = tslib.__decorate([
        Struct.type("get_table_by_scope_response_row")
      ], GetTableByScopeResponseRow);
      var GetTableByScopeResponse = class GetTableByScopeResponse extends Struct {
      };
      tslib.__decorate([
        Struct.field(GetTableByScopeResponseRow, { array: true })
      ], GetTableByScopeResponse.prototype, "rows", void 0);
      tslib.__decorate([
        Struct.field("string")
      ], GetTableByScopeResponse.prototype, "more", void 0);
      GetTableByScopeResponse = tslib.__decorate([
        Struct.type("get_table_by_scope_response")
      ], GetTableByScopeResponse);
      var types$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        get AccountPermission() {
          return AccountPermission;
        },
        get AccountResourceLimit() {
          return AccountResourceLimit;
        },
        get AccountTotalResources() {
          return AccountTotalResources;
        },
        get AccountSelfDelegatedBandwidth() {
          return AccountSelfDelegatedBandwidth;
        },
        get AccountRefundRequest() {
          return AccountRefundRequest;
        },
        get AccountVoterInfo() {
          return AccountVoterInfo;
        },
        get AccountRexInfoMaturities() {
          return AccountRexInfoMaturities;
        },
        get AccountRexInfo() {
          return AccountRexInfo;
        },
        get AccountObject() {
          return AccountObject;
        },
        get NewProducersEntry() {
          return NewProducersEntry;
        },
        get NewProducers() {
          return NewProducers;
        },
        get BlockExtension() {
          return BlockExtension;
        },
        get HeaderExtension() {
          return HeaderExtension;
        },
        TrxVariant,
        get GetBlockResponseTransactionReceipt() {
          return GetBlockResponseTransactionReceipt;
        },
        get GetBlockResponse() {
          return GetBlockResponse;
        },
        get ActiveScheduleProducerAuthority() {
          return ActiveScheduleProducerAuthority;
        },
        get ActiveScheduleProducer() {
          return ActiveScheduleProducer;
        },
        get ActiveSchedule() {
          return ActiveSchedule;
        },
        get BlockStateHeader() {
          return BlockStateHeader;
        },
        get GetBlockHeaderStateResponse() {
          return GetBlockHeaderStateResponse;
        },
        get GetInfoResponse() {
          return GetInfoResponse;
        },
        get GetTableByScopeResponseRow() {
          return GetTableByScopeResponseRow;
        },
        get GetTableByScopeResponse() {
          return GetTableByScopeResponse;
        }
      });
      var ChainAPI = class {
        constructor(client) {
          this.client = client;
        }
        get_abi(accountName) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.client.call({
              path: "/v1/chain/get_abi",
              params: { account_name: Name.from(accountName) }
            });
          });
        }
        get_account(accountName) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.client.call({
              path: "/v1/chain/get_account",
              params: { account_name: Name.from(accountName) },
              responseType: AccountObject
            });
          });
        }
        get_block(block_num_or_id) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.client.call({
              path: "/v1/chain/get_block",
              params: { block_num_or_id },
              responseType: GetBlockResponse
            });
          });
        }
        get_block_header_state(block_num_or_id) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.client.call({
              path: "/v1/chain/get_block_header_state",
              params: { block_num_or_id },
              responseType: GetBlockHeaderStateResponse
            });
          });
        }
        get_currency_balance(contract, accountName, symbol) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            const params = {
              account: Name.from(accountName),
              code: Name.from(contract)
            };
            if (symbol) {
              params.symbol = symbol;
            }
            return this.client.call({
              path: "/v1/chain/get_currency_balance",
              params,
              responseType: "asset[]"
            });
          });
        }
        get_info() {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.client.call({
              path: "/v1/chain/get_info",
              responseType: GetInfoResponse
            });
          });
        }
        push_transaction(tx) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!isInstanceOf(tx, exports.PackedTransaction)) {
              tx = exports.PackedTransaction.fromSigned(exports.SignedTransaction.from(tx));
            }
            return this.client.call({
              path: "/v1/chain/push_transaction",
              params: tx
            });
          });
        }
        get_table_rows(params) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            const type = params.type;
            let key_type = params.key_type;
            const someBound = params.lower_bound || params.upper_bound;
            if (!key_type && someBound) {
              if (isInstanceOf(someBound, UInt64)) {
                key_type = "i64";
              } else if (isInstanceOf(someBound, UInt128)) {
                key_type = "i128";
              } else if (isInstanceOf(someBound, Checksum256)) {
                key_type = "sha256";
              } else if (isInstanceOf(someBound, Checksum160)) {
                key_type = "ripemd160";
              }
            }
            if (!key_type) {
              key_type = "name";
            }
            let json = params.json;
            if (json === void 0) {
              json = type === void 0;
            }
            let upper_bound = params.upper_bound;
            if (upper_bound && typeof upper_bound !== "string") {
              upper_bound = String(upper_bound);
            }
            let lower_bound = params.lower_bound;
            if (lower_bound && typeof lower_bound !== "string") {
              lower_bound = String(lower_bound);
            }
            let scope = params.scope;
            if (typeof scope === "undefined") {
              scope = String(Name.from(params.code));
            } else if (typeof scope !== "string") {
              scope = String(scope);
            }
            let { rows, more, next_key } = yield this.client.call({
              path: "/v1/chain/get_table_rows",
              params: Object.assign(Object.assign({}, params), {
                code: Name.from(params.code),
                table: Name.from(params.table),
                limit: params.limit !== void 0 ? UInt32.from(params.limit) : void 0,
                scope,
                key_type,
                json,
                upper_bound,
                lower_bound
              })
            });
            let ram_payers;
            if (params.show_payer) {
              ram_payers = [];
              rows = rows.map(({ data, payer }) => {
                ram_payers.push(Name.from(payer));
                return data;
              });
            }
            if (type) {
              if (json) {
                rows = rows.map((value) => {
                  if (typeof value === "string" && Bytes.isBytes(value)) {
                    return exports.Serializer.decode({ data: Bytes.from(value), type });
                  } else {
                    return exports.Serializer.decode({ object: value, type });
                  }
                });
              } else {
                rows = rows.map((hex) => Bytes.from(hex)).map((data) => exports.Serializer.decode({ data, type }));
              }
            }
            if (next_key && next_key.length > 0) {
              let indexType;
              switch (key_type) {
                case "i64":
                  indexType = UInt64;
                  break;
                case "i128":
                  indexType = UInt128;
                  break;
                case "name":
                  indexType = Name;
                  break;
                case "float64":
                  indexType = Float64;
                  break;
                case "float128":
                  indexType = Float128;
                  break;
                case "sha256":
                  indexType = Checksum256;
                  break;
                case "ripemd160":
                  indexType = Checksum160;
                  break;
                default:
                  throw new Error(`Unsupported key type: ${key_type}`);
              }
              if (indexType === Name) {
                next_key = Name.from(exports.Serializer.decode({ object: next_key, type: UInt64 }));
              } else {
                next_key = exports.Serializer.decode({ object: next_key, type: indexType });
              }
            } else {
              next_key = void 0;
            }
            return { rows, more, next_key, ram_payers };
          });
        }
        get_table_by_scope(params) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.client.call({
              path: "/v1/chain/get_table_by_scope",
              params,
              responseType: GetTableByScopeResponse
            });
          });
        }
      };
      var APIError = class extends Error {
        constructor(path, error) {
          super(`${APIError.formatError(error)} at ${path}`);
          this.path = path;
          this.error = error;
        }
        static formatError(error) {
          if (error.what === "unspecified" && error.details && error.details.length > 0) {
            return error.details[0].message;
          } else if (error.what && error.what.length > 0) {
            return error.what;
          } else {
            return "Unknown API error";
          }
        }
        get name() {
          return this.error.name || "unspecified";
        }
        get code() {
          return this.error.code || 0;
        }
        get details() {
          return this.error.details;
        }
      };
      APIError.__className = "APIError";
      var APIClient = class {
        constructor(options) {
          this.v1 = {
            chain: new ChainAPI(this)
          };
          if (options.provider) {
            this.provider = options.provider;
          } else if (options.url) {
            this.provider = new FetchProvider(options.url, options);
          } else {
            throw new Error("Missing url or provider");
          }
        }
        call(args) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.provider.call(args.path, args.params);
            if (response.error) {
              throw new APIError(args.path, response.error);
            }
            if (args.responseType) {
              return abiDecode({ type: args.responseType, object: response });
            }
            return response;
          });
        }
      };
      APIClient.__className = "APIClient";
      var types = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        v1: types$1
      });
      exports.ABI = ABI;
      exports.ABIDecoder = ABIDecoder;
      exports.ABIEncoder = ABIEncoder;
      exports.API = types;
      exports.APIClient = APIClient;
      exports.APIError = APIError;
      exports.Asset = Asset;
      exports.BlockTimestamp = BlockTimestamp;
      exports.Bytes = Bytes;
      exports.Checksum160 = Checksum160;
      exports.Checksum256 = Checksum256;
      exports.Checksum512 = Checksum512;
      exports.ExtendedAsset = ExtendedAsset;
      exports.FetchProvider = FetchProvider;
      exports.Float128 = Float128;
      exports.Float32 = Float32;
      exports.Float64 = Float64;
      exports.Int = Int;
      exports.Int128 = Int128;
      exports.Int16 = Int16;
      exports.Int32 = Int32;
      exports.Int64 = Int64;
      exports.Int8 = Int8;
      exports.Name = Name;
      exports.PrivateKey = PrivateKey;
      exports.PublicKey = PublicKey;
      exports.Signature = Signature;
      exports.Struct = Struct;
      exports.TimePoint = TimePoint;
      exports.TimePointSec = TimePointSec;
      exports.TypeAlias = TypeAlias;
      exports.UInt128 = UInt128;
      exports.UInt16 = UInt16;
      exports.UInt32 = UInt32;
      exports.UInt64 = UInt64;
      exports.UInt8 = UInt8;
      exports.VarInt = VarInt;
      exports.VarUInt = VarUInt;
      exports.Variant = Variant;
      exports.isInstanceOf = isInstanceOf;
    }
  });

  // node_modules/eosio-signing-request/lib/esr.js
  var require_esr = __commonJS({
    "node_modules/eosio-signing-request/lib/esr.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib = require_tslib();
      var eosio = require_eosio_core();
      var baseCharset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      var lookup = new Uint8Array(256);
      for (let i = 0; i < 62; i++) {
        lookup[baseCharset.charCodeAt(i)] = i;
      }
      lookup[43] = lookup[45] = 62;
      lookup[47] = lookup[95] = 63;
      function encode(data, urlSafe = true) {
        const byteLength = data.byteLength;
        const byteRemainder = byteLength % 3;
        const mainLength = byteLength - byteRemainder;
        const charset = baseCharset + (urlSafe ? "-_" : "+/");
        const parts = [];
        let a;
        let b;
        let c;
        let d;
        let chunk;
        for (let i = 0; i < mainLength; i += 3) {
          chunk = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
          a = (chunk & 16515072) >> 18;
          b = (chunk & 258048) >> 12;
          c = (chunk & 4032) >> 6;
          d = chunk & 63;
          parts.push(charset[a] + charset[b] + charset[c] + charset[d]);
        }
        if (byteRemainder === 1) {
          chunk = data[mainLength];
          a = (chunk & 252) >> 2;
          b = (chunk & 3) << 4;
          parts.push(charset[a] + charset[b]);
        } else if (byteRemainder === 2) {
          chunk = data[mainLength] << 8 | data[mainLength + 1];
          a = (chunk & 64512) >> 10;
          b = (chunk & 1008) >> 4;
          c = (chunk & 15) << 2;
          parts.push(charset[a] + charset[b] + charset[c]);
        }
        return parts.join("");
      }
      function decode(input) {
        const byteLength = input.length * 0.75;
        const data = new Uint8Array(byteLength);
        let a;
        let b;
        let c;
        let d;
        let p = 0;
        for (let i = 0; i < input.length; i += 4) {
          a = lookup[input.charCodeAt(i)];
          b = lookup[input.charCodeAt(i + 1)];
          c = lookup[input.charCodeAt(i + 2)];
          d = lookup[input.charCodeAt(i + 3)];
          data[p++] = a << 2 | b >> 4;
          data[p++] = (b & 15) << 4 | c >> 2;
          data[p++] = (c & 3) << 6 | d & 63;
        }
        return data;
      }
      var base64u = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        encode,
        decode
      });
      exports.ChainName = void 0;
      (function(ChainName) {
        ChainName[ChainName["UNKNOWN"] = 0] = "UNKNOWN";
        ChainName[ChainName["EOS"] = 1] = "EOS";
        ChainName[ChainName["TELOS"] = 2] = "TELOS";
        ChainName[ChainName["JUNGLE"] = 3] = "JUNGLE";
        ChainName[ChainName["KYLIN"] = 4] = "KYLIN";
        ChainName[ChainName["WORBLI"] = 5] = "WORBLI";
        ChainName[ChainName["BOS"] = 6] = "BOS";
        ChainName[ChainName["MEETONE"] = 7] = "MEETONE";
        ChainName[ChainName["INSIGHTS"] = 8] = "INSIGHTS";
        ChainName[ChainName["BEOS"] = 9] = "BEOS";
        ChainName[ChainName["WAX"] = 10] = "WAX";
        ChainName[ChainName["PROTON"] = 11] = "PROTON";
        ChainName[ChainName["FIO"] = 12] = "FIO";
      })(exports.ChainName || (exports.ChainName = {}));
      exports.ChainId = class ChainId extends eosio.Checksum256 {
        static from(value) {
          if (eosio.isInstanceOf(value, this)) {
            return value;
          }
          if (typeof value === "number") {
            value = ChainIdLookup.get(value);
            if (!value) {
              throw new Error("Unknown chain id alias");
            }
          }
          return super.from(value);
        }
        get chainVariant() {
          const name = this.chainName;
          if (name !== exports.ChainName.UNKNOWN) {
            return exports.ChainIdVariant.from(["chain_alias", name]);
          }
          return exports.ChainIdVariant.from(this);
        }
        get chainName() {
          const cid = this.hexString;
          for (const [n, id] of ChainIdLookup) {
            if (id === cid) {
              return n;
            }
          }
          return exports.ChainName.UNKNOWN;
        }
      };
      exports.ChainId = tslib.__decorate([
        eosio.TypeAlias("chain_id")
      ], exports.ChainId);
      exports.ChainAlias = class ChainAlias extends eosio.UInt8 {
      };
      exports.ChainAlias = tslib.__decorate([
        eosio.TypeAlias("chain_alias")
      ], exports.ChainAlias);
      exports.ChainIdVariant = class ChainIdVariant extends eosio.Variant {
        get chainId() {
          if (eosio.isInstanceOf(this.value, exports.ChainId)) {
            return this.value;
          }
          return exports.ChainId.from(Number(this.value.value));
        }
      };
      exports.ChainIdVariant = tslib.__decorate([
        eosio.Variant.type("variant_id", [exports.ChainAlias, exports.ChainId])
      ], exports.ChainIdVariant);
      var ChainIdLookup = new Map([
        [exports.ChainName.EOS, "aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906"],
        [exports.ChainName.TELOS, "4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11"],
        [exports.ChainName.JUNGLE, "e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473"],
        [exports.ChainName.KYLIN, "5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191"],
        [exports.ChainName.WORBLI, "73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f"],
        [exports.ChainName.BOS, "d5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86"],
        [exports.ChainName.MEETONE, "cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422"],
        [exports.ChainName.INSIGHTS, "b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664"],
        [exports.ChainName.BEOS, "b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4"],
        [exports.ChainName.WAX, "1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4"],
        [exports.ChainName.PROTON, "384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0"],
        [exports.ChainName.FIO, "21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c"]
      ]);
      var RequestFlags_1;
      exports.AccountName = class AccountName extends eosio.Name {
      };
      exports.AccountName = tslib.__decorate([
        eosio.TypeAlias("account_name")
      ], exports.AccountName);
      exports.PermissionName = class PermissionName extends eosio.Name {
      };
      exports.PermissionName = tslib.__decorate([
        eosio.TypeAlias("permission_name")
      ], exports.PermissionName);
      exports.IdentityV2 = class IdentityV2 extends eosio.Struct {
      };
      tslib.__decorate([
        eosio.Struct.field(eosio.PermissionLevel, { optional: true })
      ], exports.IdentityV2.prototype, "permission", void 0);
      exports.IdentityV2 = tslib.__decorate([
        eosio.Struct.type("identity")
      ], exports.IdentityV2);
      exports.IdentityV3 = class IdentityV3 extends eosio.Struct {
      };
      tslib.__decorate([
        eosio.Struct.field("name")
      ], exports.IdentityV3.prototype, "scope", void 0);
      tslib.__decorate([
        eosio.Struct.field(eosio.PermissionLevel, { optional: true })
      ], exports.IdentityV3.prototype, "permission", void 0);
      exports.IdentityV3 = tslib.__decorate([
        eosio.Struct.type("identity")
      ], exports.IdentityV3);
      exports.RequestVariantV2 = class RequestVariantV2 extends eosio.Variant {
      };
      exports.RequestVariantV2 = tslib.__decorate([
        eosio.Variant.type("variant_req", [eosio.Action, { type: eosio.Action, array: true }, eosio.Transaction, exports.IdentityV2])
      ], exports.RequestVariantV2);
      exports.RequestVariantV3 = class RequestVariantV3 extends eosio.Variant {
      };
      exports.RequestVariantV3 = tslib.__decorate([
        eosio.Variant.type("variant_req", [eosio.Action, { type: eosio.Action, array: true }, eosio.Transaction, exports.IdentityV3])
      ], exports.RequestVariantV3);
      exports.RequestFlags = RequestFlags_1 = class RequestFlags extends eosio.UInt8 {
        get broadcast() {
          return (Number(this) & RequestFlags_1.broadcast) !== 0;
        }
        set broadcast(enabled) {
          this.setFlag(RequestFlags_1.broadcast, enabled);
        }
        get background() {
          return (Number(this) & RequestFlags_1.background) !== 0;
        }
        set background(enabled) {
          this.setFlag(RequestFlags_1.background, enabled);
        }
        setFlag(flag, enabled) {
          if (enabled) {
            this.value = eosio.UInt8.from(Number(this) | flag).value;
          } else {
            this.value.imaskn(flag);
          }
        }
      };
      exports.RequestFlags.broadcast = 1 << 0;
      exports.RequestFlags.background = 1 << 1;
      exports.RequestFlags = RequestFlags_1 = tslib.__decorate([
        eosio.TypeAlias("request_flags")
      ], exports.RequestFlags);
      exports.InfoPair = class InfoPair extends eosio.Struct {
      };
      tslib.__decorate([
        eosio.Struct.field("string")
      ], exports.InfoPair.prototype, "key", void 0);
      tslib.__decorate([
        eosio.Struct.field("bytes")
      ], exports.InfoPair.prototype, "value", void 0);
      exports.InfoPair = tslib.__decorate([
        eosio.Struct.type("info_pair")
      ], exports.InfoPair);
      exports.RequestDataV2 = class RequestDataV2 extends eosio.Struct {
      };
      tslib.__decorate([
        eosio.Struct.field(exports.ChainIdVariant)
      ], exports.RequestDataV2.prototype, "chain_id", void 0);
      tslib.__decorate([
        eosio.Struct.field(exports.RequestVariantV2)
      ], exports.RequestDataV2.prototype, "req", void 0);
      tslib.__decorate([
        eosio.Struct.field(exports.RequestFlags)
      ], exports.RequestDataV2.prototype, "flags", void 0);
      tslib.__decorate([
        eosio.Struct.field("string")
      ], exports.RequestDataV2.prototype, "callback", void 0);
      tslib.__decorate([
        eosio.Struct.field(exports.InfoPair, { array: true })
      ], exports.RequestDataV2.prototype, "info", void 0);
      exports.RequestDataV2 = tslib.__decorate([
        eosio.Struct.type("signing_request")
      ], exports.RequestDataV2);
      exports.RequestDataV3 = class RequestDataV3 extends eosio.Struct {
      };
      tslib.__decorate([
        eosio.Struct.field(exports.ChainIdVariant)
      ], exports.RequestDataV3.prototype, "chain_id", void 0);
      tslib.__decorate([
        eosio.Struct.field(exports.RequestVariantV3)
      ], exports.RequestDataV3.prototype, "req", void 0);
      tslib.__decorate([
        eosio.Struct.field(exports.RequestFlags)
      ], exports.RequestDataV3.prototype, "flags", void 0);
      tslib.__decorate([
        eosio.Struct.field("string")
      ], exports.RequestDataV3.prototype, "callback", void 0);
      tslib.__decorate([
        eosio.Struct.field(exports.InfoPair, { array: true })
      ], exports.RequestDataV3.prototype, "info", void 0);
      exports.RequestDataV3 = tslib.__decorate([
        eosio.Struct.type("signing_request")
      ], exports.RequestDataV3);
      exports.RequestSignature = class RequestSignature extends eosio.Struct {
      };
      tslib.__decorate([
        eosio.Struct.field("name")
      ], exports.RequestSignature.prototype, "signer", void 0);
      tslib.__decorate([
        eosio.Struct.field("signature")
      ], exports.RequestSignature.prototype, "signature", void 0);
      exports.RequestSignature = tslib.__decorate([
        eosio.Struct.type("request_signature")
      ], exports.RequestSignature);
      var IdentityProof_1;
      exports.IdentityProof = IdentityProof_1 = class IdentityProof extends eosio.Struct {
        static from(value) {
          if (eosio.isInstanceOf(value, IdentityProof_1)) {
            return value;
          } else if (typeof value === "string") {
            return IdentityProof_1.fromString(value);
          } else {
            return super.from(value);
          }
        }
        static fromString(string) {
          const parts = string.split(" ");
          if (parts.length !== 2 || parts[0] !== "EOSIO") {
            throw new Error("Invalid IdentityProof string");
          }
          const data = decode(parts[1]);
          return eosio.Serializer.decode({ data, type: IdentityProof_1 });
        }
        static fromPayload(payload, options = {}) {
          const request = SigningRequest.from(payload.req, options);
          if (!(request.version >= 3 && request.isIdentity())) {
            throw new Error("Not an identity request");
          }
          return this.from({
            chainId: payload.cid || request.getChainId(),
            scope: request.getIdentityScope(),
            expiration: payload.ex,
            signer: { actor: payload.sa, permission: payload.sp },
            signature: payload.sig
          });
        }
        get transaction() {
          const action = eosio.Action.from({
            account: "",
            name: "identity",
            authorization: [this.signer],
            data: exports.IdentityV3.from({ scope: this.scope, permission: this.signer })
          });
          return eosio.Transaction.from({
            ref_block_num: 0,
            ref_block_prefix: 0,
            expiration: this.expiration,
            actions: [action]
          });
        }
        recover() {
          return this.signature.recoverDigest(this.transaction.signingDigest(this.chainId));
        }
        verify(auth, currentTime) {
          const now = eosio.TimePointSec.from(currentTime || new Date()).toMilliseconds();
          return now < this.expiration.toMilliseconds() && eosio.Authority.from(auth).hasPermission(this.recover());
        }
        toString() {
          const data = eosio.Serializer.encode({ object: this });
          return `EOSIO ${encode(data.array, false)}`;
        }
      };
      tslib.__decorate([
        eosio.Struct.field(exports.ChainId)
      ], exports.IdentityProof.prototype, "chainId", void 0);
      tslib.__decorate([
        eosio.Struct.field(eosio.Name)
      ], exports.IdentityProof.prototype, "scope", void 0);
      tslib.__decorate([
        eosio.Struct.field(eosio.TimePointSec)
      ], exports.IdentityProof.prototype, "expiration", void 0);
      tslib.__decorate([
        eosio.Struct.field(eosio.PermissionLevel)
      ], exports.IdentityProof.prototype, "signer", void 0);
      tslib.__decorate([
        eosio.Struct.field(eosio.Signature)
      ], exports.IdentityProof.prototype, "signature", void 0);
      exports.IdentityProof = IdentityProof_1 = tslib.__decorate([
        eosio.Struct.type("identity_proof")
      ], exports.IdentityProof);
      var ProtocolVersion = 3;
      var PlaceholderName = eosio.Name.from("............1");
      var PlaceholderPermission = eosio.Name.from("............2");
      var PlaceholderAuth = eosio.PermissionLevel.from({
        actor: PlaceholderName,
        permission: PlaceholderPermission
      });
      var SigningRequest = class {
        constructor(version2, data, zlib, abiProvider, signature) {
          if (data.flags.broadcast && data.req.variantName === "identity") {
            throw new Error("Invalid request (identity request cannot be broadcast)");
          }
          this.version = version2;
          this.data = data;
          this.zlib = zlib;
          this.abiProvider = abiProvider;
          this.signature = signature;
        }
        static identityAbi(version2) {
          const abi = eosio.Serializer.synthesize(this.identityType(version2));
          abi.actions = [{ name: "identity", type: "identity", ricardian_contract: "" }];
          return abi;
        }
        static identityType(version2) {
          return version2 === 2 ? exports.IdentityV2 : exports.IdentityV3;
        }
        static storageType(version2) {
          return version2 === 2 ? exports.RequestDataV2 : exports.RequestDataV3;
        }
        static create(args, options = {}) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            let actions;
            if (args.action) {
              actions = [args.action];
            } else if (args.actions) {
              actions = args.actions;
            } else if (args.transaction) {
              actions = args.transaction.actions || [];
            } else {
              actions = [];
            }
            const requiredAbis = actions.filter((action) => !eosio.Bytes.isBytes(action.data) && action.data.constructor.abiName === void 0).map((action) => eosio.Name.from(action.account));
            const abis = {};
            if (requiredAbis.length > 0) {
              const provider = options.abiProvider;
              if (!provider) {
                throw new Error("Missing abi provider");
              }
              const accountAbis = yield Promise.all(requiredAbis.map((account) => provider.getAbi(account)));
              for (const [idx, abi] of accountAbis.entries()) {
                abis[requiredAbis[idx].toString()] = abi;
              }
            }
            return this.createSync(args, options, abis);
          });
        }
        static createSync(args, options = {}, abis = {}) {
          let version2 = 2;
          const data = {};
          const encode2 = (action) => encodeAction(action, abis);
          if (args.chainId === null) {
            version2 = 3;
          }
          if (args.identity !== void 0) {
            if (args.identity.scope) {
              version2 = 3;
            }
            data.req = ["identity", this.identityType(version2).from(args.identity)];
          } else if (args.action && !args.actions && !args.transaction) {
            data.req = ["action", encode2(args.action)];
          } else if (args.actions && !args.action && !args.transaction) {
            if (args.actions.length === 1) {
              data.req = ["action", encode2(args.actions[0])];
            } else {
              data.req = ["action[]", args.actions.map(encode2)];
            }
          } else if (args.transaction && !args.action && !args.actions) {
            const tx = args.transaction;
            if (tx.expiration === void 0) {
              tx.expiration = "1970-01-01T00:00:00.000";
            }
            if (tx.ref_block_num === void 0) {
              tx.ref_block_num = 0;
            }
            if (tx.ref_block_prefix === void 0) {
              tx.ref_block_prefix = 0;
            }
            if (tx.context_free_actions === void 0) {
              tx.context_free_actions = [];
            }
            if (tx.transaction_extensions === void 0) {
              tx.transaction_extensions = [];
            }
            if (tx.delay_sec === void 0) {
              tx.delay_sec = 0;
            }
            if (tx.max_cpu_usage_ms === void 0) {
              tx.max_cpu_usage_ms = 0;
            }
            if (tx.max_net_usage_words === void 0) {
              tx.max_net_usage_words = 0;
            }
            if (tx.actions === void 0) {
              tx.actions = [];
            }
            if (tx.context_free_actions === void 0) {
              tx.context_free_actions = [];
            }
            tx.actions = tx.actions.map(encode2);
            data.req = ["transaction", tx];
          } else {
            throw new TypeError("Invalid arguments: Must have exactly one of action, actions or transaction");
          }
          if (args.chainId === null) {
            data.chain_id = exports.ChainIdVariant.from(["chain_alias", 0]);
          } else {
            data.chain_id = exports.ChainId.from(args.chainId || exports.ChainName.EOS).chainVariant;
          }
          const flags = exports.RequestFlags.from(0);
          let callback = "";
          flags.broadcast = args.broadcast !== void 0 ? args.broadcast : data.req[0] !== "identity";
          if (typeof args.callback === "string") {
            callback = args.callback;
          } else if (typeof args.callback === "object") {
            callback = args.callback.url;
            flags.background = args.callback.background || false;
          }
          data.flags = flags;
          data.callback = callback;
          data.info = [];
          if (typeof args.info === "object") {
            for (const key in args.info) {
              const isOwn = Object.prototype.hasOwnProperty.call(args.info, key);
              if (isOwn) {
                let value = args.info[key];
                if (typeof value === "string") {
                  value = eosio.Bytes.from(value, "utf8");
                } else if (!(value instanceof eosio.Bytes)) {
                  value = eosio.Serializer.encode({ object: value });
                }
                data.info.push({ key, value });
              }
            }
          }
          if (args.chainIds && args.chainId === null) {
            const ids = args.chainIds.map((id) => exports.ChainId.from(id).chainVariant);
            data.info.push({
              key: "chain_ids",
              value: eosio.Serializer.encode({ object: ids, type: { type: exports.ChainIdVariant, array: true } })
            });
          }
          const req = new SigningRequest(version2, this.storageType(version2).from(data), options.zlib, options.abiProvider);
          if (options.signatureProvider) {
            req.sign(options.signatureProvider);
          }
          return req;
        }
        static identity(args, options = {}) {
          let permission = {
            actor: args.account || PlaceholderName,
            permission: args.permission || PlaceholderPermission
          };
          if (permission.actor === PlaceholderName && permission.permission === PlaceholderPermission) {
            permission = void 0;
          }
          return this.createSync(Object.assign(Object.assign({}, args), { identity: {
            permission,
            scope: args.scope
          }, broadcast: false }), options);
        }
        static fromTransaction(chainId, serializedTransaction, options = {}) {
          const id = exports.ChainId.from(chainId);
          serializedTransaction = eosio.Bytes.from(serializedTransaction);
          const encoder = new eosio.ABIEncoder();
          encoder.writeByte(2);
          encoder.writeArray(eosio.Serializer.encode({ object: id.chainVariant }).array);
          encoder.writeByte(2);
          encoder.writeArray(eosio.Bytes.from(serializedTransaction).array);
          encoder.writeByte(exports.RequestFlags.broadcast);
          encoder.writeByte(0);
          encoder.writeByte(0);
          return SigningRequest.fromData(encoder.getData(), options);
        }
        static from(uri, options = {}) {
          if (typeof uri !== "string") {
            throw new Error("Invalid request uri");
          }
          const [scheme, path] = uri.split(":");
          if (scheme !== "esr" && scheme !== "web+esr") {
            throw new Error("Invalid scheme");
          }
          const data = decode(path.startsWith("//") ? path.slice(2) : path);
          return SigningRequest.fromData(data, options);
        }
        static fromData(data, options = {}) {
          data = eosio.Bytes.from(data);
          const header = data.array[0];
          const version2 = header & ~(1 << 7);
          if (version2 !== 2 && version2 !== 3) {
            throw new Error("Unsupported protocol version");
          }
          let payload = data.droppingFirst(1);
          if ((header & 1 << 7) !== 0) {
            if (!options.zlib) {
              throw new Error("Compressed URI needs zlib");
            }
            payload = eosio.Bytes.from(options.zlib.inflateRaw(payload.array));
          }
          const decoder = new eosio.ABIDecoder(payload.array);
          const req = eosio.Serializer.decode({ data: decoder, type: this.storageType(version2) });
          let sig;
          if (decoder.canRead()) {
            sig = eosio.Serializer.decode({ data: decoder, type: exports.RequestSignature });
          }
          return new SigningRequest(version2, req, options.zlib, options.abiProvider, sig);
        }
        sign(signatureProvider) {
          const message = this.getSignatureDigest();
          this.signature = exports.RequestSignature.from(signatureProvider.sign(message));
        }
        getSignatureDigest() {
          const prefix = [this.version, 114, 101, 113, 117, 101, 115, 116];
          return eosio.Checksum256.hash(eosio.Bytes.from(prefix).appending(this.getData()));
        }
        setSignature(signer, signature) {
          this.signature = exports.RequestSignature.from({ signer, signature });
        }
        setCallback(url, background) {
          this.data.callback = url;
          this.data.flags.background = background;
        }
        setBroadcast(broadcast) {
          this.data.flags.broadcast = broadcast;
        }
        encode(compress, slashes) {
          const shouldCompress = compress !== void 0 ? compress : this.zlib !== void 0;
          if (shouldCompress && this.zlib === void 0) {
            throw new Error("Need zlib to compress");
          }
          let header = this.version;
          const data = this.getData();
          const sigData = this.getSignatureData();
          let array = new Uint8Array(data.byteLength + sigData.byteLength);
          array.set(data, 0);
          array.set(sigData, data.byteLength);
          if (shouldCompress) {
            const deflated = this.zlib.deflateRaw(array);
            if (array.byteLength > deflated.byteLength) {
              header |= 1 << 7;
              array = deflated;
            }
          }
          const out = new Uint8Array(1 + array.byteLength);
          out[0] = header;
          out.set(array, 1);
          let scheme = "esr:";
          if (slashes !== false) {
            scheme += "//";
          }
          return scheme + encode(out);
        }
        getData() {
          return eosio.Serializer.encode({ object: this.data }).array;
        }
        getSignatureData() {
          if (!this.signature) {
            return new Uint8Array(0);
          }
          return eosio.Serializer.encode({ object: this.signature }).array;
        }
        getRequiredAbis() {
          return this.getRawActions().filter((action) => !isIdentity(action)).map((action) => action.account).filter((value, index, self2) => self2.indexOf(value) === index);
        }
        requiresTapos() {
          const tx = this.getRawTransaction();
          return !this.isIdentity() && !hasTapos(tx);
        }
        fetchAbis(abiProvider) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            const required = this.getRequiredAbis();
            if (required.length > 0) {
              const provider = abiProvider || this.abiProvider;
              if (!provider) {
                throw new Error("Missing ABI provider");
              }
              const abis = new Map();
              yield Promise.all(required.map((account) => tslib.__awaiter(this, void 0, void 0, function* () {
                abis.set(account.toString(), eosio.ABI.from(yield provider.getAbi(account)));
              })));
              return abis;
            } else {
              return new Map();
            }
          });
        }
        resolveActions(abis, signer) {
          return this.getRawActions().map((rawAction) => {
            let abi;
            if (isIdentity(rawAction)) {
              abi = this.constructor.identityAbi(this.version);
            } else {
              const rawAbi = abis.get(rawAction.account.toString());
              if (!rawAbi) {
                throw new Error(`Missing ABI definition for ${rawAction.account}`);
              }
              abi = eosio.ABI.from(rawAbi);
            }
            const type = abi.getActionType(rawAction.name);
            if (!type) {
              throw new Error(`Missing type for action ${rawAction.account}:${rawAction.name} in ABI`);
            }
            let data = rawAction.decodeData(abi);
            let authorization = rawAction.authorization;
            if (signer) {
              const signerPerm = eosio.PermissionLevel.from(signer);
              const resolve = (value) => {
                if (value instanceof eosio.Name) {
                  if (value.equals(PlaceholderName)) {
                    return signerPerm.actor;
                  } else if (value.equals(PlaceholderPermission)) {
                    return signerPerm.permission;
                  } else {
                    return value;
                  }
                } else if (Array.isArray(value)) {
                  return value.map(resolve);
                } else if (typeof value === "object" && value !== null) {
                  for (const key of Object.keys(value)) {
                    value[key] = resolve(value[key]);
                  }
                  return value;
                } else {
                  return value;
                }
              };
              data = resolve(data);
              authorization = authorization.map((auth) => {
                let { actor, permission } = auth;
                if (actor.equals(PlaceholderName)) {
                  actor = signerPerm.actor;
                }
                if (permission.equals(PlaceholderPermission)) {
                  permission = signerPerm.permission;
                }
                if (permission.equals(PlaceholderName)) {
                  permission = signerPerm.permission;
                }
                return eosio.PermissionLevel.from({ actor, permission });
              });
            }
            return Object.assign(Object.assign({}, rawAction), {
              authorization,
              data
            });
          });
        }
        resolveTransaction(abis, signer, ctx = {}) {
          const tx = this.getRawTransaction();
          if (!this.isIdentity() && !hasTapos(tx)) {
            if (ctx.expiration !== void 0 && ctx.ref_block_num !== void 0 && ctx.ref_block_prefix !== void 0) {
              tx.expiration = eosio.TimePointSec.from(ctx.expiration);
              tx.ref_block_num = eosio.UInt16.from(ctx.ref_block_num);
              tx.ref_block_prefix = eosio.UInt32.from(ctx.ref_block_prefix);
            } else if (ctx.block_num !== void 0 && ctx.ref_block_prefix !== void 0 && ctx.timestamp !== void 0) {
              tx.expiration = expirationTime(ctx.timestamp, ctx.expire_seconds);
              tx.ref_block_num = eosio.UInt16.from(ctx.block_num);
              tx.ref_block_prefix = eosio.UInt32.from(ctx.ref_block_prefix);
            } else {
              throw new Error("Invalid transaction context, need either a reference block or explicit TaPoS values");
            }
          } else if (this.isIdentity() && this.version > 2) {
            tx.expiration = ctx.expiration ? eosio.TimePointSec.from(ctx.expiration) : expirationTime(ctx.timestamp, ctx.expire_seconds);
          }
          const actions = this.resolveActions(abis, signer);
          const context_free_actions = tx.context_free_actions;
          return Object.assign(Object.assign({}, tx), { context_free_actions, actions });
        }
        resolve(abis, signer, ctx = {}) {
          const tx = this.resolveTransaction(abis, signer, ctx);
          const actions = tx.actions.map((action) => {
            let abi;
            if (isIdentity(action)) {
              abi = this.constructor.identityAbi(this.version);
            } else {
              abi = abis.get(action.account.toString());
            }
            if (!abi) {
              throw new Error(`Missing ABI definition for ${action.account}`);
            }
            const type = abi.getActionType(action.name);
            const data = eosio.Serializer.encode({ object: action.data, type, abi });
            return eosio.Action.from(Object.assign(Object.assign({}, action), { data }));
          });
          const transaction = eosio.Transaction.from(Object.assign(Object.assign({}, tx), { actions }));
          let chainId;
          if (this.isMultiChain()) {
            if (!ctx.chainId) {
              throw new Error("Missing chosen chain ID for multi-chain request");
            }
            chainId = exports.ChainId.from(ctx.chainId);
            const ids = this.getChainIds();
            if (ids && !ids.some((id) => chainId.equals(id))) {
              throw new Error("Trying to resolve for chain ID not defined in request");
            }
          } else {
            chainId = this.getChainId();
          }
          return new ResolvedSigningRequest(this, eosio.PermissionLevel.from(signer), transaction, tx, chainId);
        }
        getChainId() {
          return this.data.chain_id.chainId;
        }
        getChainIds() {
          if (!this.isMultiChain()) {
            return null;
          }
          const ids = this.getInfoKey("chain_ids", { type: exports.ChainIdVariant, array: true });
          if (ids) {
            return ids.map((id) => id.chainId);
          }
          return null;
        }
        setChainIds(ids) {
          const value = ids.map((id) => exports.ChainId.from(id).chainVariant);
          this.setInfoKey("chain_ids", value, { type: exports.ChainIdVariant, array: true });
        }
        isMultiChain() {
          return this.data.chain_id.variantIdx === 0 && this.data.chain_id.value.equals(exports.ChainName.UNKNOWN);
        }
        getRawActions() {
          const req = this.data.req;
          switch (req.variantName) {
            case "action":
              return [req.value];
            case "action[]":
              return req.value;
            case "identity": {
              if (this.version === 2) {
                const id = req.value;
                let data = "0101000000000000000200000000000000";
                let authorization = [PlaceholderAuth];
                if (id.permission) {
                  data = eosio.Serializer.encode({ object: id });
                  authorization = [id.permission];
                }
                return [
                  eosio.Action.from({
                    account: "",
                    name: "identity",
                    authorization,
                    data
                  })
                ];
              } else {
                let { scope, permission } = req.value;
                if (!permission) {
                  permission = PlaceholderAuth;
                }
                const data = eosio.Serializer.encode({ object: { scope, permission }, type: exports.IdentityV3 });
                return [
                  eosio.Action.from({
                    account: "",
                    name: "identity",
                    authorization: [permission],
                    data
                  })
                ];
              }
            }
            case "transaction":
              return req.value.actions;
            default:
              throw new Error("Invalid signing request data");
          }
        }
        getRawTransaction() {
          const req = this.data.req;
          switch (req.variantName) {
            case "transaction":
              return eosio.Transaction.from(Object.assign({}, req.value));
            case "action":
            case "action[]":
            case "identity":
              return eosio.Transaction.from({
                actions: this.getRawActions(),
                context_free_actions: [],
                transaction_extensions: [],
                expiration: "1970-01-01T00:00:00.000",
                ref_block_num: 0,
                ref_block_prefix: 0,
                max_cpu_usage_ms: 0,
                max_net_usage_words: 0,
                delay_sec: 0
              });
            default:
              throw new Error("Invalid signing request data");
          }
        }
        isIdentity() {
          return this.data.req.variantName === "identity";
        }
        shouldBroadcast() {
          if (this.isIdentity()) {
            return false;
          }
          return this.data.flags.broadcast;
        }
        getIdentity() {
          if (!this.isIdentity()) {
            return null;
          }
          const id = this.data.req.value;
          if (id.permission && !id.permission.actor.equals(PlaceholderName)) {
            return id.permission.actor;
          }
          return null;
        }
        getIdentityPermission() {
          if (!this.isIdentity()) {
            return null;
          }
          const id = this.data.req.value;
          if (id.permission && !id.permission.permission.equals(PlaceholderPermission)) {
            return id.permission.permission;
          }
          return null;
        }
        getIdentityScope() {
          if (!this.isIdentity() || this.version <= 2) {
            return null;
          }
          const id = this.data.req.value;
          return id.scope;
        }
        getRawInfo() {
          const rv = {};
          for (const { key, value } of this.data.info) {
            rv[key] = value;
          }
          return rv;
        }
        getRawInfoKey(key) {
          const pair = this.data.info.find((pair2) => pair2.key === key);
          if (pair) {
            return pair.value;
          }
        }
        setRawInfoKey(key, value) {
          let pair = this.data.info.find((pair2) => pair2.key === key);
          if (!pair) {
            pair = exports.InfoPair.from({ key, value });
            this.data.info.push(pair);
          } else {
            pair.value = eosio.Bytes.from(value);
          }
        }
        setInfoKey(key, object, type) {
          let data;
          if (typeof object === "string" && !type) {
            data = eosio.Bytes.from(object, "utf8");
          } else {
            data = eosio.Serializer.encode({ object, type });
          }
          this.setRawInfoKey(key, data);
        }
        getInfoKey(key, type) {
          const data = this.getRawInfoKey(key);
          if (data) {
            if (type) {
              return eosio.Serializer.decode({ data, type });
            } else {
              return data.utf8String;
            }
          }
        }
        clone() {
          let signature;
          if (this.signature) {
            signature = exports.RequestSignature.from(JSON.parse(JSON.stringify(this.signature)));
          }
          const RequestData = this.constructor.storageType(this.version);
          const data = RequestData.from(JSON.parse(JSON.stringify(this.data)));
          return new SigningRequest(this.version, data, this.zlib, this.abiProvider, signature);
        }
        toString() {
          return this.encode();
        }
        toJSON() {
          return this.encode();
        }
      };
      var ResolvedSigningRequest = class {
        constructor(request, signer, transaction, resolvedTransaction, chainId) {
          this.request = request;
          this.signer = signer;
          this.transaction = transaction;
          this.resolvedTransaction = resolvedTransaction;
          this.chainId = chainId;
        }
        static fromPayload(payload, options = {}) {
          return tslib.__awaiter(this, void 0, void 0, function* () {
            const request = SigningRequest.from(payload.req, options);
            const abis = yield request.fetchAbis();
            return request.resolve(abis, { actor: payload.sa, permission: payload.sp }, {
              ref_block_num: payload.rbn,
              ref_block_prefix: payload.rid,
              expiration: payload.ex,
              chainId: payload.cid || request.getChainId()
            });
          });
        }
        get serializedTransaction() {
          return eosio.Serializer.encode({ object: this.transaction }).array;
        }
        get signingDigest() {
          return this.transaction.signingDigest(this.chainId);
        }
        getCallback(signatures, blockNum) {
          const { callback, flags } = this.request.data;
          if (!callback || callback.length === 0) {
            return null;
          }
          if (!signatures || signatures.length === 0) {
            throw new Error("Must have at least one signature to resolve callback");
          }
          const sigs = signatures.map((sig) => eosio.Signature.from(sig));
          const payload = {
            sig: String(sigs[0]),
            tx: String(this.transaction.id),
            rbn: String(this.transaction.ref_block_num),
            rid: String(this.transaction.ref_block_prefix),
            ex: String(this.transaction.expiration),
            req: this.request.encode(),
            sa: String(this.signer.actor),
            sp: String(this.signer.permission),
            cid: String(this.chainId)
          };
          for (const [n, sig] of sigs.slice(1).entries()) {
            payload[`sig${n}`] = String(sig);
          }
          if (blockNum) {
            payload.bn = String(eosio.UInt32.from(blockNum));
          }
          const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {
            return payload[m] || "";
          });
          return {
            background: flags.background,
            payload,
            url
          };
        }
        getIdentityProof(signature) {
          if (!this.request.isIdentity()) {
            throw new Error("Not a identity request");
          }
          return exports.IdentityProof.from({
            chainId: this.chainId,
            scope: this.request.getIdentityScope(),
            expiration: this.transaction.expiration,
            signer: this.signer,
            signature
          });
        }
      };
      function encodeAction(action, abis) {
        if (eosio.Bytes.isBytes(action.data) || action.data.constructor.abiName !== void 0) {
          return eosio.Action.from(action);
        }
        const abi = abis[String(eosio.Name.from(action.account))];
        if (!abi) {
          throw new Error(`Missing ABI for ${action.account}`);
        }
        return eosio.Action.from(action, abi);
      }
      function isIdentity(action) {
        const account = eosio.Name.from(action.account);
        const name = eosio.Name.from(action.name);
        return account.rawValue.equals(0) && name.equals("identity");
      }
      function hasTapos(tx) {
        return !(tx.expiration.equals(0) && tx.ref_block_num.equals(0) && tx.ref_block_prefix.equals(0));
      }
      function expirationTime(timestamp, expireSeconds = 60) {
        const ts = eosio.TimePointSec.from(timestamp || new Date());
        const exp = eosio.UInt32.from(expireSeconds);
        return eosio.TimePointSec.fromInteger(ts.value.adding(exp));
      }
      exports.Base64u = base64u;
      exports.PlaceholderAuth = PlaceholderAuth;
      exports.PlaceholderName = PlaceholderName;
      exports.PlaceholderPermission = PlaceholderPermission;
      exports.ProtocolVersion = ProtocolVersion;
      exports.ResolvedSigningRequest = ResolvedSigningRequest;
      exports.SigningRequest = SigningRequest;
    }
  });

  // node_modules/fetch-ponyfill/build/fetch-browser.js
  var require_fetch_browser = __commonJS({
    "node_modules/fetch-ponyfill/build/fetch-browser.js"(exports, module) {
      (function(global2) {
        "use strict";
        function fetchPonyfill(options) {
          var Promise2 = options && options.Promise || global2.Promise;
          var XMLHttpRequest = options && options.XMLHttpRequest || global2.XMLHttpRequest;
          return function() {
            var globalThis2 = Object.create(global2, {
              fetch: {
                value: void 0,
                writable: true
              }
            });
            (function(global3, factory) {
              typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global3.WHATWGFetch = {});
            })(this, function(exports2) {
              "use strict";
              var global3 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global3 !== "undefined" && global3;
              var support = {
                searchParams: "URLSearchParams" in global3,
                iterable: "Symbol" in global3 && "iterator" in Symbol,
                blob: "FileReader" in global3 && "Blob" in global3 && function() {
                  try {
                    new Blob();
                    return true;
                  } catch (e) {
                    return false;
                  }
                }(),
                formData: "FormData" in global3,
                arrayBuffer: "ArrayBuffer" in global3
              };
              function isDataView(obj) {
                return obj && DataView.prototype.isPrototypeOf(obj);
              }
              if (support.arrayBuffer) {
                var viewClasses = [
                  "[object Int8Array]",
                  "[object Uint8Array]",
                  "[object Uint8ClampedArray]",
                  "[object Int16Array]",
                  "[object Uint16Array]",
                  "[object Int32Array]",
                  "[object Uint32Array]",
                  "[object Float32Array]",
                  "[object Float64Array]"
                ];
                var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                  return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
                };
              }
              function normalizeName(name) {
                if (typeof name !== "string") {
                  name = String(name);
                }
                if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
                  throw new TypeError("Invalid character in header field name");
                }
                return name.toLowerCase();
              }
              function normalizeValue(value) {
                if (typeof value !== "string") {
                  value = String(value);
                }
                return value;
              }
              function iteratorFor(items) {
                var iterator = {
                  next: function() {
                    var value = items.shift();
                    return { done: value === void 0, value };
                  }
                };
                if (support.iterable) {
                  iterator[Symbol.iterator] = function() {
                    return iterator;
                  };
                }
                return iterator;
              }
              function Headers(headers) {
                this.map = {};
                if (headers instanceof Headers) {
                  headers.forEach(function(value, name) {
                    this.append(name, value);
                  }, this);
                } else if (Array.isArray(headers)) {
                  headers.forEach(function(header) {
                    this.append(header[0], header[1]);
                  }, this);
                } else if (headers) {
                  Object.getOwnPropertyNames(headers).forEach(function(name) {
                    this.append(name, headers[name]);
                  }, this);
                }
              }
              Headers.prototype.append = function(name, value) {
                name = normalizeName(name);
                value = normalizeValue(value);
                var oldValue = this.map[name];
                this.map[name] = oldValue ? oldValue + ", " + value : value;
              };
              Headers.prototype["delete"] = function(name) {
                delete this.map[normalizeName(name)];
              };
              Headers.prototype.get = function(name) {
                name = normalizeName(name);
                return this.has(name) ? this.map[name] : null;
              };
              Headers.prototype.has = function(name) {
                return this.map.hasOwnProperty(normalizeName(name));
              };
              Headers.prototype.set = function(name, value) {
                this.map[normalizeName(name)] = normalizeValue(value);
              };
              Headers.prototype.forEach = function(callback, thisArg) {
                for (var name in this.map) {
                  if (this.map.hasOwnProperty(name)) {
                    callback.call(thisArg, this.map[name], name, this);
                  }
                }
              };
              Headers.prototype.keys = function() {
                var items = [];
                this.forEach(function(value, name) {
                  items.push(name);
                });
                return iteratorFor(items);
              };
              Headers.prototype.values = function() {
                var items = [];
                this.forEach(function(value) {
                  items.push(value);
                });
                return iteratorFor(items);
              };
              Headers.prototype.entries = function() {
                var items = [];
                this.forEach(function(value, name) {
                  items.push([name, value]);
                });
                return iteratorFor(items);
              };
              if (support.iterable) {
                Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
              }
              function consumed(body) {
                if (body.bodyUsed) {
                  return Promise2.reject(new TypeError("Already read"));
                }
                body.bodyUsed = true;
              }
              function fileReaderReady(reader) {
                return new Promise2(function(resolve, reject) {
                  reader.onload = function() {
                    resolve(reader.result);
                  };
                  reader.onerror = function() {
                    reject(reader.error);
                  };
                });
              }
              function readBlobAsArrayBuffer(blob) {
                var reader = new FileReader();
                var promise = fileReaderReady(reader);
                reader.readAsArrayBuffer(blob);
                return promise;
              }
              function readBlobAsText(blob) {
                var reader = new FileReader();
                var promise = fileReaderReady(reader);
                reader.readAsText(blob);
                return promise;
              }
              function readArrayBufferAsText(buf) {
                var view = new Uint8Array(buf);
                var chars = new Array(view.length);
                for (var i = 0; i < view.length; i++) {
                  chars[i] = String.fromCharCode(view[i]);
                }
                return chars.join("");
              }
              function bufferClone(buf) {
                if (buf.slice) {
                  return buf.slice(0);
                } else {
                  var view = new Uint8Array(buf.byteLength);
                  view.set(new Uint8Array(buf));
                  return view.buffer;
                }
              }
              function Body() {
                this.bodyUsed = false;
                this._initBody = function(body) {
                  this.bodyUsed = this.bodyUsed;
                  this._bodyInit = body;
                  if (!body) {
                    this._bodyText = "";
                  } else if (typeof body === "string") {
                    this._bodyText = body;
                  } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                    this._bodyBlob = body;
                  } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                    this._bodyFormData = body;
                  } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this._bodyText = body.toString();
                  } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                    this._bodyArrayBuffer = bufferClone(body.buffer);
                    this._bodyInit = new Blob([this._bodyArrayBuffer]);
                  } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                    this._bodyArrayBuffer = bufferClone(body);
                  } else {
                    this._bodyText = body = Object.prototype.toString.call(body);
                  }
                  if (!this.headers.get("content-type")) {
                    if (typeof body === "string") {
                      this.headers.set("content-type", "text/plain;charset=UTF-8");
                    } else if (this._bodyBlob && this._bodyBlob.type) {
                      this.headers.set("content-type", this._bodyBlob.type);
                    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                      this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                    }
                  }
                };
                if (support.blob) {
                  this.blob = function() {
                    var rejected = consumed(this);
                    if (rejected) {
                      return rejected;
                    }
                    if (this._bodyBlob) {
                      return Promise2.resolve(this._bodyBlob);
                    } else if (this._bodyArrayBuffer) {
                      return Promise2.resolve(new Blob([this._bodyArrayBuffer]));
                    } else if (this._bodyFormData) {
                      throw new Error("could not read FormData body as blob");
                    } else {
                      return Promise2.resolve(new Blob([this._bodyText]));
                    }
                  };
                  this.arrayBuffer = function() {
                    if (this._bodyArrayBuffer) {
                      var isConsumed = consumed(this);
                      if (isConsumed) {
                        return isConsumed;
                      }
                      if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                        return Promise2.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
                      } else {
                        return Promise2.resolve(this._bodyArrayBuffer);
                      }
                    } else {
                      return this.blob().then(readBlobAsArrayBuffer);
                    }
                  };
                }
                this.text = function() {
                  var rejected = consumed(this);
                  if (rejected) {
                    return rejected;
                  }
                  if (this._bodyBlob) {
                    return readBlobAsText(this._bodyBlob);
                  } else if (this._bodyArrayBuffer) {
                    return Promise2.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                  } else if (this._bodyFormData) {
                    throw new Error("could not read FormData body as text");
                  } else {
                    return Promise2.resolve(this._bodyText);
                  }
                };
                if (support.formData) {
                  this.formData = function() {
                    return this.text().then(decode);
                  };
                }
                this.json = function() {
                  return this.text().then(JSON.parse);
                };
                return this;
              }
              var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
              function normalizeMethod(method) {
                var upcased = method.toUpperCase();
                return methods.indexOf(upcased) > -1 ? upcased : method;
              }
              function Request(input, options2) {
                if (!(this instanceof Request)) {
                  throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                }
                options2 = options2 || {};
                var body = options2.body;
                if (input instanceof Request) {
                  if (input.bodyUsed) {
                    throw new TypeError("Already read");
                  }
                  this.url = input.url;
                  this.credentials = input.credentials;
                  if (!options2.headers) {
                    this.headers = new Headers(input.headers);
                  }
                  this.method = input.method;
                  this.mode = input.mode;
                  this.signal = input.signal;
                  if (!body && input._bodyInit != null) {
                    body = input._bodyInit;
                    input.bodyUsed = true;
                  }
                } else {
                  this.url = String(input);
                }
                this.credentials = options2.credentials || this.credentials || "same-origin";
                if (options2.headers || !this.headers) {
                  this.headers = new Headers(options2.headers);
                }
                this.method = normalizeMethod(options2.method || this.method || "GET");
                this.mode = options2.mode || this.mode || null;
                this.signal = options2.signal || this.signal;
                this.referrer = null;
                if ((this.method === "GET" || this.method === "HEAD") && body) {
                  throw new TypeError("Body not allowed for GET or HEAD requests");
                }
                this._initBody(body);
                if (this.method === "GET" || this.method === "HEAD") {
                  if (options2.cache === "no-store" || options2.cache === "no-cache") {
                    var reParamSearch = /([?&])_=[^&]*/;
                    if (reParamSearch.test(this.url)) {
                      this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
                    } else {
                      var reQueryString = /\?/;
                      this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
                    }
                  }
                }
              }
              Request.prototype.clone = function() {
                return new Request(this, { body: this._bodyInit });
              };
              function decode(body) {
                var form = new FormData();
                body.trim().split("&").forEach(function(bytes) {
                  if (bytes) {
                    var split = bytes.split("=");
                    var name = split.shift().replace(/\+/g, " ");
                    var value = split.join("=").replace(/\+/g, " ");
                    form.append(decodeURIComponent(name), decodeURIComponent(value));
                  }
                });
                return form;
              }
              function parseHeaders(rawHeaders) {
                var headers = new Headers();
                var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
                preProcessedHeaders.split("\r").map(function(header) {
                  return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
                }).forEach(function(line) {
                  var parts = line.split(":");
                  var key = parts.shift().trim();
                  if (key) {
                    var value = parts.join(":").trim();
                    headers.append(key, value);
                  }
                });
                return headers;
              }
              Body.call(Request.prototype);
              function Response(bodyInit, options2) {
                if (!(this instanceof Response)) {
                  throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                }
                if (!options2) {
                  options2 = {};
                }
                this.type = "default";
                this.status = options2.status === void 0 ? 200 : options2.status;
                this.ok = this.status >= 200 && this.status < 300;
                this.statusText = "statusText" in options2 ? options2.statusText : "";
                this.headers = new Headers(options2.headers);
                this.url = options2.url || "";
                this._initBody(bodyInit);
              }
              Body.call(Response.prototype);
              Response.prototype.clone = function() {
                return new Response(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new Headers(this.headers),
                  url: this.url
                });
              };
              Response.error = function() {
                var response = new Response(null, { status: 0, statusText: "" });
                response.type = "error";
                return response;
              };
              var redirectStatuses = [301, 302, 303, 307, 308];
              Response.redirect = function(url, status) {
                if (redirectStatuses.indexOf(status) === -1) {
                  throw new RangeError("Invalid status code");
                }
                return new Response(null, { status, headers: { location: url } });
              };
              exports2.DOMException = global3.DOMException;
              try {
                new exports2.DOMException();
              } catch (err) {
                exports2.DOMException = function(message, name) {
                  this.message = message;
                  this.name = name;
                  var error = Error(message);
                  this.stack = error.stack;
                };
                exports2.DOMException.prototype = Object.create(Error.prototype);
                exports2.DOMException.prototype.constructor = exports2.DOMException;
              }
              function fetch2(input, init) {
                return new Promise2(function(resolve, reject) {
                  var request = new Request(input, init);
                  if (request.signal && request.signal.aborted) {
                    return reject(new exports2.DOMException("Aborted", "AbortError"));
                  }
                  var xhr = new XMLHttpRequest();
                  function abortXhr() {
                    xhr.abort();
                  }
                  xhr.onload = function() {
                    var options2 = {
                      status: xhr.status,
                      statusText: xhr.statusText,
                      headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                    };
                    options2.url = "responseURL" in xhr ? xhr.responseURL : options2.headers.get("X-Request-URL");
                    var body = "response" in xhr ? xhr.response : xhr.responseText;
                    setTimeout(function() {
                      resolve(new Response(body, options2));
                    }, 0);
                  };
                  xhr.onerror = function() {
                    setTimeout(function() {
                      reject(new TypeError("Network request failed"));
                    }, 0);
                  };
                  xhr.ontimeout = function() {
                    setTimeout(function() {
                      reject(new TypeError("Network request failed"));
                    }, 0);
                  };
                  xhr.onabort = function() {
                    setTimeout(function() {
                      reject(new exports2.DOMException("Aborted", "AbortError"));
                    }, 0);
                  };
                  function fixUrl(url) {
                    try {
                      return url === "" && global3.location.href ? global3.location.href : url;
                    } catch (e) {
                      return url;
                    }
                  }
                  xhr.open(request.method, fixUrl(request.url), true);
                  if (request.credentials === "include") {
                    xhr.withCredentials = true;
                  } else if (request.credentials === "omit") {
                    xhr.withCredentials = false;
                  }
                  if ("responseType" in xhr) {
                    if (support.blob) {
                      xhr.responseType = "blob";
                    } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                      xhr.responseType = "arraybuffer";
                    }
                  }
                  if (init && typeof init.headers === "object" && !(init.headers instanceof Headers)) {
                    Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                      xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                    });
                  } else {
                    request.headers.forEach(function(value, name) {
                      xhr.setRequestHeader(name, value);
                    });
                  }
                  if (request.signal) {
                    request.signal.addEventListener("abort", abortXhr);
                    xhr.onreadystatechange = function() {
                      if (xhr.readyState === 4) {
                        request.signal.removeEventListener("abort", abortXhr);
                      }
                    };
                  }
                  xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
                });
              }
              fetch2.polyfill = true;
              if (!global3.fetch) {
                global3.fetch = fetch2;
                global3.Headers = Headers;
                global3.Request = Request;
                global3.Response = Response;
              }
              exports2.Headers = Headers;
              exports2.Request = Request;
              exports2.Response = Response;
              exports2.fetch = fetch2;
              Object.defineProperty(exports2, "__esModule", { value: true });
            });
            return {
              fetch: globalThis2.fetch,
              Headers: globalThis2.Headers,
              Request: globalThis2.Request,
              Response: globalThis2.Response,
              DOMException: globalThis2.DOMException
            };
          }();
        }
        if (typeof define === "function" && define.amd) {
          define(function() {
            return fetchPonyfill;
          });
        } else if (typeof exports === "object") {
          module.exports = fetchPonyfill;
        } else {
          global2.fetchPonyfill = fetchPonyfill;
        }
      })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : exports);
    }
  });

  // node_modules/asmcrypto.js/asmcrypto.all.js
  var require_asmcrypto_all = __commonJS({
    "node_modules/asmcrypto.js/asmcrypto.all.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var local_atob = typeof atob === "undefined" ? function(str) {
        return Buffer.from(str, "base64").toString("binary");
      } : atob;
      var local_btoa = typeof btoa === "undefined" ? function(str) {
        return Buffer.from(str, "binary").toString("base64");
      } : btoa;
      function string_to_bytes(str, utf8) {
        if (utf8 === void 0) {
          utf8 = false;
        }
        var len = str.length, bytes = new Uint8Array(utf8 ? 4 * len : len);
        for (var i = 0, j = 0; i < len; i++) {
          var c = str.charCodeAt(i);
          if (utf8 && 55296 <= c && c <= 56319) {
            if (++i >= len)
              throw new Error("Malformed string, low surrogate expected at position " + i);
            c = (c ^ 55296) << 10 | 65536 | str.charCodeAt(i) ^ 56320;
          } else if (!utf8 && c >>> 8) {
            throw new Error("Wide characters are not allowed.");
          }
          if (!utf8 || c <= 127) {
            bytes[j++] = c;
          } else if (c <= 2047) {
            bytes[j++] = 192 | c >> 6;
            bytes[j++] = 128 | c & 63;
          } else if (c <= 65535) {
            bytes[j++] = 224 | c >> 12;
            bytes[j++] = 128 | c >> 6 & 63;
            bytes[j++] = 128 | c & 63;
          } else {
            bytes[j++] = 240 | c >> 18;
            bytes[j++] = 128 | c >> 12 & 63;
            bytes[j++] = 128 | c >> 6 & 63;
            bytes[j++] = 128 | c & 63;
          }
        }
        return bytes.subarray(0, j);
      }
      function hex_to_bytes(str) {
        var len = str.length;
        if (len & 1) {
          str = "0" + str;
          len++;
        }
        var bytes = new Uint8Array(len >> 1);
        for (var i = 0; i < len; i += 2) {
          bytes[i >> 1] = parseInt(str.substr(i, 2), 16);
        }
        return bytes;
      }
      function base64_to_bytes(str) {
        return string_to_bytes(local_atob(str));
      }
      function bytes_to_string(bytes, utf8) {
        if (utf8 === void 0) {
          utf8 = false;
        }
        var len = bytes.length, chars = new Array(len);
        for (var i = 0, j = 0; i < len; i++) {
          var b = bytes[i];
          if (!utf8 || b < 128) {
            chars[j++] = b;
          } else if (b >= 192 && b < 224 && i + 1 < len) {
            chars[j++] = (b & 31) << 6 | bytes[++i] & 63;
          } else if (b >= 224 && b < 240 && i + 2 < len) {
            chars[j++] = (b & 15) << 12 | (bytes[++i] & 63) << 6 | bytes[++i] & 63;
          } else if (b >= 240 && b < 248 && i + 3 < len) {
            var c = (b & 7) << 18 | (bytes[++i] & 63) << 12 | (bytes[++i] & 63) << 6 | bytes[++i] & 63;
            if (c <= 65535) {
              chars[j++] = c;
            } else {
              c ^= 65536;
              chars[j++] = 55296 | c >> 10;
              chars[j++] = 56320 | c & 1023;
            }
          } else {
            throw new Error("Malformed UTF8 character at byte offset " + i);
          }
        }
        var str = "", bs = 16384;
        for (var i = 0; i < j; i += bs) {
          str += String.fromCharCode.apply(String, chars.slice(i, i + bs <= j ? i + bs : j));
        }
        return str;
      }
      function bytes_to_hex(arr) {
        var str = "";
        for (var i = 0; i < arr.length; i++) {
          var h = (arr[i] & 255).toString(16);
          if (h.length < 2)
            str += "0";
          str += h;
        }
        return str;
      }
      function bytes_to_base64(arr) {
        return local_btoa(bytes_to_string(arr));
      }
      function is_bytes(a) {
        return a instanceof Uint8Array;
      }
      function _heap_init(heap, heapSize) {
        var size = heap ? heap.byteLength : heapSize || 65536;
        if (size & 4095 || size <= 0)
          throw new Error("heap size must be a positive integer and a multiple of 4096");
        heap = heap || new Uint8Array(new ArrayBuffer(size));
        return heap;
      }
      function _heap_write(heap, hpos, data, dpos, dlen) {
        var hlen = heap.length - hpos;
        var wlen = hlen < dlen ? hlen : dlen;
        heap.set(data.subarray(dpos, dpos + wlen), hpos);
        return wlen;
      }
      function joinBytes() {
        var arg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          arg[_i] = arguments[_i];
        }
        var totalLenght = arg.reduce(function(sum, curr) {
          return sum + curr.length;
        }, 0);
        var ret = new Uint8Array(totalLenght);
        var cursor = 0;
        for (var i = 0; i < arg.length; i++) {
          ret.set(arg[i], cursor);
          cursor += arg[i].length;
        }
        return ret;
      }
      var __extends = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var IllegalStateError = function(_super) {
        __extends(IllegalStateError2, _super);
        function IllegalStateError2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = _super.apply(this, args) || this;
          return _this;
        }
        return IllegalStateError2;
      }(Error);
      var IllegalArgumentError = function(_super) {
        __extends(IllegalArgumentError2, _super);
        function IllegalArgumentError2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = _super.apply(this, args) || this;
          return _this;
        }
        return IllegalArgumentError2;
      }(Error);
      var SecurityError = function(_super) {
        __extends(SecurityError2, _super);
        function SecurityError2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = _super.apply(this, args) || this;
          return _this;
        }
        return SecurityError2;
      }(Error);
      var AES_asm = function() {
        var ginit_done = false;
        var gexp3, glog3;
        function ginit() {
          gexp3 = [], glog3 = [];
          var a = 1, c, d;
          for (c = 0; c < 255; c++) {
            gexp3[c] = a;
            d = a & 128, a <<= 1, a &= 255;
            if (d === 128)
              a ^= 27;
            a ^= gexp3[c];
            glog3[gexp3[c]] = c;
          }
          gexp3[255] = gexp3[0];
          glog3[0] = 0;
          ginit_done = true;
        }
        function gmul(a, b) {
          var c = gexp3[(glog3[a] + glog3[b]) % 255];
          if (a === 0 || b === 0)
            c = 0;
          return c;
        }
        function ginv(a) {
          var i = gexp3[255 - glog3[a]];
          if (a === 0)
            i = 0;
          return i;
        }
        var aes_init_done = false;
        var aes_sbox;
        var aes_sinv;
        var aes_enc;
        var aes_dec;
        function aes_init() {
          if (!ginit_done)
            ginit();
          function _s(a) {
            var c, s2, x;
            s2 = x = ginv(a);
            for (c = 0; c < 4; c++) {
              s2 = (s2 << 1 | s2 >>> 7) & 255;
              x ^= s2;
            }
            x ^= 99;
            return x;
          }
          aes_sbox = [], aes_sinv = [], aes_enc = [[], [], [], []], aes_dec = [[], [], [], []];
          for (var i = 0; i < 256; i++) {
            var s = _s(i);
            aes_sbox[i] = s;
            aes_sinv[s] = i;
            aes_enc[0][i] = gmul(2, s) << 24 | s << 16 | s << 8 | gmul(3, s);
            aes_dec[0][s] = gmul(14, i) << 24 | gmul(9, i) << 16 | gmul(13, i) << 8 | gmul(11, i);
            for (var t = 1; t < 4; t++) {
              aes_enc[t][i] = aes_enc[t - 1][i] >>> 8 | aes_enc[t - 1][i] << 24;
              aes_dec[t][s] = aes_dec[t - 1][s] >>> 8 | aes_dec[t - 1][s] << 24;
            }
          }
          aes_init_done = true;
        }
        var wrapper = function(foreign, buffer) {
          if (!aes_init_done)
            aes_init();
          var heap = new Uint32Array(buffer);
          heap.set(aes_sbox, 2048 >> 2);
          heap.set(aes_sinv, 3072 >> 2);
          for (var i = 0; i < 4; i++) {
            heap.set(aes_enc[i], 4096 + 1024 * i >> 2);
            heap.set(aes_dec[i], 8192 + 1024 * i >> 2);
          }
          function set_key(ks, k0, k1, k2, k3, k4, k5, k6, k7) {
            var ekeys = heap.subarray(0, 60), dkeys = heap.subarray(256, 256 + 60);
            ekeys.set([k0, k1, k2, k3, k4, k5, k6, k7]);
            for (var i2 = ks, rcon = 1; i2 < 4 * ks + 28; i2++) {
              var k = ekeys[i2 - 1];
              if (i2 % ks === 0 || ks === 8 && i2 % ks === 4) {
                k = aes_sbox[k >>> 24] << 24 ^ aes_sbox[k >>> 16 & 255] << 16 ^ aes_sbox[k >>> 8 & 255] << 8 ^ aes_sbox[k & 255];
              }
              if (i2 % ks === 0) {
                k = k << 8 ^ k >>> 24 ^ rcon << 24;
                rcon = rcon << 1 ^ (rcon & 128 ? 27 : 0);
              }
              ekeys[i2] = ekeys[i2 - ks] ^ k;
            }
            for (var j = 0; j < i2; j += 4) {
              for (var jj = 0; jj < 4; jj++) {
                var k = ekeys[i2 - (4 + j) + (4 - jj) % 4];
                if (j < 4 || j >= i2 - 4) {
                  dkeys[j + jj] = k;
                } else {
                  dkeys[j + jj] = aes_dec[0][aes_sbox[k >>> 24]] ^ aes_dec[1][aes_sbox[k >>> 16 & 255]] ^ aes_dec[2][aes_sbox[k >>> 8 & 255]] ^ aes_dec[3][aes_sbox[k & 255]];
                }
              }
            }
            asm.set_rounds(ks + 5);
          }
          var stdlib = { Uint8Array, Uint32Array };
          var asm = function(stdlib2, foreign2, buffer2) {
            ;
            var S0 = 0, S1 = 0, S2 = 0, S3 = 0, I0 = 0, I1 = 0, I2 = 0, I3 = 0, N0 = 0, N1 = 0, N2 = 0, N3 = 0, M0 = 0, M1 = 0, M2 = 0, M3 = 0, H0 = 0, H1 = 0, H2 = 0, H3 = 0, R = 0;
            var HEAP = new stdlib2.Uint32Array(buffer2), DATA = new stdlib2.Uint8Array(buffer2);
            function _core(k, s, t, r, x0, x1, x2, x3) {
              k = k | 0;
              s = s | 0;
              t = t | 0;
              r = r | 0;
              x0 = x0 | 0;
              x1 = x1 | 0;
              x2 = x2 | 0;
              x3 = x3 | 0;
              var t1 = 0, t2 = 0, t3 = 0, y0 = 0, y1 = 0, y2 = 0, y3 = 0, i2 = 0;
              t1 = t | 1024, t2 = t | 2048, t3 = t | 3072;
              x0 = x0 ^ HEAP[(k | 0) >> 2], x1 = x1 ^ HEAP[(k | 4) >> 2], x2 = x2 ^ HEAP[(k | 8) >> 2], x3 = x3 ^ HEAP[(k | 12) >> 2];
              for (i2 = 16; (i2 | 0) <= r << 4; i2 = i2 + 16 | 0) {
                y0 = HEAP[(t | x0 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x1 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x2 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x3 << 2 & 1020) >> 2] ^ HEAP[(k | i2 | 0) >> 2], y1 = HEAP[(t | x1 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x2 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x3 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x0 << 2 & 1020) >> 2] ^ HEAP[(k | i2 | 4) >> 2], y2 = HEAP[(t | x2 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x3 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x0 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x1 << 2 & 1020) >> 2] ^ HEAP[(k | i2 | 8) >> 2], y3 = HEAP[(t | x3 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x0 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x1 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x2 << 2 & 1020) >> 2] ^ HEAP[(k | i2 | 12) >> 2];
                x0 = y0, x1 = y1, x2 = y2, x3 = y3;
              }
              S0 = HEAP[(s | x0 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x1 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x2 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x3 << 2 & 1020) >> 2] ^ HEAP[(k | i2 | 0) >> 2], S1 = HEAP[(s | x1 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x2 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x3 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x0 << 2 & 1020) >> 2] ^ HEAP[(k | i2 | 4) >> 2], S2 = HEAP[(s | x2 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x3 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x0 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x1 << 2 & 1020) >> 2] ^ HEAP[(k | i2 | 8) >> 2], S3 = HEAP[(s | x3 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x0 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x1 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x2 << 2 & 1020) >> 2] ^ HEAP[(k | i2 | 12) >> 2];
            }
            function _ecb_enc(x0, x1, x2, x3) {
              x0 = x0 | 0;
              x1 = x1 | 0;
              x2 = x2 | 0;
              x3 = x3 | 0;
              _core(0, 2048, 4096, R, x0, x1, x2, x3);
            }
            function _ecb_dec(x0, x1, x2, x3) {
              x0 = x0 | 0;
              x1 = x1 | 0;
              x2 = x2 | 0;
              x3 = x3 | 0;
              var t = 0;
              _core(1024, 3072, 8192, R, x0, x3, x2, x1);
              t = S1, S1 = S3, S3 = t;
            }
            function _cbc_enc(x0, x1, x2, x3) {
              x0 = x0 | 0;
              x1 = x1 | 0;
              x2 = x2 | 0;
              x3 = x3 | 0;
              _core(0, 2048, 4096, R, I0 ^ x0, I1 ^ x1, I2 ^ x2, I3 ^ x3);
              I0 = S0, I1 = S1, I2 = S2, I3 = S3;
            }
            function _cbc_dec(x0, x1, x2, x3) {
              x0 = x0 | 0;
              x1 = x1 | 0;
              x2 = x2 | 0;
              x3 = x3 | 0;
              var t = 0;
              _core(1024, 3072, 8192, R, x0, x3, x2, x1);
              t = S1, S1 = S3, S3 = t;
              S0 = S0 ^ I0, S1 = S1 ^ I1, S2 = S2 ^ I2, S3 = S3 ^ I3;
              I0 = x0, I1 = x1, I2 = x2, I3 = x3;
            }
            function _cfb_enc(x0, x1, x2, x3) {
              x0 = x0 | 0;
              x1 = x1 | 0;
              x2 = x2 | 0;
              x3 = x3 | 0;
              _core(0, 2048, 4096, R, I0, I1, I2, I3);
              I0 = S0 = S0 ^ x0, I1 = S1 = S1 ^ x1, I2 = S2 = S2 ^ x2, I3 = S3 = S3 ^ x3;
            }
            function _cfb_dec(x0, x1, x2, x3) {
              x0 = x0 | 0;
              x1 = x1 | 0;
              x2 = x2 | 0;
              x3 = x3 | 0;
              _core(0, 2048, 4096, R, I0, I1, I2, I3);
              S0 = S0 ^ x0, S1 = S1 ^ x1, S2 = S2 ^ x2, S3 = S3 ^ x3;
              I0 = x0, I1 = x1, I2 = x2, I3 = x3;
            }
            function _ofb(x0, x1, x2, x3) {
              x0 = x0 | 0;
              x1 = x1 | 0;
              x2 = x2 | 0;
              x3 = x3 | 0;
              _core(0, 2048, 4096, R, I0, I1, I2, I3);
              I0 = S0, I1 = S1, I2 = S2, I3 = S3;
              S0 = S0 ^ x0, S1 = S1 ^ x1, S2 = S2 ^ x2, S3 = S3 ^ x3;
            }
            function _ctr(x0, x1, x2, x3) {
              x0 = x0 | 0;
              x1 = x1 | 0;
              x2 = x2 | 0;
              x3 = x3 | 0;
              _core(0, 2048, 4096, R, N0, N1, N2, N3);
              N3 = ~M3 & N3 | M3 & N3 + 1;
              N2 = ~M2 & N2 | M2 & N2 + ((N3 | 0) == 0);
              N1 = ~M1 & N1 | M1 & N1 + ((N2 | 0) == 0);
              N0 = ~M0 & N0 | M0 & N0 + ((N1 | 0) == 0);
              S0 = S0 ^ x0;
              S1 = S1 ^ x1;
              S2 = S2 ^ x2;
              S3 = S3 ^ x3;
            }
            function _gcm_mac(x0, x1, x2, x3) {
              x0 = x0 | 0;
              x1 = x1 | 0;
              x2 = x2 | 0;
              x3 = x3 | 0;
              var y0 = 0, y1 = 0, y2 = 0, y3 = 0, z0 = 0, z1 = 0, z2 = 0, z3 = 0, i2 = 0, c = 0;
              x0 = x0 ^ I0, x1 = x1 ^ I1, x2 = x2 ^ I2, x3 = x3 ^ I3;
              y0 = H0 | 0, y1 = H1 | 0, y2 = H2 | 0, y3 = H3 | 0;
              for (; (i2 | 0) < 128; i2 = i2 + 1 | 0) {
                if (y0 >>> 31) {
                  z0 = z0 ^ x0, z1 = z1 ^ x1, z2 = z2 ^ x2, z3 = z3 ^ x3;
                }
                y0 = y0 << 1 | y1 >>> 31, y1 = y1 << 1 | y2 >>> 31, y2 = y2 << 1 | y3 >>> 31, y3 = y3 << 1;
                c = x3 & 1;
                x3 = x3 >>> 1 | x2 << 31, x2 = x2 >>> 1 | x1 << 31, x1 = x1 >>> 1 | x0 << 31, x0 = x0 >>> 1;
                if (c)
                  x0 = x0 ^ 3774873600;
              }
              I0 = z0, I1 = z1, I2 = z2, I3 = z3;
            }
            function set_rounds(r) {
              r = r | 0;
              R = r;
            }
            function set_state(s0, s1, s2, s3) {
              s0 = s0 | 0;
              s1 = s1 | 0;
              s2 = s2 | 0;
              s3 = s3 | 0;
              S0 = s0, S1 = s1, S2 = s2, S3 = s3;
            }
            function set_iv(i0, i1, i2, i3) {
              i0 = i0 | 0;
              i1 = i1 | 0;
              i2 = i2 | 0;
              i3 = i3 | 0;
              I0 = i0, I1 = i1, I2 = i2, I3 = i3;
            }
            function set_nonce(n0, n1, n2, n3) {
              n0 = n0 | 0;
              n1 = n1 | 0;
              n2 = n2 | 0;
              n3 = n3 | 0;
              N0 = n0, N1 = n1, N2 = n2, N3 = n3;
            }
            function set_mask(m0, m1, m2, m3) {
              m0 = m0 | 0;
              m1 = m1 | 0;
              m2 = m2 | 0;
              m3 = m3 | 0;
              M0 = m0, M1 = m1, M2 = m2, M3 = m3;
            }
            function set_counter(c0, c1, c2, c3) {
              c0 = c0 | 0;
              c1 = c1 | 0;
              c2 = c2 | 0;
              c3 = c3 | 0;
              N3 = ~M3 & N3 | M3 & c3, N2 = ~M2 & N2 | M2 & c2, N1 = ~M1 & N1 | M1 & c1, N0 = ~M0 & N0 | M0 & c0;
            }
            function get_state(pos) {
              pos = pos | 0;
              if (pos & 15)
                return -1;
              DATA[pos | 0] = S0 >>> 24, DATA[pos | 1] = S0 >>> 16 & 255, DATA[pos | 2] = S0 >>> 8 & 255, DATA[pos | 3] = S0 & 255, DATA[pos | 4] = S1 >>> 24, DATA[pos | 5] = S1 >>> 16 & 255, DATA[pos | 6] = S1 >>> 8 & 255, DATA[pos | 7] = S1 & 255, DATA[pos | 8] = S2 >>> 24, DATA[pos | 9] = S2 >>> 16 & 255, DATA[pos | 10] = S2 >>> 8 & 255, DATA[pos | 11] = S2 & 255, DATA[pos | 12] = S3 >>> 24, DATA[pos | 13] = S3 >>> 16 & 255, DATA[pos | 14] = S3 >>> 8 & 255, DATA[pos | 15] = S3 & 255;
              return 16;
            }
            function get_iv(pos) {
              pos = pos | 0;
              if (pos & 15)
                return -1;
              DATA[pos | 0] = I0 >>> 24, DATA[pos | 1] = I0 >>> 16 & 255, DATA[pos | 2] = I0 >>> 8 & 255, DATA[pos | 3] = I0 & 255, DATA[pos | 4] = I1 >>> 24, DATA[pos | 5] = I1 >>> 16 & 255, DATA[pos | 6] = I1 >>> 8 & 255, DATA[pos | 7] = I1 & 255, DATA[pos | 8] = I2 >>> 24, DATA[pos | 9] = I2 >>> 16 & 255, DATA[pos | 10] = I2 >>> 8 & 255, DATA[pos | 11] = I2 & 255, DATA[pos | 12] = I3 >>> 24, DATA[pos | 13] = I3 >>> 16 & 255, DATA[pos | 14] = I3 >>> 8 & 255, DATA[pos | 15] = I3 & 255;
              return 16;
            }
            function gcm_init() {
              _ecb_enc(0, 0, 0, 0);
              H0 = S0, H1 = S1, H2 = S2, H3 = S3;
            }
            function cipher(mode, pos, len) {
              mode = mode | 0;
              pos = pos | 0;
              len = len | 0;
              var ret = 0;
              if (pos & 15)
                return -1;
              while ((len | 0) >= 16) {
                _cipher_modes[mode & 7](DATA[pos | 0] << 24 | DATA[pos | 1] << 16 | DATA[pos | 2] << 8 | DATA[pos | 3], DATA[pos | 4] << 24 | DATA[pos | 5] << 16 | DATA[pos | 6] << 8 | DATA[pos | 7], DATA[pos | 8] << 24 | DATA[pos | 9] << 16 | DATA[pos | 10] << 8 | DATA[pos | 11], DATA[pos | 12] << 24 | DATA[pos | 13] << 16 | DATA[pos | 14] << 8 | DATA[pos | 15]);
                DATA[pos | 0] = S0 >>> 24, DATA[pos | 1] = S0 >>> 16 & 255, DATA[pos | 2] = S0 >>> 8 & 255, DATA[pos | 3] = S0 & 255, DATA[pos | 4] = S1 >>> 24, DATA[pos | 5] = S1 >>> 16 & 255, DATA[pos | 6] = S1 >>> 8 & 255, DATA[pos | 7] = S1 & 255, DATA[pos | 8] = S2 >>> 24, DATA[pos | 9] = S2 >>> 16 & 255, DATA[pos | 10] = S2 >>> 8 & 255, DATA[pos | 11] = S2 & 255, DATA[pos | 12] = S3 >>> 24, DATA[pos | 13] = S3 >>> 16 & 255, DATA[pos | 14] = S3 >>> 8 & 255, DATA[pos | 15] = S3 & 255;
                ret = ret + 16 | 0, pos = pos + 16 | 0, len = len - 16 | 0;
              }
              return ret | 0;
            }
            function mac(mode, pos, len) {
              mode = mode | 0;
              pos = pos | 0;
              len = len | 0;
              var ret = 0;
              if (pos & 15)
                return -1;
              while ((len | 0) >= 16) {
                _mac_modes[mode & 1](DATA[pos | 0] << 24 | DATA[pos | 1] << 16 | DATA[pos | 2] << 8 | DATA[pos | 3], DATA[pos | 4] << 24 | DATA[pos | 5] << 16 | DATA[pos | 6] << 8 | DATA[pos | 7], DATA[pos | 8] << 24 | DATA[pos | 9] << 16 | DATA[pos | 10] << 8 | DATA[pos | 11], DATA[pos | 12] << 24 | DATA[pos | 13] << 16 | DATA[pos | 14] << 8 | DATA[pos | 15]);
                ret = ret + 16 | 0, pos = pos + 16 | 0, len = len - 16 | 0;
              }
              return ret | 0;
            }
            var _cipher_modes = [_ecb_enc, _ecb_dec, _cbc_enc, _cbc_dec, _cfb_enc, _cfb_dec, _ofb, _ctr];
            var _mac_modes = [_cbc_enc, _gcm_mac];
            return {
              set_rounds,
              set_state,
              set_iv,
              set_nonce,
              set_mask,
              set_counter,
              get_state,
              get_iv,
              gcm_init,
              cipher,
              mac
            };
          }(stdlib, foreign, buffer);
          asm.set_key = set_key;
          return asm;
        };
        wrapper.ENC = {
          ECB: 0,
          CBC: 2,
          CFB: 4,
          OFB: 6,
          CTR: 7
        }, wrapper.DEC = {
          ECB: 1,
          CBC: 3,
          CFB: 5,
          OFB: 6,
          CTR: 7
        }, wrapper.MAC = {
          CBC: 0,
          GCM: 1
        };
        wrapper.HEAP_DATA = 16384;
        return wrapper;
      }();
      var AES = function() {
        function AES2(key, iv, padding, mode) {
          if (padding === void 0) {
            padding = true;
          }
          this.pos = 0;
          this.len = 0;
          this.mode = mode;
          this.heap = _heap_init().subarray(AES_asm.HEAP_DATA);
          this.asm = new AES_asm(null, this.heap.buffer);
          this.pos = 0;
          this.len = 0;
          var keylen = key.length;
          if (keylen !== 16 && keylen !== 24 && keylen !== 32)
            throw new IllegalArgumentError("illegal key size");
          var keyview = new DataView(key.buffer, key.byteOffset, key.byteLength);
          this.asm.set_key(keylen >> 2, keyview.getUint32(0), keyview.getUint32(4), keyview.getUint32(8), keyview.getUint32(12), keylen > 16 ? keyview.getUint32(16) : 0, keylen > 16 ? keyview.getUint32(20) : 0, keylen > 24 ? keyview.getUint32(24) : 0, keylen > 24 ? keyview.getUint32(28) : 0);
          if (iv !== void 0) {
            if (iv.length !== 16)
              throw new IllegalArgumentError("illegal iv size");
            var ivview = new DataView(iv.buffer, iv.byteOffset, iv.byteLength);
            this.asm.set_iv(ivview.getUint32(0), ivview.getUint32(4), ivview.getUint32(8), ivview.getUint32(12));
          } else {
            this.asm.set_iv(0, 0, 0, 0);
          }
          this.padding = padding;
        }
        AES2.prototype.AES_Encrypt_process = function(data) {
          if (!is_bytes(data))
            throw new TypeError("data isn't of expected type");
          var asm = this.asm;
          var heap = this.heap;
          var amode = AES_asm.ENC[this.mode];
          var hpos = AES_asm.HEAP_DATA;
          var pos = this.pos;
          var len = this.len;
          var dpos = 0;
          var dlen = data.length || 0;
          var rpos = 0;
          var rlen = len + dlen & -16;
          var wlen = 0;
          var result = new Uint8Array(rlen);
          while (dlen > 0) {
            wlen = _heap_write(heap, pos + len, data, dpos, dlen);
            len += wlen;
            dpos += wlen;
            dlen -= wlen;
            wlen = asm.cipher(amode, hpos + pos, len);
            if (wlen)
              result.set(heap.subarray(pos, pos + wlen), rpos);
            rpos += wlen;
            if (wlen < len) {
              pos += wlen;
              len -= wlen;
            } else {
              pos = 0;
              len = 0;
            }
          }
          this.pos = pos;
          this.len = len;
          return result;
        };
        AES2.prototype.AES_Encrypt_finish = function() {
          var asm = this.asm;
          var heap = this.heap;
          var amode = AES_asm.ENC[this.mode];
          var hpos = AES_asm.HEAP_DATA;
          var pos = this.pos;
          var len = this.len;
          var plen = 16 - len % 16;
          var rlen = len;
          if (this.hasOwnProperty("padding")) {
            if (this.padding) {
              for (var p = 0; p < plen; ++p) {
                heap[pos + len + p] = plen;
              }
              len += plen;
              rlen = len;
            } else if (len % 16) {
              throw new IllegalArgumentError("data length must be a multiple of the block size");
            }
          } else {
            len += plen;
          }
          var result = new Uint8Array(rlen);
          if (len)
            asm.cipher(amode, hpos + pos, len);
          if (rlen)
            result.set(heap.subarray(pos, pos + rlen));
          this.pos = 0;
          this.len = 0;
          return result;
        };
        AES2.prototype.AES_Decrypt_process = function(data) {
          if (!is_bytes(data))
            throw new TypeError("data isn't of expected type");
          var asm = this.asm;
          var heap = this.heap;
          var amode = AES_asm.DEC[this.mode];
          var hpos = AES_asm.HEAP_DATA;
          var pos = this.pos;
          var len = this.len;
          var dpos = 0;
          var dlen = data.length || 0;
          var rpos = 0;
          var rlen = len + dlen & -16;
          var plen = 0;
          var wlen = 0;
          if (this.padding) {
            plen = len + dlen - rlen || 16;
            rlen -= plen;
          }
          var result = new Uint8Array(rlen);
          while (dlen > 0) {
            wlen = _heap_write(heap, pos + len, data, dpos, dlen);
            len += wlen;
            dpos += wlen;
            dlen -= wlen;
            wlen = asm.cipher(amode, hpos + pos, len - (!dlen ? plen : 0));
            if (wlen)
              result.set(heap.subarray(pos, pos + wlen), rpos);
            rpos += wlen;
            if (wlen < len) {
              pos += wlen;
              len -= wlen;
            } else {
              pos = 0;
              len = 0;
            }
          }
          this.pos = pos;
          this.len = len;
          return result;
        };
        AES2.prototype.AES_Decrypt_finish = function() {
          var asm = this.asm;
          var heap = this.heap;
          var amode = AES_asm.DEC[this.mode];
          var hpos = AES_asm.HEAP_DATA;
          var pos = this.pos;
          var len = this.len;
          var rlen = len;
          if (len > 0) {
            if (len % 16) {
              if (this.hasOwnProperty("padding")) {
                throw new IllegalArgumentError("data length must be a multiple of the block size");
              } else {
                len += 16 - len % 16;
              }
            }
            asm.cipher(amode, hpos + pos, len);
            if (this.hasOwnProperty("padding") && this.padding) {
              var pad = heap[pos + rlen - 1];
              if (pad < 1 || pad > 16 || pad > rlen)
                throw new SecurityError("bad padding");
              var pcheck = 0;
              for (var i = pad; i > 1; i--)
                pcheck |= pad ^ heap[pos + rlen - i];
              if (pcheck)
                throw new SecurityError("bad padding");
              rlen -= pad;
            }
          }
          var result = new Uint8Array(rlen);
          if (rlen > 0) {
            result.set(heap.subarray(pos, pos + rlen));
          }
          this.pos = 0;
          this.len = 0;
          return result;
        };
        return AES2;
      }();
      var __extends$1 = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var AES_CBC = function(_super) {
        __extends$1(AES_CBC2, _super);
        function AES_CBC2(key, iv, padding) {
          if (padding === void 0) {
            padding = true;
          }
          return _super.call(this, key, iv, padding, "CBC") || this;
        }
        AES_CBC2.encrypt = function(data, key, padding, iv) {
          if (padding === void 0) {
            padding = true;
          }
          return new AES_CBC2(key, iv, padding).encrypt(data);
        };
        AES_CBC2.decrypt = function(data, key, padding, iv) {
          if (padding === void 0) {
            padding = true;
          }
          return new AES_CBC2(key, iv, padding).decrypt(data);
        };
        AES_CBC2.prototype.encrypt = function(data) {
          var r1 = this.AES_Encrypt_process(data);
          var r2 = this.AES_Encrypt_finish();
          return joinBytes(r1, r2);
        };
        AES_CBC2.prototype.decrypt = function(data) {
          var r1 = this.AES_Decrypt_process(data);
          var r2 = this.AES_Decrypt_finish();
          return joinBytes(r1, r2);
        };
        return AES_CBC2;
      }(AES);
      var __extends$2 = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var _AES_CCM_adata_maxLength = 65279;
      var _AES_CCM_data_maxLength = 4503599627370480;
      var AES_CCM = function(_super) {
        __extends$2(AES_CCM2, _super);
        function AES_CCM2(key, nonce, adata, tagSize, dataLength) {
          if (tagSize === void 0) {
            tagSize = 16;
          }
          var _this = _super.call(this, key, void 0, void 0, "CCM") || this;
          _this.counter = 1;
          _this.dataLength = -1;
          if (tagSize < 4 || tagSize > 16 || tagSize & 1)
            throw new IllegalArgumentError("illegal tagSize value");
          _this.tagSize = tagSize;
          _this.nonce = nonce;
          if (nonce.length < 8 || nonce.length > 13)
            throw new IllegalArgumentError("illegal nonce length");
          _this.lengthSize = 15 - nonce.length;
          nonce = new Uint8Array(nonce.length + 1);
          nonce[0] = _this.lengthSize - 1;
          nonce.set(_this.nonce, 1);
          if (dataLength < 0 || dataLength > _AES_CCM_data_maxLength || dataLength > Math.pow(2, 8 * _this.lengthSize) - 16)
            throw new IllegalArgumentError("illegal dataLength value");
          if (adata !== void 0) {
            if (adata.length > _AES_CCM_adata_maxLength)
              throw new IllegalArgumentError("illegal adata length");
            _this.adata = adata.length ? adata : void 0;
          }
          _this.dataLength = dataLength;
          _this.counter = 1;
          _this.AES_CCM_calculate_iv();
          _this.AES_CTR_set_options(nonce, _this.counter, 8 * _this.lengthSize);
          return _this;
        }
        AES_CCM2.encrypt = function(clear, key, nonce, adata, tagsize) {
          if (tagsize === void 0) {
            tagsize = 16;
          }
          return new AES_CCM2(key, nonce, adata, tagsize, clear.length).encrypt(clear);
        };
        AES_CCM2.decrypt = function(cipher, key, nonce, adata, tagsize) {
          if (tagsize === void 0) {
            tagsize = 16;
          }
          return new AES_CCM2(key, nonce, adata, tagsize, cipher.length - tagsize).decrypt(cipher);
        };
        AES_CCM2.prototype.encrypt = function(data) {
          this.dataLength = data.length || 0;
          var result1 = this.AES_CCM_Encrypt_process(data);
          var result2 = this.AES_CCM_Encrypt_finish();
          var result = new Uint8Array(result1.length + result2.length);
          if (result1.length)
            result.set(result1);
          if (result2.length)
            result.set(result2, result1.length);
          return result;
        };
        AES_CCM2.prototype.decrypt = function(data) {
          this.dataLength = data.length || 0;
          var result1 = this.AES_CCM_Decrypt_process(data);
          var result2 = this.AES_CCM_Decrypt_finish();
          var result = new Uint8Array(result1.length + result2.length);
          if (result1.length)
            result.set(result1);
          if (result2.length)
            result.set(result2, result1.length);
          return result;
        };
        AES_CCM2.prototype.AES_CCM_calculate_iv = function() {
          var nonce = this.nonce;
          var adata = this.adata;
          var tagSize = this.tagSize;
          var lengthSize = this.lengthSize;
          var dataLength = this.dataLength;
          var data = new Uint8Array(16 + (adata ? 2 + adata.length : 0));
          data[0] = (adata ? 64 : 0) | tagSize - 2 << 2 | lengthSize - 1;
          data.set(nonce, 1);
          if (lengthSize > 6)
            data[9] = dataLength / 4294967296 >>> 16 & 15;
          if (lengthSize > 5)
            data[10] = dataLength / 4294967296 >>> 8 & 255;
          if (lengthSize > 4)
            data[11] = dataLength / 4294967296 & 255;
          if (lengthSize > 3)
            data[12] = dataLength >>> 24;
          if (lengthSize > 2)
            data[13] = dataLength >>> 16 & 255;
          data[14] = dataLength >>> 8 & 255;
          data[15] = dataLength & 255;
          if (adata) {
            data[16] = adata.length >>> 8 & 255;
            data[17] = adata.length & 255;
            data.set(adata, 18);
          }
          this._cbc_mac_process(data);
          this.asm.get_state(AES_asm.HEAP_DATA);
          var iv = new Uint8Array(this.heap.subarray(0, 16));
          var ivview = new DataView(iv.buffer, iv.byteOffset, iv.byteLength);
          this.asm.set_iv(ivview.getUint32(0), ivview.getUint32(4), ivview.getUint32(8), ivview.getUint32(12));
        };
        AES_CCM2.prototype._cbc_mac_process = function(data) {
          var heap = this.heap;
          var asm = this.asm;
          var dpos = 0;
          var dlen = data.length || 0;
          var wlen = 0;
          while (dlen > 0) {
            wlen = _heap_write(heap, 0, data, dpos, dlen);
            while (wlen & 15)
              heap[wlen++] = 0;
            dpos += wlen;
            dlen -= wlen;
            asm.mac(AES_asm.MAC.CBC, AES_asm.HEAP_DATA, wlen);
          }
        };
        AES_CCM2.prototype.AES_CCM_Encrypt_process = function(data) {
          var asm = this.asm;
          var heap = this.heap;
          var dpos = 0;
          var dlen = data.length || 0;
          var counter = this.counter;
          var pos = this.pos;
          var len = this.len;
          var rlen = len + dlen & -16;
          var rpos = 0;
          var wlen = 0;
          if ((counter - 1 << 4) + len + dlen > _AES_CCM_data_maxLength)
            throw new RangeError("counter overflow");
          var result = new Uint8Array(rlen);
          while (dlen > 0) {
            wlen = _heap_write(heap, pos + len, data, dpos, dlen);
            len += wlen;
            dpos += wlen;
            dlen -= wlen;
            wlen = asm.mac(AES_asm.MAC.CBC, AES_asm.HEAP_DATA + pos, len);
            wlen = asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA + pos, wlen);
            if (wlen)
              result.set(heap.subarray(pos, pos + wlen), rpos);
            counter += wlen >>> 4;
            rpos += wlen;
            if (wlen < len) {
              pos += wlen;
              len -= wlen;
            } else {
              pos = 0;
              len = 0;
            }
          }
          this.counter = counter;
          this.pos = pos;
          this.len = len;
          return result;
        };
        AES_CCM2.prototype.AES_CCM_Encrypt_finish = function() {
          var asm = this.asm;
          var heap = this.heap;
          var tagSize = this.tagSize;
          var pos = this.pos;
          var len = this.len;
          var result = new Uint8Array(len + tagSize);
          var i = len;
          for (; i & 15; i++)
            heap[pos + i] = 0;
          asm.mac(AES_asm.MAC.CBC, AES_asm.HEAP_DATA + pos, i);
          asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA + pos, i);
          if (len)
            result.set(heap.subarray(pos, pos + len));
          asm.set_counter(0, 0, 0, 0);
          asm.get_iv(AES_asm.HEAP_DATA);
          asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA, 16);
          result.set(heap.subarray(0, tagSize), len);
          this.counter = 1;
          this.pos = 0;
          this.len = 0;
          return result;
        };
        AES_CCM2.prototype.AES_CCM_Decrypt_process = function(data) {
          var dpos = 0;
          var dlen = data.length || 0;
          var asm = this.asm;
          var heap = this.heap;
          var counter = this.counter;
          var tagSize = this.tagSize;
          var pos = this.pos;
          var len = this.len;
          var rpos = 0;
          var rlen = len + dlen > tagSize ? len + dlen - tagSize & -16 : 0;
          var tlen = len + dlen - rlen;
          var wlen = 0;
          if ((counter - 1 << 4) + len + dlen > _AES_CCM_data_maxLength)
            throw new RangeError("counter overflow");
          var result = new Uint8Array(rlen);
          while (dlen > tlen) {
            wlen = _heap_write(heap, pos + len, data, dpos, dlen - tlen);
            len += wlen;
            dpos += wlen;
            dlen -= wlen;
            wlen = asm.cipher(AES_asm.DEC.CTR, AES_asm.HEAP_DATA + pos, wlen);
            wlen = asm.mac(AES_asm.MAC.CBC, AES_asm.HEAP_DATA + pos, wlen);
            if (wlen)
              result.set(heap.subarray(pos, pos + wlen), rpos);
            counter += wlen >>> 4;
            rpos += wlen;
            pos = 0;
            len = 0;
          }
          if (dlen > 0) {
            len += _heap_write(heap, 0, data, dpos, dlen);
          }
          this.counter = counter;
          this.pos = pos;
          this.len = len;
          return result;
        };
        AES_CCM2.prototype.AES_CCM_Decrypt_finish = function() {
          var asm = this.asm;
          var heap = this.heap;
          var tagSize = this.tagSize;
          var pos = this.pos;
          var len = this.len;
          var rlen = len - tagSize;
          if (len < tagSize)
            throw new IllegalStateError("authentication tag not found");
          var result = new Uint8Array(rlen);
          var atag = new Uint8Array(heap.subarray(pos + rlen, pos + len));
          asm.cipher(AES_asm.DEC.CTR, AES_asm.HEAP_DATA + pos, rlen + 15 & -16);
          result.set(heap.subarray(pos, pos + rlen));
          var i = rlen;
          for (; i & 15; i++)
            heap[pos + i] = 0;
          asm.mac(AES_asm.MAC.CBC, AES_asm.HEAP_DATA + pos, i);
          asm.set_counter(0, 0, 0, 0);
          asm.get_iv(AES_asm.HEAP_DATA);
          asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA, 16);
          var acheck = 0;
          for (var j = 0; j < tagSize; ++j)
            acheck |= atag[j] ^ heap[j];
          if (acheck)
            throw new SecurityError("data integrity check failed");
          this.counter = 1;
          this.pos = 0;
          this.len = 0;
          return result;
        };
        AES_CCM2.prototype.AES_CTR_set_options = function(nonce, counter, size) {
          if (size < 8 || size > 48)
            throw new IllegalArgumentError("illegal counter size");
          var mask = Math.pow(2, size) - 1;
          this.asm.set_mask(0, 0, mask / 4294967296 | 0, mask | 0);
          var len = nonce.length;
          if (!len || len > 16)
            throw new IllegalArgumentError("illegal nonce size");
          this.nonce = nonce;
          var view = new DataView(new ArrayBuffer(16));
          new Uint8Array(view.buffer).set(nonce);
          this.asm.set_nonce(view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12));
          if (counter < 0 || counter >= Math.pow(2, size))
            throw new IllegalArgumentError("illegal counter value");
          this.counter = counter;
          this.asm.set_counter(0, 0, counter / 4294967296 | 0, counter | 0);
        };
        return AES_CCM2;
      }(AES);
      var __extends$3 = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var AES_CFB = function(_super) {
        __extends$3(AES_CFB2, _super);
        function AES_CFB2(key, iv) {
          var _this = _super.call(this, key, iv, true, "CFB") || this;
          delete _this.padding;
          return _this;
        }
        AES_CFB2.encrypt = function(data, key, iv) {
          return new AES_CFB2(key, iv).encrypt(data);
        };
        AES_CFB2.decrypt = function(data, key, iv) {
          return new AES_CFB2(key, iv).decrypt(data);
        };
        AES_CFB2.prototype.encrypt = function(data) {
          var r1 = this.AES_Encrypt_process(data);
          var r2 = this.AES_Encrypt_finish();
          return joinBytes(r1, r2);
        };
        AES_CFB2.prototype.decrypt = function(data) {
          var r1 = this.AES_Decrypt_process(data);
          var r2 = this.AES_Decrypt_finish();
          return joinBytes(r1, r2);
        };
        return AES_CFB2;
      }(AES);
      var __extends$4 = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var AES_ECB = function(_super) {
        __extends$4(AES_ECB2, _super);
        function AES_ECB2(key, padding) {
          if (padding === void 0) {
            padding = false;
          }
          return _super.call(this, key, void 0, padding, "ECB") || this;
        }
        AES_ECB2.encrypt = function(data, key, padding) {
          if (padding === void 0) {
            padding = false;
          }
          return new AES_ECB2(key, padding).encrypt(data);
        };
        AES_ECB2.decrypt = function(data, key, padding) {
          if (padding === void 0) {
            padding = false;
          }
          return new AES_ECB2(key, padding).decrypt(data);
        };
        AES_ECB2.prototype.encrypt = function(data) {
          var r1 = this.AES_Encrypt_process(data);
          var r2 = this.AES_Encrypt_finish();
          return joinBytes(r1, r2);
        };
        AES_ECB2.prototype.decrypt = function(data) {
          var r1 = this.AES_Decrypt_process(data);
          var r2 = this.AES_Decrypt_finish();
          return joinBytes(r1, r2);
        };
        return AES_ECB2;
      }(AES);
      function mul2(data) {
        var t = data[0] & 128;
        for (var i = 0; i < 15; i++) {
          data[i] = data[i] << 1 ^ (data[i + 1] & 128 ? 1 : 0);
        }
        data[15] = data[15] << 1 ^ (t ? 135 : 0);
      }
      var AES_CMAC = function() {
        function AES_CMAC2(key) {
          this.bufferLength = 0;
          this.k = new AES_ECB(key).encrypt(new Uint8Array(16));
          mul2(this.k);
          this.cbc = new AES_CBC(key, new Uint8Array(16), false);
          this.buffer = new Uint8Array(16);
          this.result = null;
        }
        AES_CMAC2.bytes = function(data, key) {
          return new AES_CMAC2(key).process(data).finish().result;
        };
        AES_CMAC2.prototype.process = function(data) {
          if (this.bufferLength + data.length > 16) {
            this.cbc.encrypt(this.buffer.subarray(0, this.bufferLength));
            var offset = (this.bufferLength + data.length - 1 & ~15) - this.bufferLength;
            this.cbc.encrypt(data.subarray(0, offset));
            this.buffer.set(data.subarray(offset));
            this.bufferLength = data.length - offset;
          } else {
            this.buffer.set(data, this.bufferLength);
            this.bufferLength += data.length;
          }
          return this;
        };
        AES_CMAC2.prototype.finish = function() {
          if (this.bufferLength !== 16) {
            this.buffer[this.bufferLength] = 128;
            for (var i = this.bufferLength + 1; i < 16; i++) {
              this.buffer[i] = 0;
            }
            mul2(this.k);
          }
          for (var i = 0; i < 16; i++) {
            this.buffer[i] ^= this.k[i];
          }
          this.result = this.cbc.encrypt(this.buffer);
          return this;
        };
        return AES_CMAC2;
      }();
      var __extends$5 = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var AES_CTR = function(_super) {
        __extends$5(AES_CTR2, _super);
        function AES_CTR2(key, nonce) {
          var _this = _super.call(this, key, void 0, false, "CTR") || this;
          delete _this.padding;
          _this.AES_CTR_set_options(nonce);
          return _this;
        }
        AES_CTR2.encrypt = function(data, key, nonce) {
          return new AES_CTR2(key, nonce).encrypt(data);
        };
        AES_CTR2.decrypt = function(data, key, nonce) {
          return new AES_CTR2(key, nonce).encrypt(data);
        };
        AES_CTR2.prototype.encrypt = function(data) {
          var r1 = this.AES_Encrypt_process(data);
          var r2 = this.AES_Encrypt_finish();
          return joinBytes(r1, r2);
        };
        AES_CTR2.prototype.decrypt = function(data) {
          var r1 = this.AES_Encrypt_process(data);
          var r2 = this.AES_Encrypt_finish();
          return joinBytes(r1, r2);
        };
        AES_CTR2.prototype.AES_CTR_set_options = function(nonce, counter, size) {
          if (size !== void 0) {
            if (size < 8 || size > 48)
              throw new IllegalArgumentError("illegal counter size");
            var mask = Math.pow(2, size) - 1;
            this.asm.set_mask(0, 0, mask / 4294967296 | 0, mask | 0);
          } else {
            size = 48;
            this.asm.set_mask(0, 0, 65535, 4294967295);
          }
          if (nonce !== void 0) {
            var len = nonce.length;
            if (!len || len > 16)
              throw new IllegalArgumentError("illegal nonce size");
            var view = new DataView(new ArrayBuffer(16));
            new Uint8Array(view.buffer).set(nonce);
            this.asm.set_nonce(view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12));
          } else {
            throw new Error("nonce is required");
          }
          if (counter !== void 0) {
            if (counter < 0 || counter >= Math.pow(2, size))
              throw new IllegalArgumentError("illegal counter value");
            this.asm.set_counter(0, 0, counter / 4294967296 | 0, counter | 0);
          }
        };
        return AES_CTR2;
      }(AES);
      var __extends$6 = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var _AES_GCM_data_maxLength = 68719476704;
      var AES_GCM = function(_super) {
        __extends$6(AES_GCM2, _super);
        function AES_GCM2(key, nonce, adata, tagSize) {
          if (tagSize === void 0) {
            tagSize = 16;
          }
          var _this = _super.call(this, key, void 0, false, "CTR") || this;
          _this.tagSize = tagSize;
          _this.gamma0 = 0;
          _this.counter = 1;
          _this.asm.gcm_init();
          if (_this.tagSize < 4 || _this.tagSize > 16)
            throw new IllegalArgumentError("illegal tagSize value");
          var noncelen = nonce.length || 0;
          var noncebuf = new Uint8Array(16);
          if (noncelen !== 12) {
            _this._gcm_mac_process(nonce);
            _this.heap[0] = 0;
            _this.heap[1] = 0;
            _this.heap[2] = 0;
            _this.heap[3] = 0;
            _this.heap[4] = 0;
            _this.heap[5] = 0;
            _this.heap[6] = 0;
            _this.heap[7] = 0;
            _this.heap[8] = 0;
            _this.heap[9] = 0;
            _this.heap[10] = 0;
            _this.heap[11] = noncelen >>> 29;
            _this.heap[12] = noncelen >>> 21 & 255;
            _this.heap[13] = noncelen >>> 13 & 255;
            _this.heap[14] = noncelen >>> 5 & 255;
            _this.heap[15] = noncelen << 3 & 255;
            _this.asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA, 16);
            _this.asm.get_iv(AES_asm.HEAP_DATA);
            _this.asm.set_iv(0, 0, 0, 0);
            noncebuf.set(_this.heap.subarray(0, 16));
          } else {
            noncebuf.set(nonce);
            noncebuf[15] = 1;
          }
          var nonceview = new DataView(noncebuf.buffer);
          _this.gamma0 = nonceview.getUint32(12);
          _this.asm.set_nonce(nonceview.getUint32(0), nonceview.getUint32(4), nonceview.getUint32(8), 0);
          _this.asm.set_mask(0, 0, 0, 4294967295);
          if (adata !== void 0) {
            if (adata.length > _AES_GCM_data_maxLength)
              throw new IllegalArgumentError("illegal adata length");
            if (adata.length) {
              _this.adata = adata;
              _this._gcm_mac_process(adata);
            } else {
              _this.adata = void 0;
            }
          } else {
            _this.adata = void 0;
          }
          if (_this.counter < 1 || _this.counter > 4294967295)
            throw new RangeError("counter must be a positive 32-bit integer");
          _this.asm.set_counter(0, 0, 0, _this.gamma0 + _this.counter | 0);
          return _this;
        }
        AES_GCM2.encrypt = function(cleartext, key, nonce, adata, tagsize) {
          return new AES_GCM2(key, nonce, adata, tagsize).encrypt(cleartext);
        };
        AES_GCM2.decrypt = function(ciphertext, key, nonce, adata, tagsize) {
          return new AES_GCM2(key, nonce, adata, tagsize).decrypt(ciphertext);
        };
        AES_GCM2.prototype.encrypt = function(data) {
          return this.AES_GCM_encrypt(data);
        };
        AES_GCM2.prototype.decrypt = function(data) {
          return this.AES_GCM_decrypt(data);
        };
        AES_GCM2.prototype.AES_GCM_Encrypt_process = function(data) {
          var dpos = 0;
          var dlen = data.length || 0;
          var asm = this.asm;
          var heap = this.heap;
          var counter = this.counter;
          var pos = this.pos;
          var len = this.len;
          var rpos = 0;
          var rlen = len + dlen & -16;
          var wlen = 0;
          if ((counter - 1 << 4) + len + dlen > _AES_GCM_data_maxLength)
            throw new RangeError("counter overflow");
          var result = new Uint8Array(rlen);
          while (dlen > 0) {
            wlen = _heap_write(heap, pos + len, data, dpos, dlen);
            len += wlen;
            dpos += wlen;
            dlen -= wlen;
            wlen = asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA + pos, len);
            wlen = asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA + pos, wlen);
            if (wlen)
              result.set(heap.subarray(pos, pos + wlen), rpos);
            counter += wlen >>> 4;
            rpos += wlen;
            if (wlen < len) {
              pos += wlen;
              len -= wlen;
            } else {
              pos = 0;
              len = 0;
            }
          }
          this.counter = counter;
          this.pos = pos;
          this.len = len;
          return result;
        };
        AES_GCM2.prototype.AES_GCM_Encrypt_finish = function() {
          var asm = this.asm;
          var heap = this.heap;
          var counter = this.counter;
          var tagSize = this.tagSize;
          var adata = this.adata;
          var pos = this.pos;
          var len = this.len;
          var result = new Uint8Array(len + tagSize);
          asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA + pos, len + 15 & -16);
          if (len)
            result.set(heap.subarray(pos, pos + len));
          var i = len;
          for (; i & 15; i++)
            heap[pos + i] = 0;
          asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA + pos, i);
          var alen = adata !== void 0 ? adata.length : 0;
          var clen = (counter - 1 << 4) + len;
          heap[0] = 0;
          heap[1] = 0;
          heap[2] = 0;
          heap[3] = alen >>> 29;
          heap[4] = alen >>> 21;
          heap[5] = alen >>> 13 & 255;
          heap[6] = alen >>> 5 & 255;
          heap[7] = alen << 3 & 255;
          heap[8] = heap[9] = heap[10] = 0;
          heap[11] = clen >>> 29;
          heap[12] = clen >>> 21 & 255;
          heap[13] = clen >>> 13 & 255;
          heap[14] = clen >>> 5 & 255;
          heap[15] = clen << 3 & 255;
          asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA, 16);
          asm.get_iv(AES_asm.HEAP_DATA);
          asm.set_counter(0, 0, 0, this.gamma0);
          asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA, 16);
          result.set(heap.subarray(0, tagSize), len);
          this.counter = 1;
          this.pos = 0;
          this.len = 0;
          return result;
        };
        AES_GCM2.prototype.AES_GCM_Decrypt_process = function(data) {
          var dpos = 0;
          var dlen = data.length || 0;
          var asm = this.asm;
          var heap = this.heap;
          var counter = this.counter;
          var tagSize = this.tagSize;
          var pos = this.pos;
          var len = this.len;
          var rpos = 0;
          var rlen = len + dlen > tagSize ? len + dlen - tagSize & -16 : 0;
          var tlen = len + dlen - rlen;
          var wlen = 0;
          if ((counter - 1 << 4) + len + dlen > _AES_GCM_data_maxLength)
            throw new RangeError("counter overflow");
          var result = new Uint8Array(rlen);
          while (dlen > tlen) {
            wlen = _heap_write(heap, pos + len, data, dpos, dlen - tlen);
            len += wlen;
            dpos += wlen;
            dlen -= wlen;
            wlen = asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA + pos, wlen);
            wlen = asm.cipher(AES_asm.DEC.CTR, AES_asm.HEAP_DATA + pos, wlen);
            if (wlen)
              result.set(heap.subarray(pos, pos + wlen), rpos);
            counter += wlen >>> 4;
            rpos += wlen;
            pos = 0;
            len = 0;
          }
          if (dlen > 0) {
            len += _heap_write(heap, 0, data, dpos, dlen);
          }
          this.counter = counter;
          this.pos = pos;
          this.len = len;
          return result;
        };
        AES_GCM2.prototype.AES_GCM_Decrypt_finish = function() {
          var asm = this.asm;
          var heap = this.heap;
          var tagSize = this.tagSize;
          var adata = this.adata;
          var counter = this.counter;
          var pos = this.pos;
          var len = this.len;
          var rlen = len - tagSize;
          if (len < tagSize)
            throw new IllegalStateError("authentication tag not found");
          var result = new Uint8Array(rlen);
          var atag = new Uint8Array(heap.subarray(pos + rlen, pos + len));
          var i = rlen;
          for (; i & 15; i++)
            heap[pos + i] = 0;
          asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA + pos, i);
          asm.cipher(AES_asm.DEC.CTR, AES_asm.HEAP_DATA + pos, i);
          if (rlen)
            result.set(heap.subarray(pos, pos + rlen));
          var alen = adata !== void 0 ? adata.length : 0;
          var clen = (counter - 1 << 4) + len - tagSize;
          heap[0] = 0;
          heap[1] = 0;
          heap[2] = 0;
          heap[3] = alen >>> 29;
          heap[4] = alen >>> 21;
          heap[5] = alen >>> 13 & 255;
          heap[6] = alen >>> 5 & 255;
          heap[7] = alen << 3 & 255;
          heap[8] = heap[9] = heap[10] = 0;
          heap[11] = clen >>> 29;
          heap[12] = clen >>> 21 & 255;
          heap[13] = clen >>> 13 & 255;
          heap[14] = clen >>> 5 & 255;
          heap[15] = clen << 3 & 255;
          asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA, 16);
          asm.get_iv(AES_asm.HEAP_DATA);
          asm.set_counter(0, 0, 0, this.gamma0);
          asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA, 16);
          var acheck = 0;
          for (var i_1 = 0; i_1 < tagSize; ++i_1)
            acheck |= atag[i_1] ^ heap[i_1];
          if (acheck)
            throw new SecurityError("data integrity check failed");
          this.counter = 1;
          this.pos = 0;
          this.len = 0;
          return result;
        };
        AES_GCM2.prototype.AES_GCM_decrypt = function(data) {
          var result1 = this.AES_GCM_Decrypt_process(data);
          var result2 = this.AES_GCM_Decrypt_finish();
          var result = new Uint8Array(result1.length + result2.length);
          if (result1.length)
            result.set(result1);
          if (result2.length)
            result.set(result2, result1.length);
          return result;
        };
        AES_GCM2.prototype.AES_GCM_encrypt = function(data) {
          var result1 = this.AES_GCM_Encrypt_process(data);
          var result2 = this.AES_GCM_Encrypt_finish();
          var result = new Uint8Array(result1.length + result2.length);
          if (result1.length)
            result.set(result1);
          if (result2.length)
            result.set(result2, result1.length);
          return result;
        };
        AES_GCM2.prototype._gcm_mac_process = function(data) {
          var heap = this.heap;
          var asm = this.asm;
          var dpos = 0;
          var dlen = data.length || 0;
          var wlen = 0;
          while (dlen > 0) {
            wlen = _heap_write(heap, 0, data, dpos, dlen);
            dpos += wlen;
            dlen -= wlen;
            while (wlen & 15)
              heap[wlen++] = 0;
            asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA, wlen);
          }
        };
        return AES_GCM2;
      }(AES);
      var __extends$7 = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var AES_OFB = function(_super) {
        __extends$7(AES_OFB2, _super);
        function AES_OFB2(key, iv) {
          return _super.call(this, key, iv, false, "OFB") || this;
        }
        AES_OFB2.encrypt = function(data, key, iv) {
          return new AES_OFB2(key, iv).encrypt(data);
        };
        AES_OFB2.decrypt = function(data, key, iv) {
          return new AES_OFB2(key, iv).decrypt(data);
        };
        AES_OFB2.prototype.encrypt = function(data) {
          var r1 = this.AES_Encrypt_process(data);
          var r2 = this.AES_Encrypt_finish();
          return joinBytes(r1, r2);
        };
        AES_OFB2.prototype.decrypt = function(data) {
          var r1 = this.AES_Decrypt_process(data);
          var r2 = this.AES_Decrypt_finish();
          return joinBytes(r1, r2);
        };
        return AES_OFB2;
      }(AES);
      var bigint_asm = function(stdlib, foreign, buffer) {
        ;
        var SP = 0;
        var HEAP32 = new stdlib.Uint32Array(buffer);
        var imul = stdlib.Math.imul;
        function sreset(p) {
          p = p | 0;
          SP = p = p + 31 & -32;
          return p | 0;
        }
        function salloc(l) {
          l = l | 0;
          var p = 0;
          p = SP;
          SP = p + (l + 31 & -32) | 0;
          return p | 0;
        }
        function sfree(l) {
          l = l | 0;
          SP = SP - (l + 31 & -32) | 0;
        }
        function cp(l, A, B) {
          l = l | 0;
          A = A | 0;
          B = B | 0;
          var i = 0;
          if ((A | 0) > (B | 0)) {
            for (; (i | 0) < (l | 0); i = i + 4 | 0) {
              HEAP32[B + i >> 2] = HEAP32[A + i >> 2];
            }
          } else {
            for (i = l - 4 | 0; (i | 0) >= 0; i = i - 4 | 0) {
              HEAP32[B + i >> 2] = HEAP32[A + i >> 2];
            }
          }
        }
        function z(l, z2, A) {
          l = l | 0;
          z2 = z2 | 0;
          A = A | 0;
          var i = 0;
          for (; (i | 0) < (l | 0); i = i + 4 | 0) {
            HEAP32[A + i >> 2] = z2;
          }
        }
        function neg(A, lA, R, lR) {
          A = A | 0;
          lA = lA | 0;
          R = R | 0;
          lR = lR | 0;
          var a = 0, c = 0, t = 0, r = 0, i = 0;
          if ((lR | 0) <= 0)
            lR = lA;
          if ((lR | 0) < (lA | 0))
            lA = lR;
          c = 1;
          for (; (i | 0) < (lA | 0); i = i + 4 | 0) {
            a = ~HEAP32[A + i >> 2];
            t = (a & 65535) + c | 0;
            r = (a >>> 16) + (t >>> 16) | 0;
            HEAP32[R + i >> 2] = r << 16 | t & 65535;
            c = r >>> 16;
          }
          for (; (i | 0) < (lR | 0); i = i + 4 | 0) {
            HEAP32[R + i >> 2] = c - 1 | 0;
          }
          return c | 0;
        }
        function cmp(A, lA, B, lB) {
          A = A | 0;
          lA = lA | 0;
          B = B | 0;
          lB = lB | 0;
          var a = 0, b = 0, i = 0;
          if ((lA | 0) > (lB | 0)) {
            for (i = lA - 4 | 0; (i | 0) >= (lB | 0); i = i - 4 | 0) {
              if (HEAP32[A + i >> 2] | 0)
                return 1;
            }
          } else {
            for (i = lB - 4 | 0; (i | 0) >= (lA | 0); i = i - 4 | 0) {
              if (HEAP32[B + i >> 2] | 0)
                return -1;
            }
          }
          for (; (i | 0) >= 0; i = i - 4 | 0) {
            a = HEAP32[A + i >> 2] | 0, b = HEAP32[B + i >> 2] | 0;
            if (a >>> 0 < b >>> 0)
              return -1;
            if (a >>> 0 > b >>> 0)
              return 1;
          }
          return 0;
        }
        function tst(A, lA) {
          A = A | 0;
          lA = lA | 0;
          var i = 0;
          for (i = lA - 4 | 0; (i | 0) >= 0; i = i - 4 | 0) {
            if (HEAP32[A + i >> 2] | 0)
              return i + 4 | 0;
          }
          return 0;
        }
        function add(A, lA, B, lB, R, lR) {
          A = A | 0;
          lA = lA | 0;
          B = B | 0;
          lB = lB | 0;
          R = R | 0;
          lR = lR | 0;
          var a = 0, b = 0, c = 0, t = 0, r = 0, i = 0;
          if ((lA | 0) < (lB | 0)) {
            t = A, A = B, B = t;
            t = lA, lA = lB, lB = t;
          }
          if ((lR | 0) <= 0)
            lR = lA + 4 | 0;
          if ((lR | 0) < (lB | 0))
            lA = lB = lR;
          for (; (i | 0) < (lB | 0); i = i + 4 | 0) {
            a = HEAP32[A + i >> 2] | 0;
            b = HEAP32[B + i >> 2] | 0;
            t = ((a & 65535) + (b & 65535) | 0) + c | 0;
            r = ((a >>> 16) + (b >>> 16) | 0) + (t >>> 16) | 0;
            HEAP32[R + i >> 2] = t & 65535 | r << 16;
            c = r >>> 16;
          }
          for (; (i | 0) < (lA | 0); i = i + 4 | 0) {
            a = HEAP32[A + i >> 2] | 0;
            t = (a & 65535) + c | 0;
            r = (a >>> 16) + (t >>> 16) | 0;
            HEAP32[R + i >> 2] = t & 65535 | r << 16;
            c = r >>> 16;
          }
          for (; (i | 0) < (lR | 0); i = i + 4 | 0) {
            HEAP32[R + i >> 2] = c | 0;
            c = 0;
          }
          return c | 0;
        }
        function sub(A, lA, B, lB, R, lR) {
          A = A | 0;
          lA = lA | 0;
          B = B | 0;
          lB = lB | 0;
          R = R | 0;
          lR = lR | 0;
          var a = 0, b = 0, c = 0, t = 0, r = 0, i = 0;
          if ((lR | 0) <= 0)
            lR = (lA | 0) > (lB | 0) ? lA + 4 | 0 : lB + 4 | 0;
          if ((lR | 0) < (lA | 0))
            lA = lR;
          if ((lR | 0) < (lB | 0))
            lB = lR;
          if ((lA | 0) < (lB | 0)) {
            for (; (i | 0) < (lA | 0); i = i + 4 | 0) {
              a = HEAP32[A + i >> 2] | 0;
              b = HEAP32[B + i >> 2] | 0;
              t = ((a & 65535) - (b & 65535) | 0) + c | 0;
              r = ((a >>> 16) - (b >>> 16) | 0) + (t >> 16) | 0;
              HEAP32[R + i >> 2] = t & 65535 | r << 16;
              c = r >> 16;
            }
            for (; (i | 0) < (lB | 0); i = i + 4 | 0) {
              b = HEAP32[B + i >> 2] | 0;
              t = c - (b & 65535) | 0;
              r = (t >> 16) - (b >>> 16) | 0;
              HEAP32[R + i >> 2] = t & 65535 | r << 16;
              c = r >> 16;
            }
          } else {
            for (; (i | 0) < (lB | 0); i = i + 4 | 0) {
              a = HEAP32[A + i >> 2] | 0;
              b = HEAP32[B + i >> 2] | 0;
              t = ((a & 65535) - (b & 65535) | 0) + c | 0;
              r = ((a >>> 16) - (b >>> 16) | 0) + (t >> 16) | 0;
              HEAP32[R + i >> 2] = t & 65535 | r << 16;
              c = r >> 16;
            }
            for (; (i | 0) < (lA | 0); i = i + 4 | 0) {
              a = HEAP32[A + i >> 2] | 0;
              t = (a & 65535) + c | 0;
              r = (a >>> 16) + (t >> 16) | 0;
              HEAP32[R + i >> 2] = t & 65535 | r << 16;
              c = r >> 16;
            }
          }
          for (; (i | 0) < (lR | 0); i = i + 4 | 0) {
            HEAP32[R + i >> 2] = c | 0;
          }
          return c | 0;
        }
        function mul(A, lA, B, lB, R, lR) {
          A = A | 0;
          lA = lA | 0;
          B = B | 0;
          lB = lB | 0;
          R = R | 0;
          lR = lR | 0;
          var al0 = 0, al1 = 0, al2 = 0, al3 = 0, al4 = 0, al5 = 0, al6 = 0, al7 = 0, ah0 = 0, ah1 = 0, ah2 = 0, ah3 = 0, ah4 = 0, ah5 = 0, ah6 = 0, ah7 = 0, bl0 = 0, bl1 = 0, bl2 = 0, bl3 = 0, bl4 = 0, bl5 = 0, bl6 = 0, bl7 = 0, bh0 = 0, bh1 = 0, bh2 = 0, bh3 = 0, bh4 = 0, bh5 = 0, bh6 = 0, bh7 = 0, r0 = 0, r1 = 0, r2 = 0, r3 = 0, r4 = 0, r5 = 0, r6 = 0, r7 = 0, r8 = 0, r9 = 0, r10 = 0, r11 = 0, r12 = 0, r13 = 0, r14 = 0, r15 = 0, u = 0, v = 0, w = 0, m = 0, i = 0, Ai = 0, j = 0, Bj = 0, Rk = 0;
          if ((lA | 0) > (lB | 0)) {
            u = A, v = lA;
            A = B, lA = lB;
            B = u, lB = v;
          }
          m = lA + lB | 0;
          if ((lR | 0) > (m | 0) | (lR | 0) <= 0)
            lR = m;
          if ((lR | 0) < (lA | 0))
            lA = lR;
          if ((lR | 0) < (lB | 0))
            lB = lR;
          for (; (i | 0) < (lA | 0); i = i + 32 | 0) {
            Ai = A + i | 0;
            ah0 = HEAP32[(Ai | 0) >> 2] | 0, ah1 = HEAP32[(Ai | 4) >> 2] | 0, ah2 = HEAP32[(Ai | 8) >> 2] | 0, ah3 = HEAP32[(Ai | 12) >> 2] | 0, ah4 = HEAP32[(Ai | 16) >> 2] | 0, ah5 = HEAP32[(Ai | 20) >> 2] | 0, ah6 = HEAP32[(Ai | 24) >> 2] | 0, ah7 = HEAP32[(Ai | 28) >> 2] | 0, al0 = ah0 & 65535, al1 = ah1 & 65535, al2 = ah2 & 65535, al3 = ah3 & 65535, al4 = ah4 & 65535, al5 = ah5 & 65535, al6 = ah6 & 65535, al7 = ah7 & 65535, ah0 = ah0 >>> 16, ah1 = ah1 >>> 16, ah2 = ah2 >>> 16, ah3 = ah3 >>> 16, ah4 = ah4 >>> 16, ah5 = ah5 >>> 16, ah6 = ah6 >>> 16, ah7 = ah7 >>> 16;
            r8 = r9 = r10 = r11 = r12 = r13 = r14 = r15 = 0;
            for (j = 0; (j | 0) < (lB | 0); j = j + 32 | 0) {
              Bj = B + j | 0;
              Rk = R + (i + j | 0) | 0;
              bh0 = HEAP32[(Bj | 0) >> 2] | 0, bh1 = HEAP32[(Bj | 4) >> 2] | 0, bh2 = HEAP32[(Bj | 8) >> 2] | 0, bh3 = HEAP32[(Bj | 12) >> 2] | 0, bh4 = HEAP32[(Bj | 16) >> 2] | 0, bh5 = HEAP32[(Bj | 20) >> 2] | 0, bh6 = HEAP32[(Bj | 24) >> 2] | 0, bh7 = HEAP32[(Bj | 28) >> 2] | 0, bl0 = bh0 & 65535, bl1 = bh1 & 65535, bl2 = bh2 & 65535, bl3 = bh3 & 65535, bl4 = bh4 & 65535, bl5 = bh5 & 65535, bl6 = bh6 & 65535, bl7 = bh7 & 65535, bh0 = bh0 >>> 16, bh1 = bh1 >>> 16, bh2 = bh2 >>> 16, bh3 = bh3 >>> 16, bh4 = bh4 >>> 16, bh5 = bh5 >>> 16, bh6 = bh6 >>> 16, bh7 = bh7 >>> 16;
              r0 = HEAP32[(Rk | 0) >> 2] | 0, r1 = HEAP32[(Rk | 4) >> 2] | 0, r2 = HEAP32[(Rk | 8) >> 2] | 0, r3 = HEAP32[(Rk | 12) >> 2] | 0, r4 = HEAP32[(Rk | 16) >> 2] | 0, r5 = HEAP32[(Rk | 20) >> 2] | 0, r6 = HEAP32[(Rk | 24) >> 2] | 0, r7 = HEAP32[(Rk | 28) >> 2] | 0;
              u = ((imul(al0, bl0) | 0) + (r8 & 65535) | 0) + (r0 & 65535) | 0;
              v = ((imul(ah0, bl0) | 0) + (r8 >>> 16) | 0) + (r0 >>> 16) | 0;
              w = ((imul(al0, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah0, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r0 = w << 16 | u & 65535;
              u = ((imul(al0, bl1) | 0) + (m & 65535) | 0) + (r1 & 65535) | 0;
              v = ((imul(ah0, bl1) | 0) + (m >>> 16) | 0) + (r1 >>> 16) | 0;
              w = ((imul(al0, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah0, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r1 = w << 16 | u & 65535;
              u = ((imul(al0, bl2) | 0) + (m & 65535) | 0) + (r2 & 65535) | 0;
              v = ((imul(ah0, bl2) | 0) + (m >>> 16) | 0) + (r2 >>> 16) | 0;
              w = ((imul(al0, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah0, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r2 = w << 16 | u & 65535;
              u = ((imul(al0, bl3) | 0) + (m & 65535) | 0) + (r3 & 65535) | 0;
              v = ((imul(ah0, bl3) | 0) + (m >>> 16) | 0) + (r3 >>> 16) | 0;
              w = ((imul(al0, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah0, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r3 = w << 16 | u & 65535;
              u = ((imul(al0, bl4) | 0) + (m & 65535) | 0) + (r4 & 65535) | 0;
              v = ((imul(ah0, bl4) | 0) + (m >>> 16) | 0) + (r4 >>> 16) | 0;
              w = ((imul(al0, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah0, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r4 = w << 16 | u & 65535;
              u = ((imul(al0, bl5) | 0) + (m & 65535) | 0) + (r5 & 65535) | 0;
              v = ((imul(ah0, bl5) | 0) + (m >>> 16) | 0) + (r5 >>> 16) | 0;
              w = ((imul(al0, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah0, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r5 = w << 16 | u & 65535;
              u = ((imul(al0, bl6) | 0) + (m & 65535) | 0) + (r6 & 65535) | 0;
              v = ((imul(ah0, bl6) | 0) + (m >>> 16) | 0) + (r6 >>> 16) | 0;
              w = ((imul(al0, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah0, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r6 = w << 16 | u & 65535;
              u = ((imul(al0, bl7) | 0) + (m & 65535) | 0) + (r7 & 65535) | 0;
              v = ((imul(ah0, bl7) | 0) + (m >>> 16) | 0) + (r7 >>> 16) | 0;
              w = ((imul(al0, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah0, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r7 = w << 16 | u & 65535;
              r8 = m;
              u = ((imul(al1, bl0) | 0) + (r9 & 65535) | 0) + (r1 & 65535) | 0;
              v = ((imul(ah1, bl0) | 0) + (r9 >>> 16) | 0) + (r1 >>> 16) | 0;
              w = ((imul(al1, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah1, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r1 = w << 16 | u & 65535;
              u = ((imul(al1, bl1) | 0) + (m & 65535) | 0) + (r2 & 65535) | 0;
              v = ((imul(ah1, bl1) | 0) + (m >>> 16) | 0) + (r2 >>> 16) | 0;
              w = ((imul(al1, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah1, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r2 = w << 16 | u & 65535;
              u = ((imul(al1, bl2) | 0) + (m & 65535) | 0) + (r3 & 65535) | 0;
              v = ((imul(ah1, bl2) | 0) + (m >>> 16) | 0) + (r3 >>> 16) | 0;
              w = ((imul(al1, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah1, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r3 = w << 16 | u & 65535;
              u = ((imul(al1, bl3) | 0) + (m & 65535) | 0) + (r4 & 65535) | 0;
              v = ((imul(ah1, bl3) | 0) + (m >>> 16) | 0) + (r4 >>> 16) | 0;
              w = ((imul(al1, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah1, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r4 = w << 16 | u & 65535;
              u = ((imul(al1, bl4) | 0) + (m & 65535) | 0) + (r5 & 65535) | 0;
              v = ((imul(ah1, bl4) | 0) + (m >>> 16) | 0) + (r5 >>> 16) | 0;
              w = ((imul(al1, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah1, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r5 = w << 16 | u & 65535;
              u = ((imul(al1, bl5) | 0) + (m & 65535) | 0) + (r6 & 65535) | 0;
              v = ((imul(ah1, bl5) | 0) + (m >>> 16) | 0) + (r6 >>> 16) | 0;
              w = ((imul(al1, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah1, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r6 = w << 16 | u & 65535;
              u = ((imul(al1, bl6) | 0) + (m & 65535) | 0) + (r7 & 65535) | 0;
              v = ((imul(ah1, bl6) | 0) + (m >>> 16) | 0) + (r7 >>> 16) | 0;
              w = ((imul(al1, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah1, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r7 = w << 16 | u & 65535;
              u = ((imul(al1, bl7) | 0) + (m & 65535) | 0) + (r8 & 65535) | 0;
              v = ((imul(ah1, bl7) | 0) + (m >>> 16) | 0) + (r8 >>> 16) | 0;
              w = ((imul(al1, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah1, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r8 = w << 16 | u & 65535;
              r9 = m;
              u = ((imul(al2, bl0) | 0) + (r10 & 65535) | 0) + (r2 & 65535) | 0;
              v = ((imul(ah2, bl0) | 0) + (r10 >>> 16) | 0) + (r2 >>> 16) | 0;
              w = ((imul(al2, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah2, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r2 = w << 16 | u & 65535;
              u = ((imul(al2, bl1) | 0) + (m & 65535) | 0) + (r3 & 65535) | 0;
              v = ((imul(ah2, bl1) | 0) + (m >>> 16) | 0) + (r3 >>> 16) | 0;
              w = ((imul(al2, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah2, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r3 = w << 16 | u & 65535;
              u = ((imul(al2, bl2) | 0) + (m & 65535) | 0) + (r4 & 65535) | 0;
              v = ((imul(ah2, bl2) | 0) + (m >>> 16) | 0) + (r4 >>> 16) | 0;
              w = ((imul(al2, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah2, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r4 = w << 16 | u & 65535;
              u = ((imul(al2, bl3) | 0) + (m & 65535) | 0) + (r5 & 65535) | 0;
              v = ((imul(ah2, bl3) | 0) + (m >>> 16) | 0) + (r5 >>> 16) | 0;
              w = ((imul(al2, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah2, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r5 = w << 16 | u & 65535;
              u = ((imul(al2, bl4) | 0) + (m & 65535) | 0) + (r6 & 65535) | 0;
              v = ((imul(ah2, bl4) | 0) + (m >>> 16) | 0) + (r6 >>> 16) | 0;
              w = ((imul(al2, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah2, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r6 = w << 16 | u & 65535;
              u = ((imul(al2, bl5) | 0) + (m & 65535) | 0) + (r7 & 65535) | 0;
              v = ((imul(ah2, bl5) | 0) + (m >>> 16) | 0) + (r7 >>> 16) | 0;
              w = ((imul(al2, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah2, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r7 = w << 16 | u & 65535;
              u = ((imul(al2, bl6) | 0) + (m & 65535) | 0) + (r8 & 65535) | 0;
              v = ((imul(ah2, bl6) | 0) + (m >>> 16) | 0) + (r8 >>> 16) | 0;
              w = ((imul(al2, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah2, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r8 = w << 16 | u & 65535;
              u = ((imul(al2, bl7) | 0) + (m & 65535) | 0) + (r9 & 65535) | 0;
              v = ((imul(ah2, bl7) | 0) + (m >>> 16) | 0) + (r9 >>> 16) | 0;
              w = ((imul(al2, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah2, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r9 = w << 16 | u & 65535;
              r10 = m;
              u = ((imul(al3, bl0) | 0) + (r11 & 65535) | 0) + (r3 & 65535) | 0;
              v = ((imul(ah3, bl0) | 0) + (r11 >>> 16) | 0) + (r3 >>> 16) | 0;
              w = ((imul(al3, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah3, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r3 = w << 16 | u & 65535;
              u = ((imul(al3, bl1) | 0) + (m & 65535) | 0) + (r4 & 65535) | 0;
              v = ((imul(ah3, bl1) | 0) + (m >>> 16) | 0) + (r4 >>> 16) | 0;
              w = ((imul(al3, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah3, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r4 = w << 16 | u & 65535;
              u = ((imul(al3, bl2) | 0) + (m & 65535) | 0) + (r5 & 65535) | 0;
              v = ((imul(ah3, bl2) | 0) + (m >>> 16) | 0) + (r5 >>> 16) | 0;
              w = ((imul(al3, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah3, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r5 = w << 16 | u & 65535;
              u = ((imul(al3, bl3) | 0) + (m & 65535) | 0) + (r6 & 65535) | 0;
              v = ((imul(ah3, bl3) | 0) + (m >>> 16) | 0) + (r6 >>> 16) | 0;
              w = ((imul(al3, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah3, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r6 = w << 16 | u & 65535;
              u = ((imul(al3, bl4) | 0) + (m & 65535) | 0) + (r7 & 65535) | 0;
              v = ((imul(ah3, bl4) | 0) + (m >>> 16) | 0) + (r7 >>> 16) | 0;
              w = ((imul(al3, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah3, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r7 = w << 16 | u & 65535;
              u = ((imul(al3, bl5) | 0) + (m & 65535) | 0) + (r8 & 65535) | 0;
              v = ((imul(ah3, bl5) | 0) + (m >>> 16) | 0) + (r8 >>> 16) | 0;
              w = ((imul(al3, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah3, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r8 = w << 16 | u & 65535;
              u = ((imul(al3, bl6) | 0) + (m & 65535) | 0) + (r9 & 65535) | 0;
              v = ((imul(ah3, bl6) | 0) + (m >>> 16) | 0) + (r9 >>> 16) | 0;
              w = ((imul(al3, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah3, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r9 = w << 16 | u & 65535;
              u = ((imul(al3, bl7) | 0) + (m & 65535) | 0) + (r10 & 65535) | 0;
              v = ((imul(ah3, bl7) | 0) + (m >>> 16) | 0) + (r10 >>> 16) | 0;
              w = ((imul(al3, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah3, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r10 = w << 16 | u & 65535;
              r11 = m;
              u = ((imul(al4, bl0) | 0) + (r12 & 65535) | 0) + (r4 & 65535) | 0;
              v = ((imul(ah4, bl0) | 0) + (r12 >>> 16) | 0) + (r4 >>> 16) | 0;
              w = ((imul(al4, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah4, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r4 = w << 16 | u & 65535;
              u = ((imul(al4, bl1) | 0) + (m & 65535) | 0) + (r5 & 65535) | 0;
              v = ((imul(ah4, bl1) | 0) + (m >>> 16) | 0) + (r5 >>> 16) | 0;
              w = ((imul(al4, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah4, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r5 = w << 16 | u & 65535;
              u = ((imul(al4, bl2) | 0) + (m & 65535) | 0) + (r6 & 65535) | 0;
              v = ((imul(ah4, bl2) | 0) + (m >>> 16) | 0) + (r6 >>> 16) | 0;
              w = ((imul(al4, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah4, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r6 = w << 16 | u & 65535;
              u = ((imul(al4, bl3) | 0) + (m & 65535) | 0) + (r7 & 65535) | 0;
              v = ((imul(ah4, bl3) | 0) + (m >>> 16) | 0) + (r7 >>> 16) | 0;
              w = ((imul(al4, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah4, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r7 = w << 16 | u & 65535;
              u = ((imul(al4, bl4) | 0) + (m & 65535) | 0) + (r8 & 65535) | 0;
              v = ((imul(ah4, bl4) | 0) + (m >>> 16) | 0) + (r8 >>> 16) | 0;
              w = ((imul(al4, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah4, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r8 = w << 16 | u & 65535;
              u = ((imul(al4, bl5) | 0) + (m & 65535) | 0) + (r9 & 65535) | 0;
              v = ((imul(ah4, bl5) | 0) + (m >>> 16) | 0) + (r9 >>> 16) | 0;
              w = ((imul(al4, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah4, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r9 = w << 16 | u & 65535;
              u = ((imul(al4, bl6) | 0) + (m & 65535) | 0) + (r10 & 65535) | 0;
              v = ((imul(ah4, bl6) | 0) + (m >>> 16) | 0) + (r10 >>> 16) | 0;
              w = ((imul(al4, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah4, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r10 = w << 16 | u & 65535;
              u = ((imul(al4, bl7) | 0) + (m & 65535) | 0) + (r11 & 65535) | 0;
              v = ((imul(ah4, bl7) | 0) + (m >>> 16) | 0) + (r11 >>> 16) | 0;
              w = ((imul(al4, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah4, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r11 = w << 16 | u & 65535;
              r12 = m;
              u = ((imul(al5, bl0) | 0) + (r13 & 65535) | 0) + (r5 & 65535) | 0;
              v = ((imul(ah5, bl0) | 0) + (r13 >>> 16) | 0) + (r5 >>> 16) | 0;
              w = ((imul(al5, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah5, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r5 = w << 16 | u & 65535;
              u = ((imul(al5, bl1) | 0) + (m & 65535) | 0) + (r6 & 65535) | 0;
              v = ((imul(ah5, bl1) | 0) + (m >>> 16) | 0) + (r6 >>> 16) | 0;
              w = ((imul(al5, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah5, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r6 = w << 16 | u & 65535;
              u = ((imul(al5, bl2) | 0) + (m & 65535) | 0) + (r7 & 65535) | 0;
              v = ((imul(ah5, bl2) | 0) + (m >>> 16) | 0) + (r7 >>> 16) | 0;
              w = ((imul(al5, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah5, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r7 = w << 16 | u & 65535;
              u = ((imul(al5, bl3) | 0) + (m & 65535) | 0) + (r8 & 65535) | 0;
              v = ((imul(ah5, bl3) | 0) + (m >>> 16) | 0) + (r8 >>> 16) | 0;
              w = ((imul(al5, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah5, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r8 = w << 16 | u & 65535;
              u = ((imul(al5, bl4) | 0) + (m & 65535) | 0) + (r9 & 65535) | 0;
              v = ((imul(ah5, bl4) | 0) + (m >>> 16) | 0) + (r9 >>> 16) | 0;
              w = ((imul(al5, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah5, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r9 = w << 16 | u & 65535;
              u = ((imul(al5, bl5) | 0) + (m & 65535) | 0) + (r10 & 65535) | 0;
              v = ((imul(ah5, bl5) | 0) + (m >>> 16) | 0) + (r10 >>> 16) | 0;
              w = ((imul(al5, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah5, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r10 = w << 16 | u & 65535;
              u = ((imul(al5, bl6) | 0) + (m & 65535) | 0) + (r11 & 65535) | 0;
              v = ((imul(ah5, bl6) | 0) + (m >>> 16) | 0) + (r11 >>> 16) | 0;
              w = ((imul(al5, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah5, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r11 = w << 16 | u & 65535;
              u = ((imul(al5, bl7) | 0) + (m & 65535) | 0) + (r12 & 65535) | 0;
              v = ((imul(ah5, bl7) | 0) + (m >>> 16) | 0) + (r12 >>> 16) | 0;
              w = ((imul(al5, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah5, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r12 = w << 16 | u & 65535;
              r13 = m;
              u = ((imul(al6, bl0) | 0) + (r14 & 65535) | 0) + (r6 & 65535) | 0;
              v = ((imul(ah6, bl0) | 0) + (r14 >>> 16) | 0) + (r6 >>> 16) | 0;
              w = ((imul(al6, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah6, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r6 = w << 16 | u & 65535;
              u = ((imul(al6, bl1) | 0) + (m & 65535) | 0) + (r7 & 65535) | 0;
              v = ((imul(ah6, bl1) | 0) + (m >>> 16) | 0) + (r7 >>> 16) | 0;
              w = ((imul(al6, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah6, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r7 = w << 16 | u & 65535;
              u = ((imul(al6, bl2) | 0) + (m & 65535) | 0) + (r8 & 65535) | 0;
              v = ((imul(ah6, bl2) | 0) + (m >>> 16) | 0) + (r8 >>> 16) | 0;
              w = ((imul(al6, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah6, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r8 = w << 16 | u & 65535;
              u = ((imul(al6, bl3) | 0) + (m & 65535) | 0) + (r9 & 65535) | 0;
              v = ((imul(ah6, bl3) | 0) + (m >>> 16) | 0) + (r9 >>> 16) | 0;
              w = ((imul(al6, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah6, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r9 = w << 16 | u & 65535;
              u = ((imul(al6, bl4) | 0) + (m & 65535) | 0) + (r10 & 65535) | 0;
              v = ((imul(ah6, bl4) | 0) + (m >>> 16) | 0) + (r10 >>> 16) | 0;
              w = ((imul(al6, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah6, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r10 = w << 16 | u & 65535;
              u = ((imul(al6, bl5) | 0) + (m & 65535) | 0) + (r11 & 65535) | 0;
              v = ((imul(ah6, bl5) | 0) + (m >>> 16) | 0) + (r11 >>> 16) | 0;
              w = ((imul(al6, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah6, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r11 = w << 16 | u & 65535;
              u = ((imul(al6, bl6) | 0) + (m & 65535) | 0) + (r12 & 65535) | 0;
              v = ((imul(ah6, bl6) | 0) + (m >>> 16) | 0) + (r12 >>> 16) | 0;
              w = ((imul(al6, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah6, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r12 = w << 16 | u & 65535;
              u = ((imul(al6, bl7) | 0) + (m & 65535) | 0) + (r13 & 65535) | 0;
              v = ((imul(ah6, bl7) | 0) + (m >>> 16) | 0) + (r13 >>> 16) | 0;
              w = ((imul(al6, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah6, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r13 = w << 16 | u & 65535;
              r14 = m;
              u = ((imul(al7, bl0) | 0) + (r15 & 65535) | 0) + (r7 & 65535) | 0;
              v = ((imul(ah7, bl0) | 0) + (r15 >>> 16) | 0) + (r7 >>> 16) | 0;
              w = ((imul(al7, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah7, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r7 = w << 16 | u & 65535;
              u = ((imul(al7, bl1) | 0) + (m & 65535) | 0) + (r8 & 65535) | 0;
              v = ((imul(ah7, bl1) | 0) + (m >>> 16) | 0) + (r8 >>> 16) | 0;
              w = ((imul(al7, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah7, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r8 = w << 16 | u & 65535;
              u = ((imul(al7, bl2) | 0) + (m & 65535) | 0) + (r9 & 65535) | 0;
              v = ((imul(ah7, bl2) | 0) + (m >>> 16) | 0) + (r9 >>> 16) | 0;
              w = ((imul(al7, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah7, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r9 = w << 16 | u & 65535;
              u = ((imul(al7, bl3) | 0) + (m & 65535) | 0) + (r10 & 65535) | 0;
              v = ((imul(ah7, bl3) | 0) + (m >>> 16) | 0) + (r10 >>> 16) | 0;
              w = ((imul(al7, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah7, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r10 = w << 16 | u & 65535;
              u = ((imul(al7, bl4) | 0) + (m & 65535) | 0) + (r11 & 65535) | 0;
              v = ((imul(ah7, bl4) | 0) + (m >>> 16) | 0) + (r11 >>> 16) | 0;
              w = ((imul(al7, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah7, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r11 = w << 16 | u & 65535;
              u = ((imul(al7, bl5) | 0) + (m & 65535) | 0) + (r12 & 65535) | 0;
              v = ((imul(ah7, bl5) | 0) + (m >>> 16) | 0) + (r12 >>> 16) | 0;
              w = ((imul(al7, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah7, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r12 = w << 16 | u & 65535;
              u = ((imul(al7, bl6) | 0) + (m & 65535) | 0) + (r13 & 65535) | 0;
              v = ((imul(ah7, bl6) | 0) + (m >>> 16) | 0) + (r13 >>> 16) | 0;
              w = ((imul(al7, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah7, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r13 = w << 16 | u & 65535;
              u = ((imul(al7, bl7) | 0) + (m & 65535) | 0) + (r14 & 65535) | 0;
              v = ((imul(ah7, bl7) | 0) + (m >>> 16) | 0) + (r14 >>> 16) | 0;
              w = ((imul(al7, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
              m = ((imul(ah7, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
              r14 = w << 16 | u & 65535;
              r15 = m;
              HEAP32[(Rk | 0) >> 2] = r0, HEAP32[(Rk | 4) >> 2] = r1, HEAP32[(Rk | 8) >> 2] = r2, HEAP32[(Rk | 12) >> 2] = r3, HEAP32[(Rk | 16) >> 2] = r4, HEAP32[(Rk | 20) >> 2] = r5, HEAP32[(Rk | 24) >> 2] = r6, HEAP32[(Rk | 28) >> 2] = r7;
            }
            Rk = R + (i + j | 0) | 0;
            HEAP32[(Rk | 0) >> 2] = r8, HEAP32[(Rk | 4) >> 2] = r9, HEAP32[(Rk | 8) >> 2] = r10, HEAP32[(Rk | 12) >> 2] = r11, HEAP32[(Rk | 16) >> 2] = r12, HEAP32[(Rk | 20) >> 2] = r13, HEAP32[(Rk | 24) >> 2] = r14, HEAP32[(Rk | 28) >> 2] = r15;
          }
        }
        function sqr(A, lA, R) {
          A = A | 0;
          lA = lA | 0;
          R = R | 0;
          var al0 = 0, al1 = 0, al2 = 0, al3 = 0, al4 = 0, al5 = 0, al6 = 0, al7 = 0, ah0 = 0, ah1 = 0, ah2 = 0, ah3 = 0, ah4 = 0, ah5 = 0, ah6 = 0, ah7 = 0, bl0 = 0, bl1 = 0, bl2 = 0, bl3 = 0, bl4 = 0, bl5 = 0, bl6 = 0, bl7 = 0, bh0 = 0, bh1 = 0, bh2 = 0, bh3 = 0, bh4 = 0, bh5 = 0, bh6 = 0, bh7 = 0, r0 = 0, r1 = 0, r2 = 0, r3 = 0, r4 = 0, r5 = 0, r6 = 0, r7 = 0, r8 = 0, r9 = 0, r10 = 0, r11 = 0, r12 = 0, r13 = 0, r14 = 0, r15 = 0, u = 0, v = 0, w = 0, c = 0, h = 0, m = 0, r = 0, d = 0, dd = 0, p = 0, i = 0, j = 0, k = 0, Ai = 0, Aj = 0, Rk = 0;
          for (; (i | 0) < (lA | 0); i = i + 4 | 0) {
            Rk = R + (i << 1) | 0;
            ah0 = HEAP32[A + i >> 2] | 0, al0 = ah0 & 65535, ah0 = ah0 >>> 16;
            u = imul(al0, al0) | 0;
            v = (imul(al0, ah0) | 0) + (u >>> 17) | 0;
            w = (imul(ah0, ah0) | 0) + (v >>> 15) | 0;
            HEAP32[Rk >> 2] = v << 17 | u & 131071;
            HEAP32[(Rk | 4) >> 2] = w;
          }
          for (p = 0; (p | 0) < (lA | 0); p = p + 8 | 0) {
            Ai = A + p | 0, Rk = R + (p << 1) | 0;
            ah0 = HEAP32[Ai >> 2] | 0, al0 = ah0 & 65535, ah0 = ah0 >>> 16;
            bh0 = HEAP32[(Ai | 4) >> 2] | 0, bl0 = bh0 & 65535, bh0 = bh0 >>> 16;
            u = imul(al0, bl0) | 0;
            v = (imul(al0, bh0) | 0) + (u >>> 16) | 0;
            w = (imul(ah0, bl0) | 0) + (v & 65535) | 0;
            m = ((imul(ah0, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r = HEAP32[(Rk | 4) >> 2] | 0;
            u = (r & 65535) + ((u & 65535) << 1) | 0;
            w = ((r >>> 16) + ((w & 65535) << 1) | 0) + (u >>> 16) | 0;
            HEAP32[(Rk | 4) >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[(Rk | 8) >> 2] | 0;
            u = ((r & 65535) + ((m & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (m >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[(Rk | 8) >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            if (c) {
              r = HEAP32[(Rk | 12) >> 2] | 0;
              u = (r & 65535) + c | 0;
              w = (r >>> 16) + (u >>> 16) | 0;
              HEAP32[(Rk | 12) >> 2] = w << 16 | u & 65535;
            }
          }
          for (p = 0; (p | 0) < (lA | 0); p = p + 16 | 0) {
            Ai = A + p | 0, Rk = R + (p << 1) | 0;
            ah0 = HEAP32[Ai >> 2] | 0, al0 = ah0 & 65535, ah0 = ah0 >>> 16, ah1 = HEAP32[(Ai | 4) >> 2] | 0, al1 = ah1 & 65535, ah1 = ah1 >>> 16;
            bh0 = HEAP32[(Ai | 8) >> 2] | 0, bl0 = bh0 & 65535, bh0 = bh0 >>> 16, bh1 = HEAP32[(Ai | 12) >> 2] | 0, bl1 = bh1 & 65535, bh1 = bh1 >>> 16;
            u = imul(al0, bl0) | 0;
            v = imul(ah0, bl0) | 0;
            w = ((imul(al0, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah0, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r0 = w << 16 | u & 65535;
            u = (imul(al0, bl1) | 0) + (m & 65535) | 0;
            v = (imul(ah0, bl1) | 0) + (m >>> 16) | 0;
            w = ((imul(al0, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah0, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r1 = w << 16 | u & 65535;
            r2 = m;
            u = (imul(al1, bl0) | 0) + (r1 & 65535) | 0;
            v = (imul(ah1, bl0) | 0) + (r1 >>> 16) | 0;
            w = ((imul(al1, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah1, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r1 = w << 16 | u & 65535;
            u = ((imul(al1, bl1) | 0) + (r2 & 65535) | 0) + (m & 65535) | 0;
            v = ((imul(ah1, bl1) | 0) + (r2 >>> 16) | 0) + (m >>> 16) | 0;
            w = ((imul(al1, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah1, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r2 = w << 16 | u & 65535;
            r3 = m;
            r = HEAP32[(Rk | 8) >> 2] | 0;
            u = (r & 65535) + ((r0 & 65535) << 1) | 0;
            w = ((r >>> 16) + (r0 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[(Rk | 8) >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[(Rk | 12) >> 2] | 0;
            u = ((r & 65535) + ((r1 & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (r1 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[(Rk | 12) >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[(Rk | 16) >> 2] | 0;
            u = ((r & 65535) + ((r2 & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (r2 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[(Rk | 16) >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[(Rk | 20) >> 2] | 0;
            u = ((r & 65535) + ((r3 & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (r3 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[(Rk | 20) >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            for (k = 24; !!c & (k | 0) < 32; k = k + 4 | 0) {
              r = HEAP32[(Rk | k) >> 2] | 0;
              u = (r & 65535) + c | 0;
              w = (r >>> 16) + (u >>> 16) | 0;
              HEAP32[(Rk | k) >> 2] = w << 16 | u & 65535;
              c = w >>> 16;
            }
          }
          for (p = 0; (p | 0) < (lA | 0); p = p + 32 | 0) {
            Ai = A + p | 0, Rk = R + (p << 1) | 0;
            ah0 = HEAP32[Ai >> 2] | 0, al0 = ah0 & 65535, ah0 = ah0 >>> 16, ah1 = HEAP32[(Ai | 4) >> 2] | 0, al1 = ah1 & 65535, ah1 = ah1 >>> 16, ah2 = HEAP32[(Ai | 8) >> 2] | 0, al2 = ah2 & 65535, ah2 = ah2 >>> 16, ah3 = HEAP32[(Ai | 12) >> 2] | 0, al3 = ah3 & 65535, ah3 = ah3 >>> 16;
            bh0 = HEAP32[(Ai | 16) >> 2] | 0, bl0 = bh0 & 65535, bh0 = bh0 >>> 16, bh1 = HEAP32[(Ai | 20) >> 2] | 0, bl1 = bh1 & 65535, bh1 = bh1 >>> 16, bh2 = HEAP32[(Ai | 24) >> 2] | 0, bl2 = bh2 & 65535, bh2 = bh2 >>> 16, bh3 = HEAP32[(Ai | 28) >> 2] | 0, bl3 = bh3 & 65535, bh3 = bh3 >>> 16;
            u = imul(al0, bl0) | 0;
            v = imul(ah0, bl0) | 0;
            w = ((imul(al0, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah0, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r0 = w << 16 | u & 65535;
            u = (imul(al0, bl1) | 0) + (m & 65535) | 0;
            v = (imul(ah0, bl1) | 0) + (m >>> 16) | 0;
            w = ((imul(al0, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah0, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r1 = w << 16 | u & 65535;
            u = (imul(al0, bl2) | 0) + (m & 65535) | 0;
            v = (imul(ah0, bl2) | 0) + (m >>> 16) | 0;
            w = ((imul(al0, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah0, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r2 = w << 16 | u & 65535;
            u = (imul(al0, bl3) | 0) + (m & 65535) | 0;
            v = (imul(ah0, bl3) | 0) + (m >>> 16) | 0;
            w = ((imul(al0, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah0, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r3 = w << 16 | u & 65535;
            r4 = m;
            u = (imul(al1, bl0) | 0) + (r1 & 65535) | 0;
            v = (imul(ah1, bl0) | 0) + (r1 >>> 16) | 0;
            w = ((imul(al1, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah1, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r1 = w << 16 | u & 65535;
            u = ((imul(al1, bl1) | 0) + (r2 & 65535) | 0) + (m & 65535) | 0;
            v = ((imul(ah1, bl1) | 0) + (r2 >>> 16) | 0) + (m >>> 16) | 0;
            w = ((imul(al1, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah1, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r2 = w << 16 | u & 65535;
            u = ((imul(al1, bl2) | 0) + (r3 & 65535) | 0) + (m & 65535) | 0;
            v = ((imul(ah1, bl2) | 0) + (r3 >>> 16) | 0) + (m >>> 16) | 0;
            w = ((imul(al1, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah1, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r3 = w << 16 | u & 65535;
            u = ((imul(al1, bl3) | 0) + (r4 & 65535) | 0) + (m & 65535) | 0;
            v = ((imul(ah1, bl3) | 0) + (r4 >>> 16) | 0) + (m >>> 16) | 0;
            w = ((imul(al1, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah1, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r4 = w << 16 | u & 65535;
            r5 = m;
            u = (imul(al2, bl0) | 0) + (r2 & 65535) | 0;
            v = (imul(ah2, bl0) | 0) + (r2 >>> 16) | 0;
            w = ((imul(al2, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah2, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r2 = w << 16 | u & 65535;
            u = ((imul(al2, bl1) | 0) + (r3 & 65535) | 0) + (m & 65535) | 0;
            v = ((imul(ah2, bl1) | 0) + (r3 >>> 16) | 0) + (m >>> 16) | 0;
            w = ((imul(al2, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah2, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r3 = w << 16 | u & 65535;
            u = ((imul(al2, bl2) | 0) + (r4 & 65535) | 0) + (m & 65535) | 0;
            v = ((imul(ah2, bl2) | 0) + (r4 >>> 16) | 0) + (m >>> 16) | 0;
            w = ((imul(al2, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah2, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r4 = w << 16 | u & 65535;
            u = ((imul(al2, bl3) | 0) + (r5 & 65535) | 0) + (m & 65535) | 0;
            v = ((imul(ah2, bl3) | 0) + (r5 >>> 16) | 0) + (m >>> 16) | 0;
            w = ((imul(al2, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah2, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r5 = w << 16 | u & 65535;
            r6 = m;
            u = (imul(al3, bl0) | 0) + (r3 & 65535) | 0;
            v = (imul(ah3, bl0) | 0) + (r3 >>> 16) | 0;
            w = ((imul(al3, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah3, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r3 = w << 16 | u & 65535;
            u = ((imul(al3, bl1) | 0) + (r4 & 65535) | 0) + (m & 65535) | 0;
            v = ((imul(ah3, bl1) | 0) + (r4 >>> 16) | 0) + (m >>> 16) | 0;
            w = ((imul(al3, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah3, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r4 = w << 16 | u & 65535;
            u = ((imul(al3, bl2) | 0) + (r5 & 65535) | 0) + (m & 65535) | 0;
            v = ((imul(ah3, bl2) | 0) + (r5 >>> 16) | 0) + (m >>> 16) | 0;
            w = ((imul(al3, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah3, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r5 = w << 16 | u & 65535;
            u = ((imul(al3, bl3) | 0) + (r6 & 65535) | 0) + (m & 65535) | 0;
            v = ((imul(ah3, bl3) | 0) + (r6 >>> 16) | 0) + (m >>> 16) | 0;
            w = ((imul(al3, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
            m = ((imul(ah3, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
            r6 = w << 16 | u & 65535;
            r7 = m;
            r = HEAP32[(Rk | 16) >> 2] | 0;
            u = (r & 65535) + ((r0 & 65535) << 1) | 0;
            w = ((r >>> 16) + (r0 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[(Rk | 16) >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[(Rk | 20) >> 2] | 0;
            u = ((r & 65535) + ((r1 & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (r1 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[(Rk | 20) >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[(Rk | 24) >> 2] | 0;
            u = ((r & 65535) + ((r2 & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (r2 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[(Rk | 24) >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[(Rk | 28) >> 2] | 0;
            u = ((r & 65535) + ((r3 & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (r3 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[(Rk | 28) >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[Rk + 32 >> 2] | 0;
            u = ((r & 65535) + ((r4 & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (r4 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[Rk + 32 >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[Rk + 36 >> 2] | 0;
            u = ((r & 65535) + ((r5 & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (r5 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[Rk + 36 >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[Rk + 40 >> 2] | 0;
            u = ((r & 65535) + ((r6 & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (r6 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[Rk + 40 >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            r = HEAP32[Rk + 44 >> 2] | 0;
            u = ((r & 65535) + ((r7 & 65535) << 1) | 0) + c | 0;
            w = ((r >>> 16) + (r7 >>> 16 << 1) | 0) + (u >>> 16) | 0;
            HEAP32[Rk + 44 >> 2] = w << 16 | u & 65535;
            c = w >>> 16;
            for (k = 48; !!c & (k | 0) < 64; k = k + 4 | 0) {
              r = HEAP32[Rk + k >> 2] | 0;
              u = (r & 65535) + c | 0;
              w = (r >>> 16) + (u >>> 16) | 0;
              HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
              c = w >>> 16;
            }
          }
          for (d = 32; (d | 0) < (lA | 0); d = d << 1) {
            dd = d << 1;
            for (p = 0; (p | 0) < (lA | 0); p = p + dd | 0) {
              Rk = R + (p << 1) | 0;
              h = 0;
              for (i = 0; (i | 0) < (d | 0); i = i + 32 | 0) {
                Ai = (A + p | 0) + i | 0;
                ah0 = HEAP32[Ai >> 2] | 0, al0 = ah0 & 65535, ah0 = ah0 >>> 16, ah1 = HEAP32[(Ai | 4) >> 2] | 0, al1 = ah1 & 65535, ah1 = ah1 >>> 16, ah2 = HEAP32[(Ai | 8) >> 2] | 0, al2 = ah2 & 65535, ah2 = ah2 >>> 16, ah3 = HEAP32[(Ai | 12) >> 2] | 0, al3 = ah3 & 65535, ah3 = ah3 >>> 16, ah4 = HEAP32[(Ai | 16) >> 2] | 0, al4 = ah4 & 65535, ah4 = ah4 >>> 16, ah5 = HEAP32[(Ai | 20) >> 2] | 0, al5 = ah5 & 65535, ah5 = ah5 >>> 16, ah6 = HEAP32[(Ai | 24) >> 2] | 0, al6 = ah6 & 65535, ah6 = ah6 >>> 16, ah7 = HEAP32[(Ai | 28) >> 2] | 0, al7 = ah7 & 65535, ah7 = ah7 >>> 16;
                r8 = r9 = r10 = r11 = r12 = r13 = r14 = r15 = c = 0;
                for (j = 0; (j | 0) < (d | 0); j = j + 32 | 0) {
                  Aj = ((A + p | 0) + d | 0) + j | 0;
                  bh0 = HEAP32[Aj >> 2] | 0, bl0 = bh0 & 65535, bh0 = bh0 >>> 16, bh1 = HEAP32[(Aj | 4) >> 2] | 0, bl1 = bh1 & 65535, bh1 = bh1 >>> 16, bh2 = HEAP32[(Aj | 8) >> 2] | 0, bl2 = bh2 & 65535, bh2 = bh2 >>> 16, bh3 = HEAP32[(Aj | 12) >> 2] | 0, bl3 = bh3 & 65535, bh3 = bh3 >>> 16, bh4 = HEAP32[(Aj | 16) >> 2] | 0, bl4 = bh4 & 65535, bh4 = bh4 >>> 16, bh5 = HEAP32[(Aj | 20) >> 2] | 0, bl5 = bh5 & 65535, bh5 = bh5 >>> 16, bh6 = HEAP32[(Aj | 24) >> 2] | 0, bl6 = bh6 & 65535, bh6 = bh6 >>> 16, bh7 = HEAP32[(Aj | 28) >> 2] | 0, bl7 = bh7 & 65535, bh7 = bh7 >>> 16;
                  r0 = r1 = r2 = r3 = r4 = r5 = r6 = r7 = 0;
                  u = ((imul(al0, bl0) | 0) + (r0 & 65535) | 0) + (r8 & 65535) | 0;
                  v = ((imul(ah0, bl0) | 0) + (r0 >>> 16) | 0) + (r8 >>> 16) | 0;
                  w = ((imul(al0, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah0, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r0 = w << 16 | u & 65535;
                  u = ((imul(al0, bl1) | 0) + (r1 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah0, bl1) | 0) + (r1 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al0, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah0, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r1 = w << 16 | u & 65535;
                  u = ((imul(al0, bl2) | 0) + (r2 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah0, bl2) | 0) + (r2 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al0, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah0, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r2 = w << 16 | u & 65535;
                  u = ((imul(al0, bl3) | 0) + (r3 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah0, bl3) | 0) + (r3 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al0, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah0, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r3 = w << 16 | u & 65535;
                  u = ((imul(al0, bl4) | 0) + (r4 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah0, bl4) | 0) + (r4 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al0, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah0, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r4 = w << 16 | u & 65535;
                  u = ((imul(al0, bl5) | 0) + (r5 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah0, bl5) | 0) + (r5 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al0, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah0, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r5 = w << 16 | u & 65535;
                  u = ((imul(al0, bl6) | 0) + (r6 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah0, bl6) | 0) + (r6 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al0, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah0, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r6 = w << 16 | u & 65535;
                  u = ((imul(al0, bl7) | 0) + (r7 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah0, bl7) | 0) + (r7 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al0, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah0, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r7 = w << 16 | u & 65535;
                  r8 = m;
                  u = ((imul(al1, bl0) | 0) + (r1 & 65535) | 0) + (r9 & 65535) | 0;
                  v = ((imul(ah1, bl0) | 0) + (r1 >>> 16) | 0) + (r9 >>> 16) | 0;
                  w = ((imul(al1, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah1, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r1 = w << 16 | u & 65535;
                  u = ((imul(al1, bl1) | 0) + (r2 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah1, bl1) | 0) + (r2 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al1, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah1, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r2 = w << 16 | u & 65535;
                  u = ((imul(al1, bl2) | 0) + (r3 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah1, bl2) | 0) + (r3 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al1, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah1, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r3 = w << 16 | u & 65535;
                  u = ((imul(al1, bl3) | 0) + (r4 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah1, bl3) | 0) + (r4 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al1, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah1, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r4 = w << 16 | u & 65535;
                  u = ((imul(al1, bl4) | 0) + (r5 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah1, bl4) | 0) + (r5 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al1, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah1, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r5 = w << 16 | u & 65535;
                  u = ((imul(al1, bl5) | 0) + (r6 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah1, bl5) | 0) + (r6 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al1, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah1, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r6 = w << 16 | u & 65535;
                  u = ((imul(al1, bl6) | 0) + (r7 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah1, bl6) | 0) + (r7 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al1, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah1, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r7 = w << 16 | u & 65535;
                  u = ((imul(al1, bl7) | 0) + (r8 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah1, bl7) | 0) + (r8 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al1, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah1, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r8 = w << 16 | u & 65535;
                  r9 = m;
                  u = ((imul(al2, bl0) | 0) + (r2 & 65535) | 0) + (r10 & 65535) | 0;
                  v = ((imul(ah2, bl0) | 0) + (r2 >>> 16) | 0) + (r10 >>> 16) | 0;
                  w = ((imul(al2, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah2, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r2 = w << 16 | u & 65535;
                  u = ((imul(al2, bl1) | 0) + (r3 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah2, bl1) | 0) + (r3 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al2, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah2, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r3 = w << 16 | u & 65535;
                  u = ((imul(al2, bl2) | 0) + (r4 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah2, bl2) | 0) + (r4 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al2, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah2, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r4 = w << 16 | u & 65535;
                  u = ((imul(al2, bl3) | 0) + (r5 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah2, bl3) | 0) + (r5 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al2, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah2, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r5 = w << 16 | u & 65535;
                  u = ((imul(al2, bl4) | 0) + (r6 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah2, bl4) | 0) + (r6 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al2, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah2, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r6 = w << 16 | u & 65535;
                  u = ((imul(al2, bl5) | 0) + (r7 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah2, bl5) | 0) + (r7 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al2, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah2, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r7 = w << 16 | u & 65535;
                  u = ((imul(al2, bl6) | 0) + (r8 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah2, bl6) | 0) + (r8 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al2, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah2, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r8 = w << 16 | u & 65535;
                  u = ((imul(al2, bl7) | 0) + (r9 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah2, bl7) | 0) + (r9 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al2, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah2, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r9 = w << 16 | u & 65535;
                  r10 = m;
                  u = ((imul(al3, bl0) | 0) + (r3 & 65535) | 0) + (r11 & 65535) | 0;
                  v = ((imul(ah3, bl0) | 0) + (r3 >>> 16) | 0) + (r11 >>> 16) | 0;
                  w = ((imul(al3, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah3, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r3 = w << 16 | u & 65535;
                  u = ((imul(al3, bl1) | 0) + (r4 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah3, bl1) | 0) + (r4 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al3, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah3, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r4 = w << 16 | u & 65535;
                  u = ((imul(al3, bl2) | 0) + (r5 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah3, bl2) | 0) + (r5 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al3, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah3, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r5 = w << 16 | u & 65535;
                  u = ((imul(al3, bl3) | 0) + (r6 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah3, bl3) | 0) + (r6 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al3, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah3, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r6 = w << 16 | u & 65535;
                  u = ((imul(al3, bl4) | 0) + (r7 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah3, bl4) | 0) + (r7 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al3, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah3, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r7 = w << 16 | u & 65535;
                  u = ((imul(al3, bl5) | 0) + (r8 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah3, bl5) | 0) + (r8 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al3, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah3, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r8 = w << 16 | u & 65535;
                  u = ((imul(al3, bl6) | 0) + (r9 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah3, bl6) | 0) + (r9 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al3, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah3, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r9 = w << 16 | u & 65535;
                  u = ((imul(al3, bl7) | 0) + (r10 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah3, bl7) | 0) + (r10 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al3, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah3, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r10 = w << 16 | u & 65535;
                  r11 = m;
                  u = ((imul(al4, bl0) | 0) + (r4 & 65535) | 0) + (r12 & 65535) | 0;
                  v = ((imul(ah4, bl0) | 0) + (r4 >>> 16) | 0) + (r12 >>> 16) | 0;
                  w = ((imul(al4, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah4, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r4 = w << 16 | u & 65535;
                  u = ((imul(al4, bl1) | 0) + (r5 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah4, bl1) | 0) + (r5 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al4, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah4, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r5 = w << 16 | u & 65535;
                  u = ((imul(al4, bl2) | 0) + (r6 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah4, bl2) | 0) + (r6 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al4, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah4, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r6 = w << 16 | u & 65535;
                  u = ((imul(al4, bl3) | 0) + (r7 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah4, bl3) | 0) + (r7 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al4, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah4, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r7 = w << 16 | u & 65535;
                  u = ((imul(al4, bl4) | 0) + (r8 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah4, bl4) | 0) + (r8 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al4, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah4, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r8 = w << 16 | u & 65535;
                  u = ((imul(al4, bl5) | 0) + (r9 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah4, bl5) | 0) + (r9 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al4, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah4, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r9 = w << 16 | u & 65535;
                  u = ((imul(al4, bl6) | 0) + (r10 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah4, bl6) | 0) + (r10 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al4, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah4, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r10 = w << 16 | u & 65535;
                  u = ((imul(al4, bl7) | 0) + (r11 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah4, bl7) | 0) + (r11 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al4, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah4, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r11 = w << 16 | u & 65535;
                  r12 = m;
                  u = ((imul(al5, bl0) | 0) + (r5 & 65535) | 0) + (r13 & 65535) | 0;
                  v = ((imul(ah5, bl0) | 0) + (r5 >>> 16) | 0) + (r13 >>> 16) | 0;
                  w = ((imul(al5, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah5, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r5 = w << 16 | u & 65535;
                  u = ((imul(al5, bl1) | 0) + (r6 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah5, bl1) | 0) + (r6 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al5, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah5, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r6 = w << 16 | u & 65535;
                  u = ((imul(al5, bl2) | 0) + (r7 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah5, bl2) | 0) + (r7 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al5, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah5, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r7 = w << 16 | u & 65535;
                  u = ((imul(al5, bl3) | 0) + (r8 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah5, bl3) | 0) + (r8 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al5, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah5, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r8 = w << 16 | u & 65535;
                  u = ((imul(al5, bl4) | 0) + (r9 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah5, bl4) | 0) + (r9 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al5, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah5, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r9 = w << 16 | u & 65535;
                  u = ((imul(al5, bl5) | 0) + (r10 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah5, bl5) | 0) + (r10 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al5, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah5, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r10 = w << 16 | u & 65535;
                  u = ((imul(al5, bl6) | 0) + (r11 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah5, bl6) | 0) + (r11 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al5, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah5, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r11 = w << 16 | u & 65535;
                  u = ((imul(al5, bl7) | 0) + (r12 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah5, bl7) | 0) + (r12 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al5, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah5, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r12 = w << 16 | u & 65535;
                  r13 = m;
                  u = ((imul(al6, bl0) | 0) + (r6 & 65535) | 0) + (r14 & 65535) | 0;
                  v = ((imul(ah6, bl0) | 0) + (r6 >>> 16) | 0) + (r14 >>> 16) | 0;
                  w = ((imul(al6, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah6, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r6 = w << 16 | u & 65535;
                  u = ((imul(al6, bl1) | 0) + (r7 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah6, bl1) | 0) + (r7 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al6, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah6, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r7 = w << 16 | u & 65535;
                  u = ((imul(al6, bl2) | 0) + (r8 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah6, bl2) | 0) + (r8 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al6, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah6, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r8 = w << 16 | u & 65535;
                  u = ((imul(al6, bl3) | 0) + (r9 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah6, bl3) | 0) + (r9 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al6, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah6, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r9 = w << 16 | u & 65535;
                  u = ((imul(al6, bl4) | 0) + (r10 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah6, bl4) | 0) + (r10 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al6, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah6, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r10 = w << 16 | u & 65535;
                  u = ((imul(al6, bl5) | 0) + (r11 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah6, bl5) | 0) + (r11 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al6, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah6, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r11 = w << 16 | u & 65535;
                  u = ((imul(al6, bl6) | 0) + (r12 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah6, bl6) | 0) + (r12 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al6, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah6, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r12 = w << 16 | u & 65535;
                  u = ((imul(al6, bl7) | 0) + (r13 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah6, bl7) | 0) + (r13 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al6, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah6, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r13 = w << 16 | u & 65535;
                  r14 = m;
                  u = ((imul(al7, bl0) | 0) + (r7 & 65535) | 0) + (r15 & 65535) | 0;
                  v = ((imul(ah7, bl0) | 0) + (r7 >>> 16) | 0) + (r15 >>> 16) | 0;
                  w = ((imul(al7, bh0) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah7, bh0) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r7 = w << 16 | u & 65535;
                  u = ((imul(al7, bl1) | 0) + (r8 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah7, bl1) | 0) + (r8 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al7, bh1) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah7, bh1) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r8 = w << 16 | u & 65535;
                  u = ((imul(al7, bl2) | 0) + (r9 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah7, bl2) | 0) + (r9 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al7, bh2) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah7, bh2) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r9 = w << 16 | u & 65535;
                  u = ((imul(al7, bl3) | 0) + (r10 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah7, bl3) | 0) + (r10 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al7, bh3) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah7, bh3) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r10 = w << 16 | u & 65535;
                  u = ((imul(al7, bl4) | 0) + (r11 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah7, bl4) | 0) + (r11 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al7, bh4) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah7, bh4) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r11 = w << 16 | u & 65535;
                  u = ((imul(al7, bl5) | 0) + (r12 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah7, bl5) | 0) + (r12 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al7, bh5) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah7, bh5) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r12 = w << 16 | u & 65535;
                  u = ((imul(al7, bl6) | 0) + (r13 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah7, bl6) | 0) + (r13 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al7, bh6) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah7, bh6) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r13 = w << 16 | u & 65535;
                  u = ((imul(al7, bl7) | 0) + (r14 & 65535) | 0) + (m & 65535) | 0;
                  v = ((imul(ah7, bl7) | 0) + (r14 >>> 16) | 0) + (m >>> 16) | 0;
                  w = ((imul(al7, bh7) | 0) + (v & 65535) | 0) + (u >>> 16) | 0;
                  m = ((imul(ah7, bh7) | 0) + (v >>> 16) | 0) + (w >>> 16) | 0;
                  r14 = w << 16 | u & 65535;
                  r15 = m;
                  k = d + (i + j | 0) | 0;
                  r = HEAP32[Rk + k >> 2] | 0;
                  u = ((r & 65535) + ((r0 & 65535) << 1) | 0) + c | 0;
                  w = ((r >>> 16) + (r0 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                  HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                  c = w >>> 16;
                  k = k + 4 | 0;
                  r = HEAP32[Rk + k >> 2] | 0;
                  u = ((r & 65535) + ((r1 & 65535) << 1) | 0) + c | 0;
                  w = ((r >>> 16) + (r1 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                  HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                  c = w >>> 16;
                  k = k + 4 | 0;
                  r = HEAP32[Rk + k >> 2] | 0;
                  u = ((r & 65535) + ((r2 & 65535) << 1) | 0) + c | 0;
                  w = ((r >>> 16) + (r2 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                  HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                  c = w >>> 16;
                  k = k + 4 | 0;
                  r = HEAP32[Rk + k >> 2] | 0;
                  u = ((r & 65535) + ((r3 & 65535) << 1) | 0) + c | 0;
                  w = ((r >>> 16) + (r3 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                  HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                  c = w >>> 16;
                  k = k + 4 | 0;
                  r = HEAP32[Rk + k >> 2] | 0;
                  u = ((r & 65535) + ((r4 & 65535) << 1) | 0) + c | 0;
                  w = ((r >>> 16) + (r4 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                  HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                  c = w >>> 16;
                  k = k + 4 | 0;
                  r = HEAP32[Rk + k >> 2] | 0;
                  u = ((r & 65535) + ((r5 & 65535) << 1) | 0) + c | 0;
                  w = ((r >>> 16) + (r5 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                  HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                  c = w >>> 16;
                  k = k + 4 | 0;
                  r = HEAP32[Rk + k >> 2] | 0;
                  u = ((r & 65535) + ((r6 & 65535) << 1) | 0) + c | 0;
                  w = ((r >>> 16) + (r6 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                  HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                  c = w >>> 16;
                  k = k + 4 | 0;
                  r = HEAP32[Rk + k >> 2] | 0;
                  u = ((r & 65535) + ((r7 & 65535) << 1) | 0) + c | 0;
                  w = ((r >>> 16) + (r7 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                  HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                  c = w >>> 16;
                }
                k = d + (i + j | 0) | 0;
                r = HEAP32[Rk + k >> 2] | 0;
                u = (((r & 65535) + ((r8 & 65535) << 1) | 0) + c | 0) + h | 0;
                w = ((r >>> 16) + (r8 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                c = w >>> 16;
                k = k + 4 | 0;
                r = HEAP32[Rk + k >> 2] | 0;
                u = ((r & 65535) + ((r9 & 65535) << 1) | 0) + c | 0;
                w = ((r >>> 16) + (r9 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                c = w >>> 16;
                k = k + 4 | 0;
                r = HEAP32[Rk + k >> 2] | 0;
                u = ((r & 65535) + ((r10 & 65535) << 1) | 0) + c | 0;
                w = ((r >>> 16) + (r10 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                c = w >>> 16;
                k = k + 4 | 0;
                r = HEAP32[Rk + k >> 2] | 0;
                u = ((r & 65535) + ((r11 & 65535) << 1) | 0) + c | 0;
                w = ((r >>> 16) + (r11 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                c = w >>> 16;
                k = k + 4 | 0;
                r = HEAP32[Rk + k >> 2] | 0;
                u = ((r & 65535) + ((r12 & 65535) << 1) | 0) + c | 0;
                w = ((r >>> 16) + (r12 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                c = w >>> 16;
                k = k + 4 | 0;
                r = HEAP32[Rk + k >> 2] | 0;
                u = ((r & 65535) + ((r13 & 65535) << 1) | 0) + c | 0;
                w = ((r >>> 16) + (r13 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                c = w >>> 16;
                k = k + 4 | 0;
                r = HEAP32[Rk + k >> 2] | 0;
                u = ((r & 65535) + ((r14 & 65535) << 1) | 0) + c | 0;
                w = ((r >>> 16) + (r14 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                c = w >>> 16;
                k = k + 4 | 0;
                r = HEAP32[Rk + k >> 2] | 0;
                u = ((r & 65535) + ((r15 & 65535) << 1) | 0) + c | 0;
                w = ((r >>> 16) + (r15 >>> 16 << 1) | 0) + (u >>> 16) | 0;
                HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                h = w >>> 16;
              }
              for (k = k + 4 | 0; !!h & (k | 0) < dd << 1; k = k + 4 | 0) {
                r = HEAP32[Rk + k >> 2] | 0;
                u = (r & 65535) + h | 0;
                w = (r >>> 16) + (u >>> 16) | 0;
                HEAP32[Rk + k >> 2] = w << 16 | u & 65535;
                h = w >>> 16;
              }
            }
          }
        }
        function div(N, lN, D, lD, Q) {
          N = N | 0;
          lN = lN | 0;
          D = D | 0;
          lD = lD | 0;
          Q = Q | 0;
          var n = 0, d = 0, e = 0, u1 = 0, u0 = 0, v0 = 0, vh = 0, vl = 0, qh = 0, ql = 0, rh = 0, rl = 0, t1 = 0, t2 = 0, m = 0, c = 0, i = 0, j = 0, k = 0;
          for (i = lN - 1 & -4; (i | 0) >= 0; i = i - 4 | 0) {
            n = HEAP32[N + i >> 2] | 0;
            if (n) {
              lN = i;
              break;
            }
          }
          for (i = lD - 1 & -4; (i | 0) >= 0; i = i - 4 | 0) {
            d = HEAP32[D + i >> 2] | 0;
            if (d) {
              lD = i;
              break;
            }
          }
          while ((d & 2147483648) == 0) {
            d = d << 1;
            e = e + 1 | 0;
          }
          u0 = HEAP32[N + lN >> 2] | 0;
          if (e) {
            u1 = u0 >>> (32 - e | 0);
            for (i = lN - 4 | 0; (i | 0) >= 0; i = i - 4 | 0) {
              n = HEAP32[N + i >> 2] | 0;
              HEAP32[N + i + 4 >> 2] = u0 << e | (e ? n >>> (32 - e | 0) : 0);
              u0 = n;
            }
            HEAP32[N >> 2] = u0 << e;
          }
          if (e) {
            v0 = HEAP32[D + lD >> 2] | 0;
            for (i = lD - 4 | 0; (i | 0) >= 0; i = i - 4 | 0) {
              d = HEAP32[D + i >> 2] | 0;
              HEAP32[D + i + 4 >> 2] = v0 << e | d >>> (32 - e | 0);
              v0 = d;
            }
            HEAP32[D >> 2] = v0 << e;
          }
          v0 = HEAP32[D + lD >> 2] | 0;
          vh = v0 >>> 16, vl = v0 & 65535;
          for (i = lN; (i | 0) >= (lD | 0); i = i - 4 | 0) {
            j = i - lD | 0;
            u0 = HEAP32[N + i >> 2] | 0;
            qh = (u1 >>> 0) / (vh >>> 0) | 0, rh = (u1 >>> 0) % (vh >>> 0) | 0, t1 = imul(qh, vl) | 0;
            while ((qh | 0) == 65536 | t1 >>> 0 > (rh << 16 | u0 >>> 16) >>> 0) {
              qh = qh - 1 | 0, rh = rh + vh | 0, t1 = t1 - vl | 0;
              if ((rh | 0) >= 65536)
                break;
            }
            m = 0, c = 0;
            for (k = 0; (k | 0) <= (lD | 0); k = k + 4 | 0) {
              d = HEAP32[D + k >> 2] | 0;
              t1 = (imul(qh, d & 65535) | 0) + (m >>> 16) | 0;
              t2 = (imul(qh, d >>> 16) | 0) + (t1 >>> 16) | 0;
              d = m & 65535 | t1 << 16;
              m = t2;
              n = HEAP32[N + j + k >> 2] | 0;
              t1 = ((n & 65535) - (d & 65535) | 0) + c | 0;
              t2 = ((n >>> 16) - (d >>> 16) | 0) + (t1 >> 16) | 0;
              HEAP32[N + j + k >> 2] = t2 << 16 | t1 & 65535;
              c = t2 >> 16;
            }
            t1 = ((u1 & 65535) - (m & 65535) | 0) + c | 0;
            t2 = ((u1 >>> 16) - (m >>> 16) | 0) + (t1 >> 16) | 0;
            u1 = t2 << 16 | t1 & 65535;
            c = t2 >> 16;
            if (c) {
              qh = qh - 1 | 0;
              c = 0;
              for (k = 0; (k | 0) <= (lD | 0); k = k + 4 | 0) {
                d = HEAP32[D + k >> 2] | 0;
                n = HEAP32[N + j + k >> 2] | 0;
                t1 = (n & 65535) + c | 0;
                t2 = (n >>> 16) + d + (t1 >>> 16) | 0;
                HEAP32[N + j + k >> 2] = t2 << 16 | t1 & 65535;
                c = t2 >>> 16;
              }
              u1 = u1 + c | 0;
            }
            u0 = HEAP32[N + i >> 2] | 0;
            n = u1 << 16 | u0 >>> 16;
            ql = (n >>> 0) / (vh >>> 0) | 0, rl = (n >>> 0) % (vh >>> 0) | 0, t1 = imul(ql, vl) | 0;
            while ((ql | 0) == 65536 | t1 >>> 0 > (rl << 16 | u0 & 65535) >>> 0) {
              ql = ql - 1 | 0, rl = rl + vh | 0, t1 = t1 - vl | 0;
              if ((rl | 0) >= 65536)
                break;
            }
            m = 0, c = 0;
            for (k = 0; (k | 0) <= (lD | 0); k = k + 4 | 0) {
              d = HEAP32[D + k >> 2] | 0;
              t1 = (imul(ql, d & 65535) | 0) + (m & 65535) | 0;
              t2 = ((imul(ql, d >>> 16) | 0) + (t1 >>> 16) | 0) + (m >>> 16) | 0;
              d = t1 & 65535 | t2 << 16;
              m = t2 >>> 16;
              n = HEAP32[N + j + k >> 2] | 0;
              t1 = ((n & 65535) - (d & 65535) | 0) + c | 0;
              t2 = ((n >>> 16) - (d >>> 16) | 0) + (t1 >> 16) | 0;
              c = t2 >> 16;
              HEAP32[N + j + k >> 2] = t2 << 16 | t1 & 65535;
            }
            t1 = ((u1 & 65535) - (m & 65535) | 0) + c | 0;
            t2 = ((u1 >>> 16) - (m >>> 16) | 0) + (t1 >> 16) | 0;
            c = t2 >> 16;
            if (c) {
              ql = ql - 1 | 0;
              c = 0;
              for (k = 0; (k | 0) <= (lD | 0); k = k + 4 | 0) {
                d = HEAP32[D + k >> 2] | 0;
                n = HEAP32[N + j + k >> 2] | 0;
                t1 = ((n & 65535) + (d & 65535) | 0) + c | 0;
                t2 = ((n >>> 16) + (d >>> 16) | 0) + (t1 >>> 16) | 0;
                c = t2 >>> 16;
                HEAP32[N + j + k >> 2] = t1 & 65535 | t2 << 16;
              }
            }
            HEAP32[Q + j >> 2] = qh << 16 | ql;
            u1 = HEAP32[N + i >> 2] | 0;
          }
          if (e) {
            u0 = HEAP32[N >> 2] | 0;
            for (i = 4; (i | 0) <= (lD | 0); i = i + 4 | 0) {
              n = HEAP32[N + i >> 2] | 0;
              HEAP32[N + i - 4 >> 2] = n << (32 - e | 0) | u0 >>> e;
              u0 = n;
            }
            HEAP32[N + lD >> 2] = u0 >>> e;
          }
        }
        function mredc(A, lA, N, lN, y, R) {
          A = A | 0;
          lA = lA | 0;
          N = N | 0;
          lN = lN | 0;
          y = y | 0;
          R = R | 0;
          var T = 0, c = 0, uh = 0, ul = 0, vl = 0, vh = 0, w0 = 0, w1 = 0, w2 = 0, r0 = 0, r1 = 0, i = 0, j = 0, k = 0;
          T = salloc(lN << 1) | 0;
          z(lN << 1, 0, T);
          cp(lA, A, T);
          for (i = 0; (i | 0) < (lN | 0); i = i + 4 | 0) {
            uh = HEAP32[T + i >> 2] | 0, ul = uh & 65535, uh = uh >>> 16;
            vh = y >>> 16, vl = y & 65535;
            w0 = imul(ul, vl) | 0, w1 = ((imul(ul, vh) | 0) + (imul(uh, vl) | 0) | 0) + (w0 >>> 16) | 0;
            ul = w0 & 65535, uh = w1 & 65535;
            r1 = 0;
            for (j = 0; (j | 0) < (lN | 0); j = j + 4 | 0) {
              k = i + j | 0;
              vh = HEAP32[N + j >> 2] | 0, vl = vh & 65535, vh = vh >>> 16;
              r0 = HEAP32[T + k >> 2] | 0;
              w0 = ((imul(ul, vl) | 0) + (r1 & 65535) | 0) + (r0 & 65535) | 0;
              w1 = ((imul(ul, vh) | 0) + (r1 >>> 16) | 0) + (r0 >>> 16) | 0;
              w2 = ((imul(uh, vl) | 0) + (w1 & 65535) | 0) + (w0 >>> 16) | 0;
              r1 = ((imul(uh, vh) | 0) + (w2 >>> 16) | 0) + (w1 >>> 16) | 0;
              r0 = w2 << 16 | w0 & 65535;
              HEAP32[T + k >> 2] = r0;
            }
            k = i + j | 0;
            r0 = HEAP32[T + k >> 2] | 0;
            w0 = ((r0 & 65535) + (r1 & 65535) | 0) + c | 0;
            w1 = ((r0 >>> 16) + (r1 >>> 16) | 0) + (w0 >>> 16) | 0;
            HEAP32[T + k >> 2] = w1 << 16 | w0 & 65535;
            c = w1 >>> 16;
          }
          cp(lN, T + lN | 0, R);
          sfree(lN << 1);
          if (c | (cmp(N, lN, R, lN) | 0) <= 0) {
            sub(R, lN, N, lN, R, lN) | 0;
          }
        }
        return {
          sreset,
          salloc,
          sfree,
          z,
          tst,
          neg,
          cmp,
          add,
          sub,
          mul,
          sqr,
          div,
          mredc
        };
      };
      function Number_extGCD(a, b) {
        var sa = a < 0 ? -1 : 1, sb = b < 0 ? -1 : 1, xi = 1, xj = 0, yi = 0, yj = 1, r, q, t, a_cmp_b;
        a *= sa;
        b *= sb;
        a_cmp_b = a < b;
        if (a_cmp_b) {
          t = a;
          a = b, b = t;
          t = sa;
          sa = sb;
          sb = t;
        }
        q = Math.floor(a / b), r = a - q * b;
        while (r) {
          t = xi - q * xj, xi = xj, xj = t;
          t = yi - q * yj, yi = yj, yj = t;
          a = b, b = r;
          q = Math.floor(a / b), r = a - q * b;
        }
        xj *= sa;
        yj *= sb;
        if (a_cmp_b) {
          t = xj;
          xj = yj, yj = t;
        }
        return {
          gcd: b,
          x: xj,
          y: yj
        };
      }
      function BigNumber_extGCD(a, b) {
        var sa = a.sign;
        var sb = b.sign;
        if (sa < 0)
          a = a.negate();
        if (sb < 0)
          b = b.negate();
        var a_cmp_b = a.compare(b);
        if (a_cmp_b < 0) {
          var t = a;
          a = b, b = t;
          var t2 = sa;
          sa = sb;
          sb = t2;
        }
        var xi = BigNumber.ONE, xj = BigNumber.ZERO, lx = b.bitLength, yi = BigNumber.ZERO, yj = BigNumber.ONE, ly = a.bitLength, z, r, q;
        z = a.divide(b);
        while ((r = z.remainder) !== BigNumber.ZERO) {
          q = z.quotient;
          z = xi.subtract(q.multiply(xj).clamp(lx)).clamp(lx), xi = xj, xj = z;
          z = yi.subtract(q.multiply(yj).clamp(ly)).clamp(ly), yi = yj, yj = z;
          a = b, b = r;
          z = a.divide(b);
        }
        if (sa < 0)
          xj = xj.negate();
        if (sb < 0)
          yj = yj.negate();
        if (a_cmp_b < 0) {
          var t = xj;
          xj = yj, yj = t;
        }
        return {
          gcd: b,
          x: xj,
          y: yj
        };
      }
      function getRandomValues2(buf) {
        if (typeof process !== "undefined") {
          var nodeCrypto = require_crypto();
          var bytes = nodeCrypto.randomBytes(buf.length);
          buf.set(bytes);
          return;
        }
        if (window.crypto && window.crypto.getRandomValues) {
          window.crypto.getRandomValues(buf);
          return;
        }
        if (self.crypto && self.crypto.getRandomValues) {
          self.crypto.getRandomValues(buf);
          return;
        }
        if (window.msCrypto && window.msCrypto.getRandomValues) {
          window.msCrypto.getRandomValues(buf);
          return;
        }
        throw new Error("No secure random number generator available.");
      }
      var __extends$8 = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var _bigint_stdlib = { Uint32Array, Math };
      var _bigint_heap = new Uint32Array(1048576);
      var _bigint_asm;
      function _half_imul(a, b) {
        return a * b | 0;
      }
      if (_bigint_stdlib.Math.imul === void 0) {
        _bigint_stdlib.Math.imul = _half_imul;
        _bigint_asm = bigint_asm(_bigint_stdlib, null, _bigint_heap.buffer);
        delete _bigint_stdlib.Math.imul;
      } else {
        _bigint_asm = bigint_asm(_bigint_stdlib, null, _bigint_heap.buffer);
      }
      var _BigNumber_ZERO_limbs = new Uint32Array(0);
      var BigNumber = function() {
        function BigNumber2(num) {
          var limbs = _BigNumber_ZERO_limbs;
          var bitlen = 0;
          var sign = 0;
          if (num === void 0)
            ;
          else {
            for (var i = 0; !num[i]; i++)
              ;
            bitlen = (num.length - i) * 8;
            if (!bitlen)
              return BigNumber2.ZERO;
            limbs = new Uint32Array(bitlen + 31 >> 5);
            for (var j = num.length - 4; j >= i; j -= 4) {
              limbs[num.length - 4 - j >> 2] = num[j] << 24 | num[j + 1] << 16 | num[j + 2] << 8 | num[j + 3];
            }
            if (i - j === 3) {
              limbs[limbs.length - 1] = num[i];
            } else if (i - j === 2) {
              limbs[limbs.length - 1] = num[i] << 8 | num[i + 1];
            } else if (i - j === 1) {
              limbs[limbs.length - 1] = num[i] << 16 | num[i + 1] << 8 | num[i + 2];
            }
            sign = 1;
          }
          this.limbs = limbs;
          this.bitLength = bitlen;
          this.sign = sign;
        }
        BigNumber2.fromString = function(str) {
          var bytes = string_to_bytes(str);
          return new BigNumber2(bytes);
        };
        BigNumber2.fromNumber = function(num) {
          var limbs = _BigNumber_ZERO_limbs;
          var bitlen = 0;
          var sign = 0;
          var absnum = Math.abs(num);
          if (absnum > 4294967295) {
            limbs = new Uint32Array(2);
            limbs[0] = absnum | 0;
            limbs[1] = absnum / 4294967296 | 0;
            bitlen = 52;
          } else if (absnum > 0) {
            limbs = new Uint32Array(1);
            limbs[0] = absnum;
            bitlen = 32;
          } else {
            limbs = _BigNumber_ZERO_limbs;
            bitlen = 0;
          }
          sign = num < 0 ? -1 : 1;
          return BigNumber2.fromConfig({ limbs, bitLength: bitlen, sign });
        };
        BigNumber2.fromArrayBuffer = function(buffer) {
          return new BigNumber2(new Uint8Array(buffer));
        };
        BigNumber2.fromConfig = function(obj) {
          var bn = new BigNumber2();
          bn.limbs = new Uint32Array(obj.limbs);
          bn.bitLength = obj.bitLength;
          bn.sign = obj.sign;
          return bn;
        };
        BigNumber2.prototype.toString = function(radix) {
          radix = radix || 16;
          var limbs = this.limbs;
          var bitlen = this.bitLength;
          var str = "";
          if (radix === 16) {
            for (var i = (bitlen + 31 >> 5) - 1; i >= 0; i--) {
              var h = limbs[i].toString(16);
              str += "00000000".substr(h.length);
              str += h;
            }
            str = str.replace(/^0+/, "");
            if (!str.length)
              str = "0";
          } else {
            throw new IllegalArgumentError("bad radix");
          }
          if (this.sign < 0)
            str = "-" + str;
          return str;
        };
        BigNumber2.prototype.toBytes = function() {
          var bitlen = this.bitLength;
          var limbs = this.limbs;
          if (bitlen === 0)
            return new Uint8Array(0);
          var bytelen = bitlen + 7 >> 3;
          var bytes = new Uint8Array(bytelen);
          for (var i = 0; i < bytelen; i++) {
            var j = bytelen - i - 1;
            bytes[i] = limbs[j >> 2] >> ((j & 3) << 3);
          }
          return bytes;
        };
        BigNumber2.prototype.valueOf = function() {
          var limbs = this.limbs;
          var bits = this.bitLength;
          var sign = this.sign;
          if (!sign)
            return 0;
          if (bits <= 32)
            return sign * (limbs[0] >>> 0);
          if (bits <= 52)
            return sign * (4294967296 * (limbs[1] >>> 0) + (limbs[0] >>> 0));
          var i, l, e = 0;
          for (i = limbs.length - 1; i >= 0; i--) {
            if ((l = limbs[i]) === 0)
              continue;
            while ((l << e & 2147483648) === 0)
              e++;
            break;
          }
          if (i === 0)
            return sign * (limbs[0] >>> 0);
          return sign * (1048576 * ((limbs[i] << e | (e ? limbs[i - 1] >>> 32 - e : 0)) >>> 0) + ((limbs[i - 1] << e | (e && i > 1 ? limbs[i - 2] >>> 32 - e : 0)) >>> 12)) * Math.pow(2, 32 * i - e - 52);
        };
        BigNumber2.prototype.clamp = function(b) {
          var limbs = this.limbs;
          var bitlen = this.bitLength;
          if (b >= bitlen)
            return this;
          var clamped = new BigNumber2();
          var n = b + 31 >> 5;
          var k = b % 32;
          clamped.limbs = new Uint32Array(limbs.subarray(0, n));
          clamped.bitLength = b;
          clamped.sign = this.sign;
          if (k)
            clamped.limbs[n - 1] &= -1 >>> 32 - k;
          return clamped;
        };
        BigNumber2.prototype.slice = function(f2, b) {
          var limbs = this.limbs;
          var bitlen = this.bitLength;
          if (f2 < 0)
            throw new RangeError("TODO");
          if (f2 >= bitlen)
            return BigNumber2.ZERO;
          if (b === void 0 || b > bitlen - f2)
            b = bitlen - f2;
          var sliced = new BigNumber2();
          var n = f2 >> 5;
          var m = f2 + b + 31 >> 5;
          var l = b + 31 >> 5;
          var t = f2 % 32;
          var k = b % 32;
          var slimbs = new Uint32Array(l);
          if (t) {
            for (var i = 0; i < m - n - 1; i++) {
              slimbs[i] = limbs[n + i] >>> t | limbs[n + i + 1] << 32 - t;
            }
            slimbs[i] = limbs[n + i] >>> t;
          } else {
            slimbs.set(limbs.subarray(n, m));
          }
          if (k) {
            slimbs[l - 1] &= -1 >>> 32 - k;
          }
          sliced.limbs = slimbs;
          sliced.bitLength = b;
          sliced.sign = this.sign;
          return sliced;
        };
        BigNumber2.prototype.negate = function() {
          var negative = new BigNumber2();
          negative.limbs = this.limbs;
          negative.bitLength = this.bitLength;
          negative.sign = -1 * this.sign;
          return negative;
        };
        BigNumber2.prototype.compare = function(that) {
          var alimbs = this.limbs, alimbcnt = alimbs.length, blimbs = that.limbs, blimbcnt = blimbs.length, z = 0;
          if (this.sign < that.sign)
            return -1;
          if (this.sign > that.sign)
            return 1;
          _bigint_heap.set(alimbs, 0);
          _bigint_heap.set(blimbs, alimbcnt);
          z = _bigint_asm.cmp(0, alimbcnt << 2, alimbcnt << 2, blimbcnt << 2);
          return z * this.sign;
        };
        BigNumber2.prototype.add = function(that) {
          if (!this.sign)
            return that;
          if (!that.sign)
            return this;
          var abitlen = this.bitLength, alimbs = this.limbs, alimbcnt = alimbs.length, asign = this.sign, bbitlen = that.bitLength, blimbs = that.limbs, blimbcnt = blimbs.length, bsign = that.sign, rbitlen, rlimbcnt, rsign, rof, result = new BigNumber2();
          rbitlen = (abitlen > bbitlen ? abitlen : bbitlen) + (asign * bsign > 0 ? 1 : 0);
          rlimbcnt = rbitlen + 31 >> 5;
          _bigint_asm.sreset();
          var pA = _bigint_asm.salloc(alimbcnt << 2), pB = _bigint_asm.salloc(blimbcnt << 2), pR = _bigint_asm.salloc(rlimbcnt << 2);
          _bigint_asm.z(pR - pA + (rlimbcnt << 2), 0, pA);
          _bigint_heap.set(alimbs, pA >> 2);
          _bigint_heap.set(blimbs, pB >> 2);
          if (asign * bsign > 0) {
            _bigint_asm.add(pA, alimbcnt << 2, pB, blimbcnt << 2, pR, rlimbcnt << 2);
            rsign = asign;
          } else if (asign > bsign) {
            rof = _bigint_asm.sub(pA, alimbcnt << 2, pB, blimbcnt << 2, pR, rlimbcnt << 2);
            rsign = rof ? bsign : asign;
          } else {
            rof = _bigint_asm.sub(pB, blimbcnt << 2, pA, alimbcnt << 2, pR, rlimbcnt << 2);
            rsign = rof ? asign : bsign;
          }
          if (rof)
            _bigint_asm.neg(pR, rlimbcnt << 2, pR, rlimbcnt << 2);
          if (_bigint_asm.tst(pR, rlimbcnt << 2) === 0)
            return BigNumber2.ZERO;
          result.limbs = new Uint32Array(_bigint_heap.subarray(pR >> 2, (pR >> 2) + rlimbcnt));
          result.bitLength = rbitlen;
          result.sign = rsign;
          return result;
        };
        BigNumber2.prototype.subtract = function(that) {
          return this.add(that.negate());
        };
        BigNumber2.prototype.square = function() {
          if (!this.sign)
            return BigNumber2.ZERO;
          var abitlen = this.bitLength, alimbs = this.limbs, alimbcnt = alimbs.length, rbitlen, rlimbcnt, result = new BigNumber2();
          rbitlen = abitlen << 1;
          rlimbcnt = rbitlen + 31 >> 5;
          _bigint_asm.sreset();
          var pA = _bigint_asm.salloc(alimbcnt << 2), pR = _bigint_asm.salloc(rlimbcnt << 2);
          _bigint_asm.z(pR - pA + (rlimbcnt << 2), 0, pA);
          _bigint_heap.set(alimbs, pA >> 2);
          _bigint_asm.sqr(pA, alimbcnt << 2, pR);
          result.limbs = new Uint32Array(_bigint_heap.subarray(pR >> 2, (pR >> 2) + rlimbcnt));
          result.bitLength = rbitlen;
          result.sign = 1;
          return result;
        };
        BigNumber2.prototype.divide = function(that) {
          var abitlen = this.bitLength, alimbs = this.limbs, alimbcnt = alimbs.length, bbitlen = that.bitLength, blimbs = that.limbs, blimbcnt = blimbs.length, qlimbcnt, rlimbcnt, quotient = BigNumber2.ZERO, remainder = BigNumber2.ZERO;
          _bigint_asm.sreset();
          var pA = _bigint_asm.salloc(alimbcnt << 2), pB = _bigint_asm.salloc(blimbcnt << 2), pQ = _bigint_asm.salloc(alimbcnt << 2);
          _bigint_asm.z(pQ - pA + (alimbcnt << 2), 0, pA);
          _bigint_heap.set(alimbs, pA >> 2);
          _bigint_heap.set(blimbs, pB >> 2);
          _bigint_asm.div(pA, alimbcnt << 2, pB, blimbcnt << 2, pQ);
          qlimbcnt = _bigint_asm.tst(pQ, alimbcnt << 2) >> 2;
          if (qlimbcnt) {
            quotient = new BigNumber2();
            quotient.limbs = new Uint32Array(_bigint_heap.subarray(pQ >> 2, (pQ >> 2) + qlimbcnt));
            quotient.bitLength = abitlen < qlimbcnt << 5 ? abitlen : qlimbcnt << 5;
            quotient.sign = this.sign * that.sign;
          }
          rlimbcnt = _bigint_asm.tst(pA, blimbcnt << 2) >> 2;
          if (rlimbcnt) {
            remainder = new BigNumber2();
            remainder.limbs = new Uint32Array(_bigint_heap.subarray(pA >> 2, (pA >> 2) + rlimbcnt));
            remainder.bitLength = bbitlen < rlimbcnt << 5 ? bbitlen : rlimbcnt << 5;
            remainder.sign = this.sign;
          }
          return {
            quotient,
            remainder
          };
        };
        BigNumber2.prototype.multiply = function(that) {
          if (!this.sign || !that.sign)
            return BigNumber2.ZERO;
          var abitlen = this.bitLength, alimbs = this.limbs, alimbcnt = alimbs.length, bbitlen = that.bitLength, blimbs = that.limbs, blimbcnt = blimbs.length, rbitlen, rlimbcnt, result = new BigNumber2();
          rbitlen = abitlen + bbitlen;
          rlimbcnt = rbitlen + 31 >> 5;
          _bigint_asm.sreset();
          var pA = _bigint_asm.salloc(alimbcnt << 2), pB = _bigint_asm.salloc(blimbcnt << 2), pR = _bigint_asm.salloc(rlimbcnt << 2);
          _bigint_asm.z(pR - pA + (rlimbcnt << 2), 0, pA);
          _bigint_heap.set(alimbs, pA >> 2);
          _bigint_heap.set(blimbs, pB >> 2);
          _bigint_asm.mul(pA, alimbcnt << 2, pB, blimbcnt << 2, pR, rlimbcnt << 2);
          result.limbs = new Uint32Array(_bigint_heap.subarray(pR >> 2, (pR >> 2) + rlimbcnt));
          result.sign = this.sign * that.sign;
          result.bitLength = rbitlen;
          return result;
        };
        BigNumber2.prototype.isMillerRabinProbablePrime = function(rounds) {
          var t = BigNumber2.fromConfig(this), s = 0;
          t.limbs[0] -= 1;
          while (t.limbs[s >> 5] === 0)
            s += 32;
          while ((t.limbs[s >> 5] >> (s & 31) & 1) === 0)
            s++;
          t = t.slice(s);
          var m = new Modulus(this), m1 = this.subtract(BigNumber2.ONE), a = BigNumber2.fromConfig(this), l = this.limbs.length - 1;
          while (a.limbs[l] === 0)
            l--;
          while (--rounds >= 0) {
            getRandomValues2(a.limbs);
            if (a.limbs[0] < 2)
              a.limbs[0] += 2;
            while (a.compare(m1) >= 0)
              a.limbs[l] >>>= 1;
            var x = m.power(a, t);
            if (x.compare(BigNumber2.ONE) === 0)
              continue;
            if (x.compare(m1) === 0)
              continue;
            var c = s;
            while (--c > 0) {
              x = x.square().divide(m).remainder;
              if (x.compare(BigNumber2.ONE) === 0)
                return false;
              if (x.compare(m1) === 0)
                break;
            }
            if (c === 0)
              return false;
          }
          return true;
        };
        BigNumber2.prototype.isProbablePrime = function(paranoia) {
          if (paranoia === void 0) {
            paranoia = 80;
          }
          var limbs = this.limbs;
          var i = 0;
          if ((limbs[0] & 1) === 0)
            return false;
          if (paranoia <= 1)
            return true;
          var s3 = 0, s5 = 0, s17 = 0;
          for (i = 0; i < limbs.length; i++) {
            var l3 = limbs[i];
            while (l3) {
              s3 += l3 & 3;
              l3 >>>= 2;
            }
            var l5 = limbs[i];
            while (l5) {
              s5 += l5 & 3;
              l5 >>>= 2;
              s5 -= l5 & 3;
              l5 >>>= 2;
            }
            var l17 = limbs[i];
            while (l17) {
              s17 += l17 & 15;
              l17 >>>= 4;
              s17 -= l17 & 15;
              l17 >>>= 4;
            }
          }
          if (!(s3 % 3) || !(s5 % 5) || !(s17 % 17))
            return false;
          if (paranoia <= 2)
            return true;
          return this.isMillerRabinProbablePrime(paranoia >>> 1);
        };
        BigNumber2.extGCD = BigNumber_extGCD;
        BigNumber2.ZERO = BigNumber2.fromNumber(0);
        BigNumber2.ONE = BigNumber2.fromNumber(1);
        return BigNumber2;
      }();
      var Modulus = function(_super) {
        __extends$8(Modulus2, _super);
        function Modulus2(number) {
          var _this = _super.call(this) || this;
          _this.limbs = number.limbs;
          _this.bitLength = number.bitLength;
          _this.sign = number.sign;
          if (_this.valueOf() < 1)
            throw new RangeError();
          if (_this.bitLength <= 32)
            return _this;
          var comodulus;
          if (_this.limbs[0] & 1) {
            var bitlen = (_this.bitLength + 31 & -32) + 1;
            var limbs = new Uint32Array(bitlen + 31 >> 5);
            limbs[limbs.length - 1] = 1;
            comodulus = new BigNumber();
            comodulus.sign = 1;
            comodulus.bitLength = bitlen;
            comodulus.limbs = limbs;
            var k = Number_extGCD(4294967296, _this.limbs[0]).y;
            _this.coefficient = k < 0 ? -k : 4294967296 - k;
          } else {
            return _this;
          }
          _this.comodulus = comodulus;
          _this.comodulusRemainder = comodulus.divide(_this).remainder;
          _this.comodulusRemainderSquare = comodulus.square().divide(_this).remainder;
          return _this;
        }
        Modulus2.prototype.reduce = function(a) {
          if (a.bitLength <= 32 && this.bitLength <= 32)
            return BigNumber.fromNumber(a.valueOf() % this.valueOf());
          if (a.compare(this) < 0)
            return a;
          return a.divide(this).remainder;
        };
        Modulus2.prototype.inverse = function(a) {
          a = this.reduce(a);
          var r = BigNumber_extGCD(this, a);
          if (r.gcd.valueOf() !== 1)
            throw new Error("GCD is not 1");
          if (r.y.sign < 0)
            return r.y.add(this).clamp(this.bitLength);
          return r.y;
        };
        Modulus2.prototype.power = function(g, e) {
          var c = 0;
          for (var i = 0; i < e.limbs.length; i++) {
            var t = e.limbs[i];
            while (t) {
              if (t & 1)
                c++;
              t >>>= 1;
            }
          }
          var k = 8;
          if (e.bitLength <= 4536)
            k = 7;
          if (e.bitLength <= 1736)
            k = 6;
          if (e.bitLength <= 630)
            k = 5;
          if (e.bitLength <= 210)
            k = 4;
          if (e.bitLength <= 60)
            k = 3;
          if (e.bitLength <= 12)
            k = 2;
          if (c <= 1 << k - 1)
            k = 1;
          g = Modulus2._Montgomery_reduce(this.reduce(g).multiply(this.comodulusRemainderSquare), this);
          var g2 = Modulus2._Montgomery_reduce(g.square(), this), gn = new Array(1 << k - 1);
          gn[0] = g;
          gn[1] = Modulus2._Montgomery_reduce(g.multiply(g2), this);
          for (var i = 2; i < 1 << k - 1; i++) {
            gn[i] = Modulus2._Montgomery_reduce(gn[i - 1].multiply(g2), this);
          }
          var u = this.comodulusRemainder;
          var r = u;
          for (var i = e.limbs.length - 1; i >= 0; i--) {
            var t = e.limbs[i];
            for (var j = 32; j > 0; ) {
              if (t & 2147483648) {
                var n = t >>> 32 - k, l = k;
                while ((n & 1) === 0) {
                  n >>>= 1;
                  l--;
                }
                var m = gn[n >>> 1];
                while (n) {
                  n >>>= 1;
                  if (r !== u)
                    r = Modulus2._Montgomery_reduce(r.square(), this);
                }
                r = r !== u ? Modulus2._Montgomery_reduce(r.multiply(m), this) : m;
                t <<= l, j -= l;
              } else {
                if (r !== u)
                  r = Modulus2._Montgomery_reduce(r.square(), this);
                t <<= 1, j--;
              }
            }
          }
          return Modulus2._Montgomery_reduce(r, this);
        };
        Modulus2._Montgomery_reduce = function(a, n) {
          var alimbs = a.limbs;
          var alimbcnt = alimbs.length;
          var nlimbs = n.limbs;
          var nlimbcnt = nlimbs.length;
          var y = n.coefficient;
          _bigint_asm.sreset();
          var pA = _bigint_asm.salloc(alimbcnt << 2), pN = _bigint_asm.salloc(nlimbcnt << 2), pR = _bigint_asm.salloc(nlimbcnt << 2);
          _bigint_asm.z(pR - pA + (nlimbcnt << 2), 0, pA);
          _bigint_heap.set(alimbs, pA >> 2);
          _bigint_heap.set(nlimbs, pN >> 2);
          _bigint_asm.mredc(pA, alimbcnt << 2, pN, nlimbcnt << 2, y, pR);
          var result = new BigNumber();
          result.limbs = new Uint32Array(_bigint_heap.subarray(pR >> 2, (pR >> 2) + nlimbcnt));
          result.bitLength = n.bitLength;
          result.sign = 1;
          return result;
        };
        return Modulus2;
      }(BigNumber);
      var sha1_asm = function(stdlib, foreign, buffer) {
        ;
        var H0 = 0, H1 = 0, H2 = 0, H3 = 0, H4 = 0, TOTAL0 = 0, TOTAL1 = 0;
        var I0 = 0, I1 = 0, I2 = 0, I3 = 0, I4 = 0, O0 = 0, O1 = 0, O2 = 0, O3 = 0, O4 = 0;
        var HEAP = new stdlib.Uint8Array(buffer);
        function _core(w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15) {
          w0 = w0 | 0;
          w1 = w1 | 0;
          w2 = w2 | 0;
          w3 = w3 | 0;
          w4 = w4 | 0;
          w5 = w5 | 0;
          w6 = w6 | 0;
          w7 = w7 | 0;
          w8 = w8 | 0;
          w9 = w9 | 0;
          w10 = w10 | 0;
          w11 = w11 | 0;
          w12 = w12 | 0;
          w13 = w13 | 0;
          w14 = w14 | 0;
          w15 = w15 | 0;
          var a = 0, b = 0, c = 0, d = 0, e = 0, n = 0, t = 0, w16 = 0, w17 = 0, w18 = 0, w19 = 0, w20 = 0, w21 = 0, w22 = 0, w23 = 0, w24 = 0, w25 = 0, w26 = 0, w27 = 0, w28 = 0, w29 = 0, w30 = 0, w31 = 0, w32 = 0, w33 = 0, w34 = 0, w35 = 0, w36 = 0, w37 = 0, w38 = 0, w39 = 0, w40 = 0, w41 = 0, w42 = 0, w43 = 0, w44 = 0, w45 = 0, w46 = 0, w47 = 0, w48 = 0, w49 = 0, w50 = 0, w51 = 0, w52 = 0, w53 = 0, w54 = 0, w55 = 0, w56 = 0, w57 = 0, w58 = 0, w59 = 0, w60 = 0, w61 = 0, w62 = 0, w63 = 0, w64 = 0, w65 = 0, w66 = 0, w67 = 0, w68 = 0, w69 = 0, w70 = 0, w71 = 0, w72 = 0, w73 = 0, w74 = 0, w75 = 0, w76 = 0, w77 = 0, w78 = 0, w79 = 0;
          a = H0;
          b = H1;
          c = H2;
          d = H3;
          e = H4;
          t = w0 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w1 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w2 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w3 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w4 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w5 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w6 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w7 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w8 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w9 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w10 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w11 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w12 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w13 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w14 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          t = w15 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w13 ^ w8 ^ w2 ^ w0;
          w16 = n << 1 | n >>> 31;
          t = w16 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w14 ^ w9 ^ w3 ^ w1;
          w17 = n << 1 | n >>> 31;
          t = w17 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w15 ^ w10 ^ w4 ^ w2;
          w18 = n << 1 | n >>> 31;
          t = w18 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w16 ^ w11 ^ w5 ^ w3;
          w19 = n << 1 | n >>> 31;
          t = w19 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w17 ^ w12 ^ w6 ^ w4;
          w20 = n << 1 | n >>> 31;
          t = w20 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w18 ^ w13 ^ w7 ^ w5;
          w21 = n << 1 | n >>> 31;
          t = w21 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w19 ^ w14 ^ w8 ^ w6;
          w22 = n << 1 | n >>> 31;
          t = w22 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w20 ^ w15 ^ w9 ^ w7;
          w23 = n << 1 | n >>> 31;
          t = w23 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w21 ^ w16 ^ w10 ^ w8;
          w24 = n << 1 | n >>> 31;
          t = w24 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w22 ^ w17 ^ w11 ^ w9;
          w25 = n << 1 | n >>> 31;
          t = w25 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w23 ^ w18 ^ w12 ^ w10;
          w26 = n << 1 | n >>> 31;
          t = w26 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w24 ^ w19 ^ w13 ^ w11;
          w27 = n << 1 | n >>> 31;
          t = w27 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w25 ^ w20 ^ w14 ^ w12;
          w28 = n << 1 | n >>> 31;
          t = w28 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w26 ^ w21 ^ w15 ^ w13;
          w29 = n << 1 | n >>> 31;
          t = w29 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w27 ^ w22 ^ w16 ^ w14;
          w30 = n << 1 | n >>> 31;
          t = w30 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w28 ^ w23 ^ w17 ^ w15;
          w31 = n << 1 | n >>> 31;
          t = w31 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w29 ^ w24 ^ w18 ^ w16;
          w32 = n << 1 | n >>> 31;
          t = w32 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w30 ^ w25 ^ w19 ^ w17;
          w33 = n << 1 | n >>> 31;
          t = w33 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w31 ^ w26 ^ w20 ^ w18;
          w34 = n << 1 | n >>> 31;
          t = w34 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w32 ^ w27 ^ w21 ^ w19;
          w35 = n << 1 | n >>> 31;
          t = w35 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w33 ^ w28 ^ w22 ^ w20;
          w36 = n << 1 | n >>> 31;
          t = w36 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w34 ^ w29 ^ w23 ^ w21;
          w37 = n << 1 | n >>> 31;
          t = w37 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w35 ^ w30 ^ w24 ^ w22;
          w38 = n << 1 | n >>> 31;
          t = w38 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w36 ^ w31 ^ w25 ^ w23;
          w39 = n << 1 | n >>> 31;
          t = w39 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w37 ^ w32 ^ w26 ^ w24;
          w40 = n << 1 | n >>> 31;
          t = w40 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w38 ^ w33 ^ w27 ^ w25;
          w41 = n << 1 | n >>> 31;
          t = w41 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w39 ^ w34 ^ w28 ^ w26;
          w42 = n << 1 | n >>> 31;
          t = w42 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w40 ^ w35 ^ w29 ^ w27;
          w43 = n << 1 | n >>> 31;
          t = w43 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w41 ^ w36 ^ w30 ^ w28;
          w44 = n << 1 | n >>> 31;
          t = w44 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w42 ^ w37 ^ w31 ^ w29;
          w45 = n << 1 | n >>> 31;
          t = w45 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w43 ^ w38 ^ w32 ^ w30;
          w46 = n << 1 | n >>> 31;
          t = w46 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w44 ^ w39 ^ w33 ^ w31;
          w47 = n << 1 | n >>> 31;
          t = w47 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w45 ^ w40 ^ w34 ^ w32;
          w48 = n << 1 | n >>> 31;
          t = w48 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w46 ^ w41 ^ w35 ^ w33;
          w49 = n << 1 | n >>> 31;
          t = w49 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w47 ^ w42 ^ w36 ^ w34;
          w50 = n << 1 | n >>> 31;
          t = w50 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w48 ^ w43 ^ w37 ^ w35;
          w51 = n << 1 | n >>> 31;
          t = w51 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w49 ^ w44 ^ w38 ^ w36;
          w52 = n << 1 | n >>> 31;
          t = w52 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w50 ^ w45 ^ w39 ^ w37;
          w53 = n << 1 | n >>> 31;
          t = w53 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w51 ^ w46 ^ w40 ^ w38;
          w54 = n << 1 | n >>> 31;
          t = w54 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w52 ^ w47 ^ w41 ^ w39;
          w55 = n << 1 | n >>> 31;
          t = w55 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w53 ^ w48 ^ w42 ^ w40;
          w56 = n << 1 | n >>> 31;
          t = w56 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w54 ^ w49 ^ w43 ^ w41;
          w57 = n << 1 | n >>> 31;
          t = w57 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w55 ^ w50 ^ w44 ^ w42;
          w58 = n << 1 | n >>> 31;
          t = w58 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w56 ^ w51 ^ w45 ^ w43;
          w59 = n << 1 | n >>> 31;
          t = w59 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w57 ^ w52 ^ w46 ^ w44;
          w60 = n << 1 | n >>> 31;
          t = w60 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w58 ^ w53 ^ w47 ^ w45;
          w61 = n << 1 | n >>> 31;
          t = w61 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w59 ^ w54 ^ w48 ^ w46;
          w62 = n << 1 | n >>> 31;
          t = w62 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w60 ^ w55 ^ w49 ^ w47;
          w63 = n << 1 | n >>> 31;
          t = w63 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w61 ^ w56 ^ w50 ^ w48;
          w64 = n << 1 | n >>> 31;
          t = w64 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w62 ^ w57 ^ w51 ^ w49;
          w65 = n << 1 | n >>> 31;
          t = w65 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w63 ^ w58 ^ w52 ^ w50;
          w66 = n << 1 | n >>> 31;
          t = w66 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w64 ^ w59 ^ w53 ^ w51;
          w67 = n << 1 | n >>> 31;
          t = w67 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w65 ^ w60 ^ w54 ^ w52;
          w68 = n << 1 | n >>> 31;
          t = w68 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w66 ^ w61 ^ w55 ^ w53;
          w69 = n << 1 | n >>> 31;
          t = w69 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w67 ^ w62 ^ w56 ^ w54;
          w70 = n << 1 | n >>> 31;
          t = w70 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w68 ^ w63 ^ w57 ^ w55;
          w71 = n << 1 | n >>> 31;
          t = w71 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w69 ^ w64 ^ w58 ^ w56;
          w72 = n << 1 | n >>> 31;
          t = w72 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w70 ^ w65 ^ w59 ^ w57;
          w73 = n << 1 | n >>> 31;
          t = w73 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w71 ^ w66 ^ w60 ^ w58;
          w74 = n << 1 | n >>> 31;
          t = w74 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w72 ^ w67 ^ w61 ^ w59;
          w75 = n << 1 | n >>> 31;
          t = w75 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w73 ^ w68 ^ w62 ^ w60;
          w76 = n << 1 | n >>> 31;
          t = w76 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w74 ^ w69 ^ w63 ^ w61;
          w77 = n << 1 | n >>> 31;
          t = w77 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w75 ^ w70 ^ w64 ^ w62;
          w78 = n << 1 | n >>> 31;
          t = w78 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          n = w76 ^ w71 ^ w65 ^ w63;
          w79 = n << 1 | n >>> 31;
          t = w79 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;
          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
          H0 = H0 + a | 0;
          H1 = H1 + b | 0;
          H2 = H2 + c | 0;
          H3 = H3 + d | 0;
          H4 = H4 + e | 0;
        }
        function _core_heap(offset) {
          offset = offset | 0;
          _core(HEAP[offset | 0] << 24 | HEAP[offset | 1] << 16 | HEAP[offset | 2] << 8 | HEAP[offset | 3], HEAP[offset | 4] << 24 | HEAP[offset | 5] << 16 | HEAP[offset | 6] << 8 | HEAP[offset | 7], HEAP[offset | 8] << 24 | HEAP[offset | 9] << 16 | HEAP[offset | 10] << 8 | HEAP[offset | 11], HEAP[offset | 12] << 24 | HEAP[offset | 13] << 16 | HEAP[offset | 14] << 8 | HEAP[offset | 15], HEAP[offset | 16] << 24 | HEAP[offset | 17] << 16 | HEAP[offset | 18] << 8 | HEAP[offset | 19], HEAP[offset | 20] << 24 | HEAP[offset | 21] << 16 | HEAP[offset | 22] << 8 | HEAP[offset | 23], HEAP[offset | 24] << 24 | HEAP[offset | 25] << 16 | HEAP[offset | 26] << 8 | HEAP[offset | 27], HEAP[offset | 28] << 24 | HEAP[offset | 29] << 16 | HEAP[offset | 30] << 8 | HEAP[offset | 31], HEAP[offset | 32] << 24 | HEAP[offset | 33] << 16 | HEAP[offset | 34] << 8 | HEAP[offset | 35], HEAP[offset | 36] << 24 | HEAP[offset | 37] << 16 | HEAP[offset | 38] << 8 | HEAP[offset | 39], HEAP[offset | 40] << 24 | HEAP[offset | 41] << 16 | HEAP[offset | 42] << 8 | HEAP[offset | 43], HEAP[offset | 44] << 24 | HEAP[offset | 45] << 16 | HEAP[offset | 46] << 8 | HEAP[offset | 47], HEAP[offset | 48] << 24 | HEAP[offset | 49] << 16 | HEAP[offset | 50] << 8 | HEAP[offset | 51], HEAP[offset | 52] << 24 | HEAP[offset | 53] << 16 | HEAP[offset | 54] << 8 | HEAP[offset | 55], HEAP[offset | 56] << 24 | HEAP[offset | 57] << 16 | HEAP[offset | 58] << 8 | HEAP[offset | 59], HEAP[offset | 60] << 24 | HEAP[offset | 61] << 16 | HEAP[offset | 62] << 8 | HEAP[offset | 63]);
        }
        function _state_to_heap(output) {
          output = output | 0;
          HEAP[output | 0] = H0 >>> 24;
          HEAP[output | 1] = H0 >>> 16 & 255;
          HEAP[output | 2] = H0 >>> 8 & 255;
          HEAP[output | 3] = H0 & 255;
          HEAP[output | 4] = H1 >>> 24;
          HEAP[output | 5] = H1 >>> 16 & 255;
          HEAP[output | 6] = H1 >>> 8 & 255;
          HEAP[output | 7] = H1 & 255;
          HEAP[output | 8] = H2 >>> 24;
          HEAP[output | 9] = H2 >>> 16 & 255;
          HEAP[output | 10] = H2 >>> 8 & 255;
          HEAP[output | 11] = H2 & 255;
          HEAP[output | 12] = H3 >>> 24;
          HEAP[output | 13] = H3 >>> 16 & 255;
          HEAP[output | 14] = H3 >>> 8 & 255;
          HEAP[output | 15] = H3 & 255;
          HEAP[output | 16] = H4 >>> 24;
          HEAP[output | 17] = H4 >>> 16 & 255;
          HEAP[output | 18] = H4 >>> 8 & 255;
          HEAP[output | 19] = H4 & 255;
        }
        function reset() {
          H0 = 1732584193;
          H1 = 4023233417;
          H2 = 2562383102;
          H3 = 271733878;
          H4 = 3285377520;
          TOTAL0 = TOTAL1 = 0;
        }
        function init(h0, h1, h2, h3, h4, total0, total1) {
          h0 = h0 | 0;
          h1 = h1 | 0;
          h2 = h2 | 0;
          h3 = h3 | 0;
          h4 = h4 | 0;
          total0 = total0 | 0;
          total1 = total1 | 0;
          H0 = h0;
          H1 = h1;
          H2 = h2;
          H3 = h3;
          H4 = h4;
          TOTAL0 = total0;
          TOTAL1 = total1;
        }
        function process2(offset, length) {
          offset = offset | 0;
          length = length | 0;
          var hashed = 0;
          if (offset & 63)
            return -1;
          while ((length | 0) >= 64) {
            _core_heap(offset);
            offset = offset + 64 | 0;
            length = length - 64 | 0;
            hashed = hashed + 64 | 0;
          }
          TOTAL0 = TOTAL0 + hashed | 0;
          if (TOTAL0 >>> 0 < hashed >>> 0)
            TOTAL1 = TOTAL1 + 1 | 0;
          return hashed | 0;
        }
        function finish(offset, length, output) {
          offset = offset | 0;
          length = length | 0;
          output = output | 0;
          var hashed = 0, i = 0;
          if (offset & 63)
            return -1;
          if (~output) {
            if (output & 31)
              return -1;
          }
          if ((length | 0) >= 64) {
            hashed = process2(offset, length) | 0;
            if ((hashed | 0) == -1)
              return -1;
            offset = offset + hashed | 0;
            length = length - hashed | 0;
          }
          hashed = hashed + length | 0;
          TOTAL0 = TOTAL0 + length | 0;
          if (TOTAL0 >>> 0 < length >>> 0)
            TOTAL1 = TOTAL1 + 1 | 0;
          HEAP[offset | length] = 128;
          if ((length | 0) >= 56) {
            for (i = length + 1 | 0; (i | 0) < 64; i = i + 1 | 0)
              HEAP[offset | i] = 0;
            _core_heap(offset);
            length = 0;
            HEAP[offset | 0] = 0;
          }
          for (i = length + 1 | 0; (i | 0) < 59; i = i + 1 | 0)
            HEAP[offset | i] = 0;
          HEAP[offset | 56] = TOTAL1 >>> 21 & 255;
          HEAP[offset | 57] = TOTAL1 >>> 13 & 255;
          HEAP[offset | 58] = TOTAL1 >>> 5 & 255;
          HEAP[offset | 59] = TOTAL1 << 3 & 255 | TOTAL0 >>> 29;
          HEAP[offset | 60] = TOTAL0 >>> 21 & 255;
          HEAP[offset | 61] = TOTAL0 >>> 13 & 255;
          HEAP[offset | 62] = TOTAL0 >>> 5 & 255;
          HEAP[offset | 63] = TOTAL0 << 3 & 255;
          _core_heap(offset);
          if (~output)
            _state_to_heap(output);
          return hashed | 0;
        }
        function hmac_reset() {
          H0 = I0;
          H1 = I1;
          H2 = I2;
          H3 = I3;
          H4 = I4;
          TOTAL0 = 64;
          TOTAL1 = 0;
        }
        function _hmac_opad() {
          H0 = O0;
          H1 = O1;
          H2 = O2;
          H3 = O3;
          H4 = O4;
          TOTAL0 = 64;
          TOTAL1 = 0;
        }
        function hmac_init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15) {
          p0 = p0 | 0;
          p1 = p1 | 0;
          p2 = p2 | 0;
          p3 = p3 | 0;
          p4 = p4 | 0;
          p5 = p5 | 0;
          p6 = p6 | 0;
          p7 = p7 | 0;
          p8 = p8 | 0;
          p9 = p9 | 0;
          p10 = p10 | 0;
          p11 = p11 | 0;
          p12 = p12 | 0;
          p13 = p13 | 0;
          p14 = p14 | 0;
          p15 = p15 | 0;
          reset();
          _core(p0 ^ 1549556828, p1 ^ 1549556828, p2 ^ 1549556828, p3 ^ 1549556828, p4 ^ 1549556828, p5 ^ 1549556828, p6 ^ 1549556828, p7 ^ 1549556828, p8 ^ 1549556828, p9 ^ 1549556828, p10 ^ 1549556828, p11 ^ 1549556828, p12 ^ 1549556828, p13 ^ 1549556828, p14 ^ 1549556828, p15 ^ 1549556828);
          O0 = H0;
          O1 = H1;
          O2 = H2;
          O3 = H3;
          O4 = H4;
          reset();
          _core(p0 ^ 909522486, p1 ^ 909522486, p2 ^ 909522486, p3 ^ 909522486, p4 ^ 909522486, p5 ^ 909522486, p6 ^ 909522486, p7 ^ 909522486, p8 ^ 909522486, p9 ^ 909522486, p10 ^ 909522486, p11 ^ 909522486, p12 ^ 909522486, p13 ^ 909522486, p14 ^ 909522486, p15 ^ 909522486);
          I0 = H0;
          I1 = H1;
          I2 = H2;
          I3 = H3;
          I4 = H4;
          TOTAL0 = 64;
          TOTAL1 = 0;
        }
        function hmac_finish(offset, length, output) {
          offset = offset | 0;
          length = length | 0;
          output = output | 0;
          var t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, hashed = 0;
          if (offset & 63)
            return -1;
          if (~output) {
            if (output & 31)
              return -1;
          }
          hashed = finish(offset, length, -1) | 0;
          t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4;
          _hmac_opad();
          _core(t0, t1, t2, t3, t4, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
          if (~output)
            _state_to_heap(output);
          return hashed | 0;
        }
        function pbkdf2_generate_block(offset, length, block, count, output) {
          offset = offset | 0;
          length = length | 0;
          block = block | 0;
          count = count | 0;
          output = output | 0;
          var h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0;
          if (offset & 63)
            return -1;
          if (~output) {
            if (output & 31)
              return -1;
          }
          HEAP[offset + length | 0] = block >>> 24;
          HEAP[offset + length + 1 | 0] = block >>> 16 & 255;
          HEAP[offset + length + 2 | 0] = block >>> 8 & 255;
          HEAP[offset + length + 3 | 0] = block & 255;
          hmac_finish(offset, length + 4 | 0, -1) | 0;
          h0 = t0 = H0, h1 = t1 = H1, h2 = t2 = H2, h3 = t3 = H3, h4 = t4 = H4;
          count = count - 1 | 0;
          while ((count | 0) > 0) {
            hmac_reset();
            _core(t0, t1, t2, t3, t4, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
            t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4;
            _hmac_opad();
            _core(t0, t1, t2, t3, t4, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
            t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4;
            h0 = h0 ^ H0;
            h1 = h1 ^ H1;
            h2 = h2 ^ H2;
            h3 = h3 ^ H3;
            h4 = h4 ^ H4;
            count = count - 1 | 0;
          }
          H0 = h0;
          H1 = h1;
          H2 = h2;
          H3 = h3;
          H4 = h4;
          if (~output)
            _state_to_heap(output);
          return 0;
        }
        return {
          reset,
          init,
          process: process2,
          finish,
          hmac_reset,
          hmac_init,
          hmac_finish,
          pbkdf2_generate_block
        };
      };
      var Hash = function() {
        function Hash2() {
          this.pos = 0;
          this.len = 0;
        }
        Hash2.prototype.reset = function() {
          this.result = null;
          this.pos = 0;
          this.len = 0;
          this.asm.reset();
          return this;
        };
        Hash2.prototype.process = function(data) {
          if (this.result !== null)
            throw new IllegalStateError("state must be reset before processing new data");
          var asm = this.asm;
          var heap = this.heap;
          var hpos = this.pos;
          var hlen = this.len;
          var dpos = 0;
          var dlen = data.length;
          var wlen = 0;
          while (dlen > 0) {
            wlen = _heap_write(heap, hpos + hlen, data, dpos, dlen);
            hlen += wlen;
            dpos += wlen;
            dlen -= wlen;
            wlen = asm.process(hpos, hlen);
            hpos += wlen;
            hlen -= wlen;
            if (!hlen)
              hpos = 0;
          }
          this.pos = hpos;
          this.len = hlen;
          return this;
        };
        Hash2.prototype.finish = function() {
          if (this.result !== null)
            throw new IllegalStateError("state must be reset before processing new data");
          this.asm.finish(this.pos, this.len, 0);
          this.result = new Uint8Array(this.HASH_SIZE);
          this.result.set(this.heap.subarray(0, this.HASH_SIZE));
          this.pos = 0;
          this.len = 0;
          return this;
        };
        return Hash2;
      }();
      var __extends$9 = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var _sha1_block_size = 64;
      var _sha1_hash_size = 20;
      var Sha1 = function(_super) {
        __extends$9(Sha12, _super);
        function Sha12() {
          var _this = _super.call(this) || this;
          _this.NAME = "sha1";
          _this.BLOCK_SIZE = _sha1_block_size;
          _this.HASH_SIZE = _sha1_hash_size;
          _this.heap = _heap_init();
          _this.asm = sha1_asm({ Uint8Array }, null, _this.heap.buffer);
          _this.reset();
          return _this;
        }
        Sha12.NAME = "sha1";
        return Sha12;
      }(Hash);
      var sha256_asm = function(stdlib, foreign, buffer) {
        ;
        var H0 = 0, H1 = 0, H2 = 0, H3 = 0, H4 = 0, H5 = 0, H6 = 0, H7 = 0, TOTAL0 = 0, TOTAL1 = 0;
        var I0 = 0, I1 = 0, I2 = 0, I3 = 0, I4 = 0, I5 = 0, I6 = 0, I7 = 0, O0 = 0, O1 = 0, O2 = 0, O3 = 0, O4 = 0, O5 = 0, O6 = 0, O7 = 0;
        var HEAP = new stdlib.Uint8Array(buffer);
        function _core(w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15) {
          w0 = w0 | 0;
          w1 = w1 | 0;
          w2 = w2 | 0;
          w3 = w3 | 0;
          w4 = w4 | 0;
          w5 = w5 | 0;
          w6 = w6 | 0;
          w7 = w7 | 0;
          w8 = w8 | 0;
          w9 = w9 | 0;
          w10 = w10 | 0;
          w11 = w11 | 0;
          w12 = w12 | 0;
          w13 = w13 | 0;
          w14 = w14 | 0;
          w15 = w15 | 0;
          var a = 0, b = 0, c = 0, d = 0, e = 0, f2 = 0, g = 0, h = 0;
          a = H0;
          b = H1;
          c = H2;
          d = H3;
          e = H4;
          f2 = H5;
          g = H6;
          h = H7;
          h = w0 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f2 ^ g)) + 1116352408 | 0;
          d = d + h | 0;
          h = h + (a & b ^ c & (a ^ b)) + (a >>> 2 ^ a >>> 13 ^ a >>> 22 ^ a << 30 ^ a << 19 ^ a << 10) | 0;
          g = w1 + g + (d >>> 6 ^ d >>> 11 ^ d >>> 25 ^ d << 26 ^ d << 21 ^ d << 7) + (f2 ^ d & (e ^ f2)) + 1899447441 | 0;
          c = c + g | 0;
          g = g + (h & a ^ b & (h ^ a)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0;
          f2 = w2 + f2 + (c >>> 6 ^ c >>> 11 ^ c >>> 25 ^ c << 26 ^ c << 21 ^ c << 7) + (e ^ c & (d ^ e)) + 3049323471 | 0;
          b = b + f2 | 0;
          f2 = f2 + (g & h ^ a & (g ^ h)) + (g >>> 2 ^ g >>> 13 ^ g >>> 22 ^ g << 30 ^ g << 19 ^ g << 10) | 0;
          e = w3 + e + (b >>> 6 ^ b >>> 11 ^ b >>> 25 ^ b << 26 ^ b << 21 ^ b << 7) + (d ^ b & (c ^ d)) + 3921009573 | 0;
          a = a + e | 0;
          e = e + (f2 & g ^ h & (f2 ^ g)) + (f2 >>> 2 ^ f2 >>> 13 ^ f2 >>> 22 ^ f2 << 30 ^ f2 << 19 ^ f2 << 10) | 0;
          d = w4 + d + (a >>> 6 ^ a >>> 11 ^ a >>> 25 ^ a << 26 ^ a << 21 ^ a << 7) + (c ^ a & (b ^ c)) + 961987163 | 0;
          h = h + d | 0;
          d = d + (e & f2 ^ g & (e ^ f2)) + (e >>> 2 ^ e >>> 13 ^ e >>> 22 ^ e << 30 ^ e << 19 ^ e << 10) | 0;
          c = w5 + c + (h >>> 6 ^ h >>> 11 ^ h >>> 25 ^ h << 26 ^ h << 21 ^ h << 7) + (b ^ h & (a ^ b)) + 1508970993 | 0;
          g = g + c | 0;
          c = c + (d & e ^ f2 & (d ^ e)) + (d >>> 2 ^ d >>> 13 ^ d >>> 22 ^ d << 30 ^ d << 19 ^ d << 10) | 0;
          b = w6 + b + (g >>> 6 ^ g >>> 11 ^ g >>> 25 ^ g << 26 ^ g << 21 ^ g << 7) + (a ^ g & (h ^ a)) + 2453635748 | 0;
          f2 = f2 + b | 0;
          b = b + (c & d ^ e & (c ^ d)) + (c >>> 2 ^ c >>> 13 ^ c >>> 22 ^ c << 30 ^ c << 19 ^ c << 10) | 0;
          a = w7 + a + (f2 >>> 6 ^ f2 >>> 11 ^ f2 >>> 25 ^ f2 << 26 ^ f2 << 21 ^ f2 << 7) + (h ^ f2 & (g ^ h)) + 2870763221 | 0;
          e = e + a | 0;
          a = a + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0;
          h = w8 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f2 ^ g)) + 3624381080 | 0;
          d = d + h | 0;
          h = h + (a & b ^ c & (a ^ b)) + (a >>> 2 ^ a >>> 13 ^ a >>> 22 ^ a << 30 ^ a << 19 ^ a << 10) | 0;
          g = w9 + g + (d >>> 6 ^ d >>> 11 ^ d >>> 25 ^ d << 26 ^ d << 21 ^ d << 7) + (f2 ^ d & (e ^ f2)) + 310598401 | 0;
          c = c + g | 0;
          g = g + (h & a ^ b & (h ^ a)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0;
          f2 = w10 + f2 + (c >>> 6 ^ c >>> 11 ^ c >>> 25 ^ c << 26 ^ c << 21 ^ c << 7) + (e ^ c & (d ^ e)) + 607225278 | 0;
          b = b + f2 | 0;
          f2 = f2 + (g & h ^ a & (g ^ h)) + (g >>> 2 ^ g >>> 13 ^ g >>> 22 ^ g << 30 ^ g << 19 ^ g << 10) | 0;
          e = w11 + e + (b >>> 6 ^ b >>> 11 ^ b >>> 25 ^ b << 26 ^ b << 21 ^ b << 7) + (d ^ b & (c ^ d)) + 1426881987 | 0;
          a = a + e | 0;
          e = e + (f2 & g ^ h & (f2 ^ g)) + (f2 >>> 2 ^ f2 >>> 13 ^ f2 >>> 22 ^ f2 << 30 ^ f2 << 19 ^ f2 << 10) | 0;
          d = w12 + d + (a >>> 6 ^ a >>> 11 ^ a >>> 25 ^ a << 26 ^ a << 21 ^ a << 7) + (c ^ a & (b ^ c)) + 1925078388 | 0;
          h = h + d | 0;
          d = d + (e & f2 ^ g & (e ^ f2)) + (e >>> 2 ^ e >>> 13 ^ e >>> 22 ^ e << 30 ^ e << 19 ^ e << 10) | 0;
          c = w13 + c + (h >>> 6 ^ h >>> 11 ^ h >>> 25 ^ h << 26 ^ h << 21 ^ h << 7) + (b ^ h & (a ^ b)) + 2162078206 | 0;
          g = g + c | 0;
          c = c + (d & e ^ f2 & (d ^ e)) + (d >>> 2 ^ d >>> 13 ^ d >>> 22 ^ d << 30 ^ d << 19 ^ d << 10) | 0;
          b = w14 + b + (g >>> 6 ^ g >>> 11 ^ g >>> 25 ^ g << 26 ^ g << 21 ^ g << 7) + (a ^ g & (h ^ a)) + 2614888103 | 0;
          f2 = f2 + b | 0;
          b = b + (c & d ^ e & (c ^ d)) + (c >>> 2 ^ c >>> 13 ^ c >>> 22 ^ c << 30 ^ c << 19 ^ c << 10) | 0;
          a = w15 + a + (f2 >>> 6 ^ f2 >>> 11 ^ f2 >>> 25 ^ f2 << 26 ^ f2 << 21 ^ f2 << 7) + (h ^ f2 & (g ^ h)) + 3248222580 | 0;
          e = e + a | 0;
          a = a + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0;
          w0 = (w1 >>> 7 ^ w1 >>> 18 ^ w1 >>> 3 ^ w1 << 25 ^ w1 << 14) + (w14 >>> 17 ^ w14 >>> 19 ^ w14 >>> 10 ^ w14 << 15 ^ w14 << 13) + w0 + w9 | 0;
          h = w0 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f2 ^ g)) + 3835390401 | 0;
          d = d + h | 0;
          h = h + (a & b ^ c & (a ^ b)) + (a >>> 2 ^ a >>> 13 ^ a >>> 22 ^ a << 30 ^ a << 19 ^ a << 10) | 0;
          w1 = (w2 >>> 7 ^ w2 >>> 18 ^ w2 >>> 3 ^ w2 << 25 ^ w2 << 14) + (w15 >>> 17 ^ w15 >>> 19 ^ w15 >>> 10 ^ w15 << 15 ^ w15 << 13) + w1 + w10 | 0;
          g = w1 + g + (d >>> 6 ^ d >>> 11 ^ d >>> 25 ^ d << 26 ^ d << 21 ^ d << 7) + (f2 ^ d & (e ^ f2)) + 4022224774 | 0;
          c = c + g | 0;
          g = g + (h & a ^ b & (h ^ a)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0;
          w2 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (w0 >>> 17 ^ w0 >>> 19 ^ w0 >>> 10 ^ w0 << 15 ^ w0 << 13) + w2 + w11 | 0;
          f2 = w2 + f2 + (c >>> 6 ^ c >>> 11 ^ c >>> 25 ^ c << 26 ^ c << 21 ^ c << 7) + (e ^ c & (d ^ e)) + 264347078 | 0;
          b = b + f2 | 0;
          f2 = f2 + (g & h ^ a & (g ^ h)) + (g >>> 2 ^ g >>> 13 ^ g >>> 22 ^ g << 30 ^ g << 19 ^ g << 10) | 0;
          w3 = (w4 >>> 7 ^ w4 >>> 18 ^ w4 >>> 3 ^ w4 << 25 ^ w4 << 14) + (w1 >>> 17 ^ w1 >>> 19 ^ w1 >>> 10 ^ w1 << 15 ^ w1 << 13) + w3 + w12 | 0;
          e = w3 + e + (b >>> 6 ^ b >>> 11 ^ b >>> 25 ^ b << 26 ^ b << 21 ^ b << 7) + (d ^ b & (c ^ d)) + 604807628 | 0;
          a = a + e | 0;
          e = e + (f2 & g ^ h & (f2 ^ g)) + (f2 >>> 2 ^ f2 >>> 13 ^ f2 >>> 22 ^ f2 << 30 ^ f2 << 19 ^ f2 << 10) | 0;
          w4 = (w5 >>> 7 ^ w5 >>> 18 ^ w5 >>> 3 ^ w5 << 25 ^ w5 << 14) + (w2 >>> 17 ^ w2 >>> 19 ^ w2 >>> 10 ^ w2 << 15 ^ w2 << 13) + w4 + w13 | 0;
          d = w4 + d + (a >>> 6 ^ a >>> 11 ^ a >>> 25 ^ a << 26 ^ a << 21 ^ a << 7) + (c ^ a & (b ^ c)) + 770255983 | 0;
          h = h + d | 0;
          d = d + (e & f2 ^ g & (e ^ f2)) + (e >>> 2 ^ e >>> 13 ^ e >>> 22 ^ e << 30 ^ e << 19 ^ e << 10) | 0;
          w5 = (w6 >>> 7 ^ w6 >>> 18 ^ w6 >>> 3 ^ w6 << 25 ^ w6 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + w5 + w14 | 0;
          c = w5 + c + (h >>> 6 ^ h >>> 11 ^ h >>> 25 ^ h << 26 ^ h << 21 ^ h << 7) + (b ^ h & (a ^ b)) + 1249150122 | 0;
          g = g + c | 0;
          c = c + (d & e ^ f2 & (d ^ e)) + (d >>> 2 ^ d >>> 13 ^ d >>> 22 ^ d << 30 ^ d << 19 ^ d << 10) | 0;
          w6 = (w7 >>> 7 ^ w7 >>> 18 ^ w7 >>> 3 ^ w7 << 25 ^ w7 << 14) + (w4 >>> 17 ^ w4 >>> 19 ^ w4 >>> 10 ^ w4 << 15 ^ w4 << 13) + w6 + w15 | 0;
          b = w6 + b + (g >>> 6 ^ g >>> 11 ^ g >>> 25 ^ g << 26 ^ g << 21 ^ g << 7) + (a ^ g & (h ^ a)) + 1555081692 | 0;
          f2 = f2 + b | 0;
          b = b + (c & d ^ e & (c ^ d)) + (c >>> 2 ^ c >>> 13 ^ c >>> 22 ^ c << 30 ^ c << 19 ^ c << 10) | 0;
          w7 = (w8 >>> 7 ^ w8 >>> 18 ^ w8 >>> 3 ^ w8 << 25 ^ w8 << 14) + (w5 >>> 17 ^ w5 >>> 19 ^ w5 >>> 10 ^ w5 << 15 ^ w5 << 13) + w7 + w0 | 0;
          a = w7 + a + (f2 >>> 6 ^ f2 >>> 11 ^ f2 >>> 25 ^ f2 << 26 ^ f2 << 21 ^ f2 << 7) + (h ^ f2 & (g ^ h)) + 1996064986 | 0;
          e = e + a | 0;
          a = a + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0;
          w8 = (w9 >>> 7 ^ w9 >>> 18 ^ w9 >>> 3 ^ w9 << 25 ^ w9 << 14) + (w6 >>> 17 ^ w6 >>> 19 ^ w6 >>> 10 ^ w6 << 15 ^ w6 << 13) + w8 + w1 | 0;
          h = w8 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f2 ^ g)) + 2554220882 | 0;
          d = d + h | 0;
          h = h + (a & b ^ c & (a ^ b)) + (a >>> 2 ^ a >>> 13 ^ a >>> 22 ^ a << 30 ^ a << 19 ^ a << 10) | 0;
          w9 = (w10 >>> 7 ^ w10 >>> 18 ^ w10 >>> 3 ^ w10 << 25 ^ w10 << 14) + (w7 >>> 17 ^ w7 >>> 19 ^ w7 >>> 10 ^ w7 << 15 ^ w7 << 13) + w9 + w2 | 0;
          g = w9 + g + (d >>> 6 ^ d >>> 11 ^ d >>> 25 ^ d << 26 ^ d << 21 ^ d << 7) + (f2 ^ d & (e ^ f2)) + 2821834349 | 0;
          c = c + g | 0;
          g = g + (h & a ^ b & (h ^ a)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0;
          w10 = (w11 >>> 7 ^ w11 >>> 18 ^ w11 >>> 3 ^ w11 << 25 ^ w11 << 14) + (w8 >>> 17 ^ w8 >>> 19 ^ w8 >>> 10 ^ w8 << 15 ^ w8 << 13) + w10 + w3 | 0;
          f2 = w10 + f2 + (c >>> 6 ^ c >>> 11 ^ c >>> 25 ^ c << 26 ^ c << 21 ^ c << 7) + (e ^ c & (d ^ e)) + 2952996808 | 0;
          b = b + f2 | 0;
          f2 = f2 + (g & h ^ a & (g ^ h)) + (g >>> 2 ^ g >>> 13 ^ g >>> 22 ^ g << 30 ^ g << 19 ^ g << 10) | 0;
          w11 = (w12 >>> 7 ^ w12 >>> 18 ^ w12 >>> 3 ^ w12 << 25 ^ w12 << 14) + (w9 >>> 17 ^ w9 >>> 19 ^ w9 >>> 10 ^ w9 << 15 ^ w9 << 13) + w11 + w4 | 0;
          e = w11 + e + (b >>> 6 ^ b >>> 11 ^ b >>> 25 ^ b << 26 ^ b << 21 ^ b << 7) + (d ^ b & (c ^ d)) + 3210313671 | 0;
          a = a + e | 0;
          e = e + (f2 & g ^ h & (f2 ^ g)) + (f2 >>> 2 ^ f2 >>> 13 ^ f2 >>> 22 ^ f2 << 30 ^ f2 << 19 ^ f2 << 10) | 0;
          w12 = (w13 >>> 7 ^ w13 >>> 18 ^ w13 >>> 3 ^ w13 << 25 ^ w13 << 14) + (w10 >>> 17 ^ w10 >>> 19 ^ w10 >>> 10 ^ w10 << 15 ^ w10 << 13) + w12 + w5 | 0;
          d = w12 + d + (a >>> 6 ^ a >>> 11 ^ a >>> 25 ^ a << 26 ^ a << 21 ^ a << 7) + (c ^ a & (b ^ c)) + 3336571891 | 0;
          h = h + d | 0;
          d = d + (e & f2 ^ g & (e ^ f2)) + (e >>> 2 ^ e >>> 13 ^ e >>> 22 ^ e << 30 ^ e << 19 ^ e << 10) | 0;
          w13 = (w14 >>> 7 ^ w14 >>> 18 ^ w14 >>> 3 ^ w14 << 25 ^ w14 << 14) + (w11 >>> 17 ^ w11 >>> 19 ^ w11 >>> 10 ^ w11 << 15 ^ w11 << 13) + w13 + w6 | 0;
          c = w13 + c + (h >>> 6 ^ h >>> 11 ^ h >>> 25 ^ h << 26 ^ h << 21 ^ h << 7) + (b ^ h & (a ^ b)) + 3584528711 | 0;
          g = g + c | 0;
          c = c + (d & e ^ f2 & (d ^ e)) + (d >>> 2 ^ d >>> 13 ^ d >>> 22 ^ d << 30 ^ d << 19 ^ d << 10) | 0;
          w14 = (w15 >>> 7 ^ w15 >>> 18 ^ w15 >>> 3 ^ w15 << 25 ^ w15 << 14) + (w12 >>> 17 ^ w12 >>> 19 ^ w12 >>> 10 ^ w12 << 15 ^ w12 << 13) + w14 + w7 | 0;
          b = w14 + b + (g >>> 6 ^ g >>> 11 ^ g >>> 25 ^ g << 26 ^ g << 21 ^ g << 7) + (a ^ g & (h ^ a)) + 113926993 | 0;
          f2 = f2 + b | 0;
          b = b + (c & d ^ e & (c ^ d)) + (c >>> 2 ^ c >>> 13 ^ c >>> 22 ^ c << 30 ^ c << 19 ^ c << 10) | 0;
          w15 = (w0 >>> 7 ^ w0 >>> 18 ^ w0 >>> 3 ^ w0 << 25 ^ w0 << 14) + (w13 >>> 17 ^ w13 >>> 19 ^ w13 >>> 10 ^ w13 << 15 ^ w13 << 13) + w15 + w8 | 0;
          a = w15 + a + (f2 >>> 6 ^ f2 >>> 11 ^ f2 >>> 25 ^ f2 << 26 ^ f2 << 21 ^ f2 << 7) + (h ^ f2 & (g ^ h)) + 338241895 | 0;
          e = e + a | 0;
          a = a + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0;
          w0 = (w1 >>> 7 ^ w1 >>> 18 ^ w1 >>> 3 ^ w1 << 25 ^ w1 << 14) + (w14 >>> 17 ^ w14 >>> 19 ^ w14 >>> 10 ^ w14 << 15 ^ w14 << 13) + w0 + w9 | 0;
          h = w0 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f2 ^ g)) + 666307205 | 0;
          d = d + h | 0;
          h = h + (a & b ^ c & (a ^ b)) + (a >>> 2 ^ a >>> 13 ^ a >>> 22 ^ a << 30 ^ a << 19 ^ a << 10) | 0;
          w1 = (w2 >>> 7 ^ w2 >>> 18 ^ w2 >>> 3 ^ w2 << 25 ^ w2 << 14) + (w15 >>> 17 ^ w15 >>> 19 ^ w15 >>> 10 ^ w15 << 15 ^ w15 << 13) + w1 + w10 | 0;
          g = w1 + g + (d >>> 6 ^ d >>> 11 ^ d >>> 25 ^ d << 26 ^ d << 21 ^ d << 7) + (f2 ^ d & (e ^ f2)) + 773529912 | 0;
          c = c + g | 0;
          g = g + (h & a ^ b & (h ^ a)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0;
          w2 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (w0 >>> 17 ^ w0 >>> 19 ^ w0 >>> 10 ^ w0 << 15 ^ w0 << 13) + w2 + w11 | 0;
          f2 = w2 + f2 + (c >>> 6 ^ c >>> 11 ^ c >>> 25 ^ c << 26 ^ c << 21 ^ c << 7) + (e ^ c & (d ^ e)) + 1294757372 | 0;
          b = b + f2 | 0;
          f2 = f2 + (g & h ^ a & (g ^ h)) + (g >>> 2 ^ g >>> 13 ^ g >>> 22 ^ g << 30 ^ g << 19 ^ g << 10) | 0;
          w3 = (w4 >>> 7 ^ w4 >>> 18 ^ w4 >>> 3 ^ w4 << 25 ^ w4 << 14) + (w1 >>> 17 ^ w1 >>> 19 ^ w1 >>> 10 ^ w1 << 15 ^ w1 << 13) + w3 + w12 | 0;
          e = w3 + e + (b >>> 6 ^ b >>> 11 ^ b >>> 25 ^ b << 26 ^ b << 21 ^ b << 7) + (d ^ b & (c ^ d)) + 1396182291 | 0;
          a = a + e | 0;
          e = e + (f2 & g ^ h & (f2 ^ g)) + (f2 >>> 2 ^ f2 >>> 13 ^ f2 >>> 22 ^ f2 << 30 ^ f2 << 19 ^ f2 << 10) | 0;
          w4 = (w5 >>> 7 ^ w5 >>> 18 ^ w5 >>> 3 ^ w5 << 25 ^ w5 << 14) + (w2 >>> 17 ^ w2 >>> 19 ^ w2 >>> 10 ^ w2 << 15 ^ w2 << 13) + w4 + w13 | 0;
          d = w4 + d + (a >>> 6 ^ a >>> 11 ^ a >>> 25 ^ a << 26 ^ a << 21 ^ a << 7) + (c ^ a & (b ^ c)) + 1695183700 | 0;
          h = h + d | 0;
          d = d + (e & f2 ^ g & (e ^ f2)) + (e >>> 2 ^ e >>> 13 ^ e >>> 22 ^ e << 30 ^ e << 19 ^ e << 10) | 0;
          w5 = (w6 >>> 7 ^ w6 >>> 18 ^ w6 >>> 3 ^ w6 << 25 ^ w6 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + w5 + w14 | 0;
          c = w5 + c + (h >>> 6 ^ h >>> 11 ^ h >>> 25 ^ h << 26 ^ h << 21 ^ h << 7) + (b ^ h & (a ^ b)) + 1986661051 | 0;
          g = g + c | 0;
          c = c + (d & e ^ f2 & (d ^ e)) + (d >>> 2 ^ d >>> 13 ^ d >>> 22 ^ d << 30 ^ d << 19 ^ d << 10) | 0;
          w6 = (w7 >>> 7 ^ w7 >>> 18 ^ w7 >>> 3 ^ w7 << 25 ^ w7 << 14) + (w4 >>> 17 ^ w4 >>> 19 ^ w4 >>> 10 ^ w4 << 15 ^ w4 << 13) + w6 + w15 | 0;
          b = w6 + b + (g >>> 6 ^ g >>> 11 ^ g >>> 25 ^ g << 26 ^ g << 21 ^ g << 7) + (a ^ g & (h ^ a)) + 2177026350 | 0;
          f2 = f2 + b | 0;
          b = b + (c & d ^ e & (c ^ d)) + (c >>> 2 ^ c >>> 13 ^ c >>> 22 ^ c << 30 ^ c << 19 ^ c << 10) | 0;
          w7 = (w8 >>> 7 ^ w8 >>> 18 ^ w8 >>> 3 ^ w8 << 25 ^ w8 << 14) + (w5 >>> 17 ^ w5 >>> 19 ^ w5 >>> 10 ^ w5 << 15 ^ w5 << 13) + w7 + w0 | 0;
          a = w7 + a + (f2 >>> 6 ^ f2 >>> 11 ^ f2 >>> 25 ^ f2 << 26 ^ f2 << 21 ^ f2 << 7) + (h ^ f2 & (g ^ h)) + 2456956037 | 0;
          e = e + a | 0;
          a = a + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0;
          w8 = (w9 >>> 7 ^ w9 >>> 18 ^ w9 >>> 3 ^ w9 << 25 ^ w9 << 14) + (w6 >>> 17 ^ w6 >>> 19 ^ w6 >>> 10 ^ w6 << 15 ^ w6 << 13) + w8 + w1 | 0;
          h = w8 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f2 ^ g)) + 2730485921 | 0;
          d = d + h | 0;
          h = h + (a & b ^ c & (a ^ b)) + (a >>> 2 ^ a >>> 13 ^ a >>> 22 ^ a << 30 ^ a << 19 ^ a << 10) | 0;
          w9 = (w10 >>> 7 ^ w10 >>> 18 ^ w10 >>> 3 ^ w10 << 25 ^ w10 << 14) + (w7 >>> 17 ^ w7 >>> 19 ^ w7 >>> 10 ^ w7 << 15 ^ w7 << 13) + w9 + w2 | 0;
          g = w9 + g + (d >>> 6 ^ d >>> 11 ^ d >>> 25 ^ d << 26 ^ d << 21 ^ d << 7) + (f2 ^ d & (e ^ f2)) + 2820302411 | 0;
          c = c + g | 0;
          g = g + (h & a ^ b & (h ^ a)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0;
          w10 = (w11 >>> 7 ^ w11 >>> 18 ^ w11 >>> 3 ^ w11 << 25 ^ w11 << 14) + (w8 >>> 17 ^ w8 >>> 19 ^ w8 >>> 10 ^ w8 << 15 ^ w8 << 13) + w10 + w3 | 0;
          f2 = w10 + f2 + (c >>> 6 ^ c >>> 11 ^ c >>> 25 ^ c << 26 ^ c << 21 ^ c << 7) + (e ^ c & (d ^ e)) + 3259730800 | 0;
          b = b + f2 | 0;
          f2 = f2 + (g & h ^ a & (g ^ h)) + (g >>> 2 ^ g >>> 13 ^ g >>> 22 ^ g << 30 ^ g << 19 ^ g << 10) | 0;
          w11 = (w12 >>> 7 ^ w12 >>> 18 ^ w12 >>> 3 ^ w12 << 25 ^ w12 << 14) + (w9 >>> 17 ^ w9 >>> 19 ^ w9 >>> 10 ^ w9 << 15 ^ w9 << 13) + w11 + w4 | 0;
          e = w11 + e + (b >>> 6 ^ b >>> 11 ^ b >>> 25 ^ b << 26 ^ b << 21 ^ b << 7) + (d ^ b & (c ^ d)) + 3345764771 | 0;
          a = a + e | 0;
          e = e + (f2 & g ^ h & (f2 ^ g)) + (f2 >>> 2 ^ f2 >>> 13 ^ f2 >>> 22 ^ f2 << 30 ^ f2 << 19 ^ f2 << 10) | 0;
          w12 = (w13 >>> 7 ^ w13 >>> 18 ^ w13 >>> 3 ^ w13 << 25 ^ w13 << 14) + (w10 >>> 17 ^ w10 >>> 19 ^ w10 >>> 10 ^ w10 << 15 ^ w10 << 13) + w12 + w5 | 0;
          d = w12 + d + (a >>> 6 ^ a >>> 11 ^ a >>> 25 ^ a << 26 ^ a << 21 ^ a << 7) + (c ^ a & (b ^ c)) + 3516065817 | 0;
          h = h + d | 0;
          d = d + (e & f2 ^ g & (e ^ f2)) + (e >>> 2 ^ e >>> 13 ^ e >>> 22 ^ e << 30 ^ e << 19 ^ e << 10) | 0;
          w13 = (w14 >>> 7 ^ w14 >>> 18 ^ w14 >>> 3 ^ w14 << 25 ^ w14 << 14) + (w11 >>> 17 ^ w11 >>> 19 ^ w11 >>> 10 ^ w11 << 15 ^ w11 << 13) + w13 + w6 | 0;
          c = w13 + c + (h >>> 6 ^ h >>> 11 ^ h >>> 25 ^ h << 26 ^ h << 21 ^ h << 7) + (b ^ h & (a ^ b)) + 3600352804 | 0;
          g = g + c | 0;
          c = c + (d & e ^ f2 & (d ^ e)) + (d >>> 2 ^ d >>> 13 ^ d >>> 22 ^ d << 30 ^ d << 19 ^ d << 10) | 0;
          w14 = (w15 >>> 7 ^ w15 >>> 18 ^ w15 >>> 3 ^ w15 << 25 ^ w15 << 14) + (w12 >>> 17 ^ w12 >>> 19 ^ w12 >>> 10 ^ w12 << 15 ^ w12 << 13) + w14 + w7 | 0;
          b = w14 + b + (g >>> 6 ^ g >>> 11 ^ g >>> 25 ^ g << 26 ^ g << 21 ^ g << 7) + (a ^ g & (h ^ a)) + 4094571909 | 0;
          f2 = f2 + b | 0;
          b = b + (c & d ^ e & (c ^ d)) + (c >>> 2 ^ c >>> 13 ^ c >>> 22 ^ c << 30 ^ c << 19 ^ c << 10) | 0;
          w15 = (w0 >>> 7 ^ w0 >>> 18 ^ w0 >>> 3 ^ w0 << 25 ^ w0 << 14) + (w13 >>> 17 ^ w13 >>> 19 ^ w13 >>> 10 ^ w13 << 15 ^ w13 << 13) + w15 + w8 | 0;
          a = w15 + a + (f2 >>> 6 ^ f2 >>> 11 ^ f2 >>> 25 ^ f2 << 26 ^ f2 << 21 ^ f2 << 7) + (h ^ f2 & (g ^ h)) + 275423344 | 0;
          e = e + a | 0;
          a = a + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0;
          w0 = (w1 >>> 7 ^ w1 >>> 18 ^ w1 >>> 3 ^ w1 << 25 ^ w1 << 14) + (w14 >>> 17 ^ w14 >>> 19 ^ w14 >>> 10 ^ w14 << 15 ^ w14 << 13) + w0 + w9 | 0;
          h = w0 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f2 ^ g)) + 430227734 | 0;
          d = d + h | 0;
          h = h + (a & b ^ c & (a ^ b)) + (a >>> 2 ^ a >>> 13 ^ a >>> 22 ^ a << 30 ^ a << 19 ^ a << 10) | 0;
          w1 = (w2 >>> 7 ^ w2 >>> 18 ^ w2 >>> 3 ^ w2 << 25 ^ w2 << 14) + (w15 >>> 17 ^ w15 >>> 19 ^ w15 >>> 10 ^ w15 << 15 ^ w15 << 13) + w1 + w10 | 0;
          g = w1 + g + (d >>> 6 ^ d >>> 11 ^ d >>> 25 ^ d << 26 ^ d << 21 ^ d << 7) + (f2 ^ d & (e ^ f2)) + 506948616 | 0;
          c = c + g | 0;
          g = g + (h & a ^ b & (h ^ a)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0;
          w2 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (w0 >>> 17 ^ w0 >>> 19 ^ w0 >>> 10 ^ w0 << 15 ^ w0 << 13) + w2 + w11 | 0;
          f2 = w2 + f2 + (c >>> 6 ^ c >>> 11 ^ c >>> 25 ^ c << 26 ^ c << 21 ^ c << 7) + (e ^ c & (d ^ e)) + 659060556 | 0;
          b = b + f2 | 0;
          f2 = f2 + (g & h ^ a & (g ^ h)) + (g >>> 2 ^ g >>> 13 ^ g >>> 22 ^ g << 30 ^ g << 19 ^ g << 10) | 0;
          w3 = (w4 >>> 7 ^ w4 >>> 18 ^ w4 >>> 3 ^ w4 << 25 ^ w4 << 14) + (w1 >>> 17 ^ w1 >>> 19 ^ w1 >>> 10 ^ w1 << 15 ^ w1 << 13) + w3 + w12 | 0;
          e = w3 + e + (b >>> 6 ^ b >>> 11 ^ b >>> 25 ^ b << 26 ^ b << 21 ^ b << 7) + (d ^ b & (c ^ d)) + 883997877 | 0;
          a = a + e | 0;
          e = e + (f2 & g ^ h & (f2 ^ g)) + (f2 >>> 2 ^ f2 >>> 13 ^ f2 >>> 22 ^ f2 << 30 ^ f2 << 19 ^ f2 << 10) | 0;
          w4 = (w5 >>> 7 ^ w5 >>> 18 ^ w5 >>> 3 ^ w5 << 25 ^ w5 << 14) + (w2 >>> 17 ^ w2 >>> 19 ^ w2 >>> 10 ^ w2 << 15 ^ w2 << 13) + w4 + w13 | 0;
          d = w4 + d + (a >>> 6 ^ a >>> 11 ^ a >>> 25 ^ a << 26 ^ a << 21 ^ a << 7) + (c ^ a & (b ^ c)) + 958139571 | 0;
          h = h + d | 0;
          d = d + (e & f2 ^ g & (e ^ f2)) + (e >>> 2 ^ e >>> 13 ^ e >>> 22 ^ e << 30 ^ e << 19 ^ e << 10) | 0;
          w5 = (w6 >>> 7 ^ w6 >>> 18 ^ w6 >>> 3 ^ w6 << 25 ^ w6 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + w5 + w14 | 0;
          c = w5 + c + (h >>> 6 ^ h >>> 11 ^ h >>> 25 ^ h << 26 ^ h << 21 ^ h << 7) + (b ^ h & (a ^ b)) + 1322822218 | 0;
          g = g + c | 0;
          c = c + (d & e ^ f2 & (d ^ e)) + (d >>> 2 ^ d >>> 13 ^ d >>> 22 ^ d << 30 ^ d << 19 ^ d << 10) | 0;
          w6 = (w7 >>> 7 ^ w7 >>> 18 ^ w7 >>> 3 ^ w7 << 25 ^ w7 << 14) + (w4 >>> 17 ^ w4 >>> 19 ^ w4 >>> 10 ^ w4 << 15 ^ w4 << 13) + w6 + w15 | 0;
          b = w6 + b + (g >>> 6 ^ g >>> 11 ^ g >>> 25 ^ g << 26 ^ g << 21 ^ g << 7) + (a ^ g & (h ^ a)) + 1537002063 | 0;
          f2 = f2 + b | 0;
          b = b + (c & d ^ e & (c ^ d)) + (c >>> 2 ^ c >>> 13 ^ c >>> 22 ^ c << 30 ^ c << 19 ^ c << 10) | 0;
          w7 = (w8 >>> 7 ^ w8 >>> 18 ^ w8 >>> 3 ^ w8 << 25 ^ w8 << 14) + (w5 >>> 17 ^ w5 >>> 19 ^ w5 >>> 10 ^ w5 << 15 ^ w5 << 13) + w7 + w0 | 0;
          a = w7 + a + (f2 >>> 6 ^ f2 >>> 11 ^ f2 >>> 25 ^ f2 << 26 ^ f2 << 21 ^ f2 << 7) + (h ^ f2 & (g ^ h)) + 1747873779 | 0;
          e = e + a | 0;
          a = a + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0;
          w8 = (w9 >>> 7 ^ w9 >>> 18 ^ w9 >>> 3 ^ w9 << 25 ^ w9 << 14) + (w6 >>> 17 ^ w6 >>> 19 ^ w6 >>> 10 ^ w6 << 15 ^ w6 << 13) + w8 + w1 | 0;
          h = w8 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f2 ^ g)) + 1955562222 | 0;
          d = d + h | 0;
          h = h + (a & b ^ c & (a ^ b)) + (a >>> 2 ^ a >>> 13 ^ a >>> 22 ^ a << 30 ^ a << 19 ^ a << 10) | 0;
          w9 = (w10 >>> 7 ^ w10 >>> 18 ^ w10 >>> 3 ^ w10 << 25 ^ w10 << 14) + (w7 >>> 17 ^ w7 >>> 19 ^ w7 >>> 10 ^ w7 << 15 ^ w7 << 13) + w9 + w2 | 0;
          g = w9 + g + (d >>> 6 ^ d >>> 11 ^ d >>> 25 ^ d << 26 ^ d << 21 ^ d << 7) + (f2 ^ d & (e ^ f2)) + 2024104815 | 0;
          c = c + g | 0;
          g = g + (h & a ^ b & (h ^ a)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0;
          w10 = (w11 >>> 7 ^ w11 >>> 18 ^ w11 >>> 3 ^ w11 << 25 ^ w11 << 14) + (w8 >>> 17 ^ w8 >>> 19 ^ w8 >>> 10 ^ w8 << 15 ^ w8 << 13) + w10 + w3 | 0;
          f2 = w10 + f2 + (c >>> 6 ^ c >>> 11 ^ c >>> 25 ^ c << 26 ^ c << 21 ^ c << 7) + (e ^ c & (d ^ e)) + 2227730452 | 0;
          b = b + f2 | 0;
          f2 = f2 + (g & h ^ a & (g ^ h)) + (g >>> 2 ^ g >>> 13 ^ g >>> 22 ^ g << 30 ^ g << 19 ^ g << 10) | 0;
          w11 = (w12 >>> 7 ^ w12 >>> 18 ^ w12 >>> 3 ^ w12 << 25 ^ w12 << 14) + (w9 >>> 17 ^ w9 >>> 19 ^ w9 >>> 10 ^ w9 << 15 ^ w9 << 13) + w11 + w4 | 0;
          e = w11 + e + (b >>> 6 ^ b >>> 11 ^ b >>> 25 ^ b << 26 ^ b << 21 ^ b << 7) + (d ^ b & (c ^ d)) + 2361852424 | 0;
          a = a + e | 0;
          e = e + (f2 & g ^ h & (f2 ^ g)) + (f2 >>> 2 ^ f2 >>> 13 ^ f2 >>> 22 ^ f2 << 30 ^ f2 << 19 ^ f2 << 10) | 0;
          w12 = (w13 >>> 7 ^ w13 >>> 18 ^ w13 >>> 3 ^ w13 << 25 ^ w13 << 14) + (w10 >>> 17 ^ w10 >>> 19 ^ w10 >>> 10 ^ w10 << 15 ^ w10 << 13) + w12 + w5 | 0;
          d = w12 + d + (a >>> 6 ^ a >>> 11 ^ a >>> 25 ^ a << 26 ^ a << 21 ^ a << 7) + (c ^ a & (b ^ c)) + 2428436474 | 0;
          h = h + d | 0;
          d = d + (e & f2 ^ g & (e ^ f2)) + (e >>> 2 ^ e >>> 13 ^ e >>> 22 ^ e << 30 ^ e << 19 ^ e << 10) | 0;
          w13 = (w14 >>> 7 ^ w14 >>> 18 ^ w14 >>> 3 ^ w14 << 25 ^ w14 << 14) + (w11 >>> 17 ^ w11 >>> 19 ^ w11 >>> 10 ^ w11 << 15 ^ w11 << 13) + w13 + w6 | 0;
          c = w13 + c + (h >>> 6 ^ h >>> 11 ^ h >>> 25 ^ h << 26 ^ h << 21 ^ h << 7) + (b ^ h & (a ^ b)) + 2756734187 | 0;
          g = g + c | 0;
          c = c + (d & e ^ f2 & (d ^ e)) + (d >>> 2 ^ d >>> 13 ^ d >>> 22 ^ d << 30 ^ d << 19 ^ d << 10) | 0;
          w14 = (w15 >>> 7 ^ w15 >>> 18 ^ w15 >>> 3 ^ w15 << 25 ^ w15 << 14) + (w12 >>> 17 ^ w12 >>> 19 ^ w12 >>> 10 ^ w12 << 15 ^ w12 << 13) + w14 + w7 | 0;
          b = w14 + b + (g >>> 6 ^ g >>> 11 ^ g >>> 25 ^ g << 26 ^ g << 21 ^ g << 7) + (a ^ g & (h ^ a)) + 3204031479 | 0;
          f2 = f2 + b | 0;
          b = b + (c & d ^ e & (c ^ d)) + (c >>> 2 ^ c >>> 13 ^ c >>> 22 ^ c << 30 ^ c << 19 ^ c << 10) | 0;
          w15 = (w0 >>> 7 ^ w0 >>> 18 ^ w0 >>> 3 ^ w0 << 25 ^ w0 << 14) + (w13 >>> 17 ^ w13 >>> 19 ^ w13 >>> 10 ^ w13 << 15 ^ w13 << 13) + w15 + w8 | 0;
          a = w15 + a + (f2 >>> 6 ^ f2 >>> 11 ^ f2 >>> 25 ^ f2 << 26 ^ f2 << 21 ^ f2 << 7) + (h ^ f2 & (g ^ h)) + 3329325298 | 0;
          e = e + a | 0;
          a = a + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0;
          H0 = H0 + a | 0;
          H1 = H1 + b | 0;
          H2 = H2 + c | 0;
          H3 = H3 + d | 0;
          H4 = H4 + e | 0;
          H5 = H5 + f2 | 0;
          H6 = H6 + g | 0;
          H7 = H7 + h | 0;
        }
        function _core_heap(offset) {
          offset = offset | 0;
          _core(HEAP[offset | 0] << 24 | HEAP[offset | 1] << 16 | HEAP[offset | 2] << 8 | HEAP[offset | 3], HEAP[offset | 4] << 24 | HEAP[offset | 5] << 16 | HEAP[offset | 6] << 8 | HEAP[offset | 7], HEAP[offset | 8] << 24 | HEAP[offset | 9] << 16 | HEAP[offset | 10] << 8 | HEAP[offset | 11], HEAP[offset | 12] << 24 | HEAP[offset | 13] << 16 | HEAP[offset | 14] << 8 | HEAP[offset | 15], HEAP[offset | 16] << 24 | HEAP[offset | 17] << 16 | HEAP[offset | 18] << 8 | HEAP[offset | 19], HEAP[offset | 20] << 24 | HEAP[offset | 21] << 16 | HEAP[offset | 22] << 8 | HEAP[offset | 23], HEAP[offset | 24] << 24 | HEAP[offset | 25] << 16 | HEAP[offset | 26] << 8 | HEAP[offset | 27], HEAP[offset | 28] << 24 | HEAP[offset | 29] << 16 | HEAP[offset | 30] << 8 | HEAP[offset | 31], HEAP[offset | 32] << 24 | HEAP[offset | 33] << 16 | HEAP[offset | 34] << 8 | HEAP[offset | 35], HEAP[offset | 36] << 24 | HEAP[offset | 37] << 16 | HEAP[offset | 38] << 8 | HEAP[offset | 39], HEAP[offset | 40] << 24 | HEAP[offset | 41] << 16 | HEAP[offset | 42] << 8 | HEAP[offset | 43], HEAP[offset | 44] << 24 | HEAP[offset | 45] << 16 | HEAP[offset | 46] << 8 | HEAP[offset | 47], HEAP[offset | 48] << 24 | HEAP[offset | 49] << 16 | HEAP[offset | 50] << 8 | HEAP[offset | 51], HEAP[offset | 52] << 24 | HEAP[offset | 53] << 16 | HEAP[offset | 54] << 8 | HEAP[offset | 55], HEAP[offset | 56] << 24 | HEAP[offset | 57] << 16 | HEAP[offset | 58] << 8 | HEAP[offset | 59], HEAP[offset | 60] << 24 | HEAP[offset | 61] << 16 | HEAP[offset | 62] << 8 | HEAP[offset | 63]);
        }
        function _state_to_heap(output) {
          output = output | 0;
          HEAP[output | 0] = H0 >>> 24;
          HEAP[output | 1] = H0 >>> 16 & 255;
          HEAP[output | 2] = H0 >>> 8 & 255;
          HEAP[output | 3] = H0 & 255;
          HEAP[output | 4] = H1 >>> 24;
          HEAP[output | 5] = H1 >>> 16 & 255;
          HEAP[output | 6] = H1 >>> 8 & 255;
          HEAP[output | 7] = H1 & 255;
          HEAP[output | 8] = H2 >>> 24;
          HEAP[output | 9] = H2 >>> 16 & 255;
          HEAP[output | 10] = H2 >>> 8 & 255;
          HEAP[output | 11] = H2 & 255;
          HEAP[output | 12] = H3 >>> 24;
          HEAP[output | 13] = H3 >>> 16 & 255;
          HEAP[output | 14] = H3 >>> 8 & 255;
          HEAP[output | 15] = H3 & 255;
          HEAP[output | 16] = H4 >>> 24;
          HEAP[output | 17] = H4 >>> 16 & 255;
          HEAP[output | 18] = H4 >>> 8 & 255;
          HEAP[output | 19] = H4 & 255;
          HEAP[output | 20] = H5 >>> 24;
          HEAP[output | 21] = H5 >>> 16 & 255;
          HEAP[output | 22] = H5 >>> 8 & 255;
          HEAP[output | 23] = H5 & 255;
          HEAP[output | 24] = H6 >>> 24;
          HEAP[output | 25] = H6 >>> 16 & 255;
          HEAP[output | 26] = H6 >>> 8 & 255;
          HEAP[output | 27] = H6 & 255;
          HEAP[output | 28] = H7 >>> 24;
          HEAP[output | 29] = H7 >>> 16 & 255;
          HEAP[output | 30] = H7 >>> 8 & 255;
          HEAP[output | 31] = H7 & 255;
        }
        function reset() {
          H0 = 1779033703;
          H1 = 3144134277;
          H2 = 1013904242;
          H3 = 2773480762;
          H4 = 1359893119;
          H5 = 2600822924;
          H6 = 528734635;
          H7 = 1541459225;
          TOTAL0 = TOTAL1 = 0;
        }
        function init(h0, h1, h2, h3, h4, h5, h6, h7, total0, total1) {
          h0 = h0 | 0;
          h1 = h1 | 0;
          h2 = h2 | 0;
          h3 = h3 | 0;
          h4 = h4 | 0;
          h5 = h5 | 0;
          h6 = h6 | 0;
          h7 = h7 | 0;
          total0 = total0 | 0;
          total1 = total1 | 0;
          H0 = h0;
          H1 = h1;
          H2 = h2;
          H3 = h3;
          H4 = h4;
          H5 = h5;
          H6 = h6;
          H7 = h7;
          TOTAL0 = total0;
          TOTAL1 = total1;
        }
        function process2(offset, length) {
          offset = offset | 0;
          length = length | 0;
          var hashed = 0;
          if (offset & 63)
            return -1;
          while ((length | 0) >= 64) {
            _core_heap(offset);
            offset = offset + 64 | 0;
            length = length - 64 | 0;
            hashed = hashed + 64 | 0;
          }
          TOTAL0 = TOTAL0 + hashed | 0;
          if (TOTAL0 >>> 0 < hashed >>> 0)
            TOTAL1 = TOTAL1 + 1 | 0;
          return hashed | 0;
        }
        function finish(offset, length, output) {
          offset = offset | 0;
          length = length | 0;
          output = output | 0;
          var hashed = 0, i = 0;
          if (offset & 63)
            return -1;
          if (~output) {
            if (output & 31)
              return -1;
          }
          if ((length | 0) >= 64) {
            hashed = process2(offset, length) | 0;
            if ((hashed | 0) == -1)
              return -1;
            offset = offset + hashed | 0;
            length = length - hashed | 0;
          }
          hashed = hashed + length | 0;
          TOTAL0 = TOTAL0 + length | 0;
          if (TOTAL0 >>> 0 < length >>> 0)
            TOTAL1 = TOTAL1 + 1 | 0;
          HEAP[offset | length] = 128;
          if ((length | 0) >= 56) {
            for (i = length + 1 | 0; (i | 0) < 64; i = i + 1 | 0)
              HEAP[offset | i] = 0;
            _core_heap(offset);
            length = 0;
            HEAP[offset | 0] = 0;
          }
          for (i = length + 1 | 0; (i | 0) < 59; i = i + 1 | 0)
            HEAP[offset | i] = 0;
          HEAP[offset | 56] = TOTAL1 >>> 21 & 255;
          HEAP[offset | 57] = TOTAL1 >>> 13 & 255;
          HEAP[offset | 58] = TOTAL1 >>> 5 & 255;
          HEAP[offset | 59] = TOTAL1 << 3 & 255 | TOTAL0 >>> 29;
          HEAP[offset | 60] = TOTAL0 >>> 21 & 255;
          HEAP[offset | 61] = TOTAL0 >>> 13 & 255;
          HEAP[offset | 62] = TOTAL0 >>> 5 & 255;
          HEAP[offset | 63] = TOTAL0 << 3 & 255;
          _core_heap(offset);
          if (~output)
            _state_to_heap(output);
          return hashed | 0;
        }
        function hmac_reset() {
          H0 = I0;
          H1 = I1;
          H2 = I2;
          H3 = I3;
          H4 = I4;
          H5 = I5;
          H6 = I6;
          H7 = I7;
          TOTAL0 = 64;
          TOTAL1 = 0;
        }
        function _hmac_opad() {
          H0 = O0;
          H1 = O1;
          H2 = O2;
          H3 = O3;
          H4 = O4;
          H5 = O5;
          H6 = O6;
          H7 = O7;
          TOTAL0 = 64;
          TOTAL1 = 0;
        }
        function hmac_init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15) {
          p0 = p0 | 0;
          p1 = p1 | 0;
          p2 = p2 | 0;
          p3 = p3 | 0;
          p4 = p4 | 0;
          p5 = p5 | 0;
          p6 = p6 | 0;
          p7 = p7 | 0;
          p8 = p8 | 0;
          p9 = p9 | 0;
          p10 = p10 | 0;
          p11 = p11 | 0;
          p12 = p12 | 0;
          p13 = p13 | 0;
          p14 = p14 | 0;
          p15 = p15 | 0;
          reset();
          _core(p0 ^ 1549556828, p1 ^ 1549556828, p2 ^ 1549556828, p3 ^ 1549556828, p4 ^ 1549556828, p5 ^ 1549556828, p6 ^ 1549556828, p7 ^ 1549556828, p8 ^ 1549556828, p9 ^ 1549556828, p10 ^ 1549556828, p11 ^ 1549556828, p12 ^ 1549556828, p13 ^ 1549556828, p14 ^ 1549556828, p15 ^ 1549556828);
          O0 = H0;
          O1 = H1;
          O2 = H2;
          O3 = H3;
          O4 = H4;
          O5 = H5;
          O6 = H6;
          O7 = H7;
          reset();
          _core(p0 ^ 909522486, p1 ^ 909522486, p2 ^ 909522486, p3 ^ 909522486, p4 ^ 909522486, p5 ^ 909522486, p6 ^ 909522486, p7 ^ 909522486, p8 ^ 909522486, p9 ^ 909522486, p10 ^ 909522486, p11 ^ 909522486, p12 ^ 909522486, p13 ^ 909522486, p14 ^ 909522486, p15 ^ 909522486);
          I0 = H0;
          I1 = H1;
          I2 = H2;
          I3 = H3;
          I4 = H4;
          I5 = H5;
          I6 = H6;
          I7 = H7;
          TOTAL0 = 64;
          TOTAL1 = 0;
        }
        function hmac_finish(offset, length, output) {
          offset = offset | 0;
          length = length | 0;
          output = output | 0;
          var t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, hashed = 0;
          if (offset & 63)
            return -1;
          if (~output) {
            if (output & 31)
              return -1;
          }
          hashed = finish(offset, length, -1) | 0;
          t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4, t5 = H5, t6 = H6, t7 = H7;
          _hmac_opad();
          _core(t0, t1, t2, t3, t4, t5, t6, t7, 2147483648, 0, 0, 0, 0, 0, 0, 768);
          if (~output)
            _state_to_heap(output);
          return hashed | 0;
        }
        function pbkdf2_generate_block(offset, length, block, count, output) {
          offset = offset | 0;
          length = length | 0;
          block = block | 0;
          count = count | 0;
          output = output | 0;
          var h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, h5 = 0, h6 = 0, h7 = 0, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0;
          if (offset & 63)
            return -1;
          if (~output) {
            if (output & 31)
              return -1;
          }
          HEAP[offset + length | 0] = block >>> 24;
          HEAP[offset + length + 1 | 0] = block >>> 16 & 255;
          HEAP[offset + length + 2 | 0] = block >>> 8 & 255;
          HEAP[offset + length + 3 | 0] = block & 255;
          hmac_finish(offset, length + 4 | 0, -1) | 0;
          h0 = t0 = H0, h1 = t1 = H1, h2 = t2 = H2, h3 = t3 = H3, h4 = t4 = H4, h5 = t5 = H5, h6 = t6 = H6, h7 = t7 = H7;
          count = count - 1 | 0;
          while ((count | 0) > 0) {
            hmac_reset();
            _core(t0, t1, t2, t3, t4, t5, t6, t7, 2147483648, 0, 0, 0, 0, 0, 0, 768);
            t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4, t5 = H5, t6 = H6, t7 = H7;
            _hmac_opad();
            _core(t0, t1, t2, t3, t4, t5, t6, t7, 2147483648, 0, 0, 0, 0, 0, 0, 768);
            t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4, t5 = H5, t6 = H6, t7 = H7;
            h0 = h0 ^ H0;
            h1 = h1 ^ H1;
            h2 = h2 ^ H2;
            h3 = h3 ^ H3;
            h4 = h4 ^ H4;
            h5 = h5 ^ H5;
            h6 = h6 ^ H6;
            h7 = h7 ^ H7;
            count = count - 1 | 0;
          }
          H0 = h0;
          H1 = h1;
          H2 = h2;
          H3 = h3;
          H4 = h4;
          H5 = h5;
          H6 = h6;
          H7 = h7;
          if (~output)
            _state_to_heap(output);
          return 0;
        }
        return {
          reset,
          init,
          process: process2,
          finish,
          hmac_reset,
          hmac_init,
          hmac_finish,
          pbkdf2_generate_block
        };
      };
      var __extends$a = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var _sha256_block_size = 64;
      var _sha256_hash_size = 32;
      var Sha256 = function(_super) {
        __extends$a(Sha2562, _super);
        function Sha2562() {
          var _this = _super.call(this) || this;
          _this.NAME = "sha256";
          _this.BLOCK_SIZE = _sha256_block_size;
          _this.HASH_SIZE = _sha256_hash_size;
          _this.heap = _heap_init();
          _this.asm = sha256_asm({ Uint8Array }, null, _this.heap.buffer);
          _this.reset();
          return _this;
        }
        Sha2562.NAME = "sha256";
        return Sha2562;
      }(Hash);
      var sha512_asm = function(stdlib, foreign, buffer) {
        ;
        var H0h = 0, H0l = 0, H1h = 0, H1l = 0, H2h = 0, H2l = 0, H3h = 0, H3l = 0, H4h = 0, H4l = 0, H5h = 0, H5l = 0, H6h = 0, H6l = 0, H7h = 0, H7l = 0, TOTAL0 = 0, TOTAL1 = 0;
        var I0h = 0, I0l = 0, I1h = 0, I1l = 0, I2h = 0, I2l = 0, I3h = 0, I3l = 0, I4h = 0, I4l = 0, I5h = 0, I5l = 0, I6h = 0, I6l = 0, I7h = 0, I7l = 0, O0h = 0, O0l = 0, O1h = 0, O1l = 0, O2h = 0, O2l = 0, O3h = 0, O3l = 0, O4h = 0, O4l = 0, O5h = 0, O5l = 0, O6h = 0, O6l = 0, O7h = 0, O7l = 0;
        var HEAP = new stdlib.Uint8Array(buffer);
        function _core(w0h, w0l, w1h, w1l, w2h, w2l, w3h, w3l, w4h, w4l, w5h, w5l, w6h, w6l, w7h, w7l, w8h, w8l, w9h, w9l, w10h, w10l, w11h, w11l, w12h, w12l, w13h, w13l, w14h, w14l, w15h, w15l) {
          w0h = w0h | 0;
          w0l = w0l | 0;
          w1h = w1h | 0;
          w1l = w1l | 0;
          w2h = w2h | 0;
          w2l = w2l | 0;
          w3h = w3h | 0;
          w3l = w3l | 0;
          w4h = w4h | 0;
          w4l = w4l | 0;
          w5h = w5h | 0;
          w5l = w5l | 0;
          w6h = w6h | 0;
          w6l = w6l | 0;
          w7h = w7h | 0;
          w7l = w7l | 0;
          w8h = w8h | 0;
          w8l = w8l | 0;
          w9h = w9h | 0;
          w9l = w9l | 0;
          w10h = w10h | 0;
          w10l = w10l | 0;
          w11h = w11h | 0;
          w11l = w11l | 0;
          w12h = w12h | 0;
          w12l = w12l | 0;
          w13h = w13h | 0;
          w13l = w13l | 0;
          w14h = w14h | 0;
          w14l = w14l | 0;
          w15h = w15h | 0;
          w15l = w15l | 0;
          var ah = 0, al = 0, bh = 0, bl = 0, ch = 0, cl = 0, dh = 0, dl = 0, eh = 0, el = 0, fh = 0, fl = 0, gh = 0, gl = 0, hh = 0, hl = 0, th = 0, tl = 0, xl = 0;
          ah = H0h;
          al = H0l;
          bh = H1h;
          bl = H1l;
          ch = H2h;
          cl = H2l;
          dh = H3h;
          dl = H3l;
          eh = H4h;
          el = H4l;
          fh = H5h;
          fl = H5l;
          gh = H6h;
          gl = H6l;
          hh = H7h;
          hl = H7l;
          tl = 3609767458 + w0l | 0;
          th = 1116352408 + w0h + (tl >>> 0 < w0l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 602891725 + w1l | 0;
          th = 1899447441 + w1h + (tl >>> 0 < w1l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3964484399 + w2l | 0;
          th = 3049323471 + w2h + (tl >>> 0 < w2l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2173295548 + w3l | 0;
          th = 3921009573 + w3h + (tl >>> 0 < w3l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 4081628472 + w4l | 0;
          th = 961987163 + w4h + (tl >>> 0 < w4l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3053834265 + w5l | 0;
          th = 1508970993 + w5h + (tl >>> 0 < w5l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2937671579 + w6l | 0;
          th = 2453635748 + w6h + (tl >>> 0 < w6l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3664609560 + w7l | 0;
          th = 2870763221 + w7h + (tl >>> 0 < w7l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2734883394 + w8l | 0;
          th = 3624381080 + w8h + (tl >>> 0 < w8l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1164996542 + w9l | 0;
          th = 310598401 + w9h + (tl >>> 0 < w9l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1323610764 + w10l | 0;
          th = 607225278 + w10h + (tl >>> 0 < w10l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3590304994 + w11l | 0;
          th = 1426881987 + w11h + (tl >>> 0 < w11l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 4068182383 + w12l | 0;
          th = 1925078388 + w12h + (tl >>> 0 < w12l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 991336113 + w13l | 0;
          th = 2162078206 + w13h + (tl >>> 0 < w13l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 633803317 + w14l | 0;
          th = 2614888103 + w14h + (tl >>> 0 < w14l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3479774868 + w15l | 0;
          th = 3248222580 + w15h + (tl >>> 0 < w15l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w0l = w0l + w9l | 0;
          w0h = w0h + w9h + (w0l >>> 0 < w9l >>> 0 ? 1 : 0) | 0;
          xl = (w1l >>> 1 | w1h << 31) ^ (w1l >>> 8 | w1h << 24) ^ (w1l >>> 7 | w1h << 25) | 0;
          w0l = w0l + xl | 0;
          w0h = w0h + ((w1h >>> 1 | w1l << 31) ^ (w1h >>> 8 | w1l << 24) ^ w1h >>> 7) + (w0l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w14l >>> 19 | w14h << 13) ^ (w14l << 3 | w14h >>> 29) ^ (w14l >>> 6 | w14h << 26) | 0;
          w0l = w0l + xl | 0;
          w0h = w0h + ((w14h >>> 19 | w14l << 13) ^ (w14h << 3 | w14l >>> 29) ^ w14h >>> 6) + (w0l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2666613458 + w0l | 0;
          th = 3835390401 + w0h + (tl >>> 0 < w0l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w1l = w1l + w10l | 0;
          w1h = w1h + w10h + (w1l >>> 0 < w10l >>> 0 ? 1 : 0) | 0;
          xl = (w2l >>> 1 | w2h << 31) ^ (w2l >>> 8 | w2h << 24) ^ (w2l >>> 7 | w2h << 25) | 0;
          w1l = w1l + xl | 0;
          w1h = w1h + ((w2h >>> 1 | w2l << 31) ^ (w2h >>> 8 | w2l << 24) ^ w2h >>> 7) + (w1l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w15l >>> 19 | w15h << 13) ^ (w15l << 3 | w15h >>> 29) ^ (w15l >>> 6 | w15h << 26) | 0;
          w1l = w1l + xl | 0;
          w1h = w1h + ((w15h >>> 19 | w15l << 13) ^ (w15h << 3 | w15l >>> 29) ^ w15h >>> 6) + (w1l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 944711139 + w1l | 0;
          th = 4022224774 + w1h + (tl >>> 0 < w1l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w2l = w2l + w11l | 0;
          w2h = w2h + w11h + (w2l >>> 0 < w11l >>> 0 ? 1 : 0) | 0;
          xl = (w3l >>> 1 | w3h << 31) ^ (w3l >>> 8 | w3h << 24) ^ (w3l >>> 7 | w3h << 25) | 0;
          w2l = w2l + xl | 0;
          w2h = w2h + ((w3h >>> 1 | w3l << 31) ^ (w3h >>> 8 | w3l << 24) ^ w3h >>> 7) + (w2l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w0l >>> 19 | w0h << 13) ^ (w0l << 3 | w0h >>> 29) ^ (w0l >>> 6 | w0h << 26) | 0;
          w2l = w2l + xl | 0;
          w2h = w2h + ((w0h >>> 19 | w0l << 13) ^ (w0h << 3 | w0l >>> 29) ^ w0h >>> 6) + (w2l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2341262773 + w2l | 0;
          th = 264347078 + w2h + (tl >>> 0 < w2l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w3l = w3l + w12l | 0;
          w3h = w3h + w12h + (w3l >>> 0 < w12l >>> 0 ? 1 : 0) | 0;
          xl = (w4l >>> 1 | w4h << 31) ^ (w4l >>> 8 | w4h << 24) ^ (w4l >>> 7 | w4h << 25) | 0;
          w3l = w3l + xl | 0;
          w3h = w3h + ((w4h >>> 1 | w4l << 31) ^ (w4h >>> 8 | w4l << 24) ^ w4h >>> 7) + (w3l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w1l >>> 19 | w1h << 13) ^ (w1l << 3 | w1h >>> 29) ^ (w1l >>> 6 | w1h << 26) | 0;
          w3l = w3l + xl | 0;
          w3h = w3h + ((w1h >>> 19 | w1l << 13) ^ (w1h << 3 | w1l >>> 29) ^ w1h >>> 6) + (w3l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2007800933 + w3l | 0;
          th = 604807628 + w3h + (tl >>> 0 < w3l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w4l = w4l + w13l | 0;
          w4h = w4h + w13h + (w4l >>> 0 < w13l >>> 0 ? 1 : 0) | 0;
          xl = (w5l >>> 1 | w5h << 31) ^ (w5l >>> 8 | w5h << 24) ^ (w5l >>> 7 | w5h << 25) | 0;
          w4l = w4l + xl | 0;
          w4h = w4h + ((w5h >>> 1 | w5l << 31) ^ (w5h >>> 8 | w5l << 24) ^ w5h >>> 7) + (w4l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w2l >>> 19 | w2h << 13) ^ (w2l << 3 | w2h >>> 29) ^ (w2l >>> 6 | w2h << 26) | 0;
          w4l = w4l + xl | 0;
          w4h = w4h + ((w2h >>> 19 | w2l << 13) ^ (w2h << 3 | w2l >>> 29) ^ w2h >>> 6) + (w4l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1495990901 + w4l | 0;
          th = 770255983 + w4h + (tl >>> 0 < w4l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w5l = w5l + w14l | 0;
          w5h = w5h + w14h + (w5l >>> 0 < w14l >>> 0 ? 1 : 0) | 0;
          xl = (w6l >>> 1 | w6h << 31) ^ (w6l >>> 8 | w6h << 24) ^ (w6l >>> 7 | w6h << 25) | 0;
          w5l = w5l + xl | 0;
          w5h = w5h + ((w6h >>> 1 | w6l << 31) ^ (w6h >>> 8 | w6l << 24) ^ w6h >>> 7) + (w5l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w3l >>> 19 | w3h << 13) ^ (w3l << 3 | w3h >>> 29) ^ (w3l >>> 6 | w3h << 26) | 0;
          w5l = w5l + xl | 0;
          w5h = w5h + ((w3h >>> 19 | w3l << 13) ^ (w3h << 3 | w3l >>> 29) ^ w3h >>> 6) + (w5l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1856431235 + w5l | 0;
          th = 1249150122 + w5h + (tl >>> 0 < w5l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w6l = w6l + w15l | 0;
          w6h = w6h + w15h + (w6l >>> 0 < w15l >>> 0 ? 1 : 0) | 0;
          xl = (w7l >>> 1 | w7h << 31) ^ (w7l >>> 8 | w7h << 24) ^ (w7l >>> 7 | w7h << 25) | 0;
          w6l = w6l + xl | 0;
          w6h = w6h + ((w7h >>> 1 | w7l << 31) ^ (w7h >>> 8 | w7l << 24) ^ w7h >>> 7) + (w6l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w4l >>> 19 | w4h << 13) ^ (w4l << 3 | w4h >>> 29) ^ (w4l >>> 6 | w4h << 26) | 0;
          w6l = w6l + xl | 0;
          w6h = w6h + ((w4h >>> 19 | w4l << 13) ^ (w4h << 3 | w4l >>> 29) ^ w4h >>> 6) + (w6l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3175218132 + w6l | 0;
          th = 1555081692 + w6h + (tl >>> 0 < w6l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w7l = w7l + w0l | 0;
          w7h = w7h + w0h + (w7l >>> 0 < w0l >>> 0 ? 1 : 0) | 0;
          xl = (w8l >>> 1 | w8h << 31) ^ (w8l >>> 8 | w8h << 24) ^ (w8l >>> 7 | w8h << 25) | 0;
          w7l = w7l + xl | 0;
          w7h = w7h + ((w8h >>> 1 | w8l << 31) ^ (w8h >>> 8 | w8l << 24) ^ w8h >>> 7) + (w7l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w5l >>> 19 | w5h << 13) ^ (w5l << 3 | w5h >>> 29) ^ (w5l >>> 6 | w5h << 26) | 0;
          w7l = w7l + xl | 0;
          w7h = w7h + ((w5h >>> 19 | w5l << 13) ^ (w5h << 3 | w5l >>> 29) ^ w5h >>> 6) + (w7l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2198950837 + w7l | 0;
          th = 1996064986 + w7h + (tl >>> 0 < w7l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w8l = w8l + w1l | 0;
          w8h = w8h + w1h + (w8l >>> 0 < w1l >>> 0 ? 1 : 0) | 0;
          xl = (w9l >>> 1 | w9h << 31) ^ (w9l >>> 8 | w9h << 24) ^ (w9l >>> 7 | w9h << 25) | 0;
          w8l = w8l + xl | 0;
          w8h = w8h + ((w9h >>> 1 | w9l << 31) ^ (w9h >>> 8 | w9l << 24) ^ w9h >>> 7) + (w8l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w6l >>> 19 | w6h << 13) ^ (w6l << 3 | w6h >>> 29) ^ (w6l >>> 6 | w6h << 26) | 0;
          w8l = w8l + xl | 0;
          w8h = w8h + ((w6h >>> 19 | w6l << 13) ^ (w6h << 3 | w6l >>> 29) ^ w6h >>> 6) + (w8l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3999719339 + w8l | 0;
          th = 2554220882 + w8h + (tl >>> 0 < w8l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w9l = w9l + w2l | 0;
          w9h = w9h + w2h + (w9l >>> 0 < w2l >>> 0 ? 1 : 0) | 0;
          xl = (w10l >>> 1 | w10h << 31) ^ (w10l >>> 8 | w10h << 24) ^ (w10l >>> 7 | w10h << 25) | 0;
          w9l = w9l + xl | 0;
          w9h = w9h + ((w10h >>> 1 | w10l << 31) ^ (w10h >>> 8 | w10l << 24) ^ w10h >>> 7) + (w9l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w7l >>> 19 | w7h << 13) ^ (w7l << 3 | w7h >>> 29) ^ (w7l >>> 6 | w7h << 26) | 0;
          w9l = w9l + xl | 0;
          w9h = w9h + ((w7h >>> 19 | w7l << 13) ^ (w7h << 3 | w7l >>> 29) ^ w7h >>> 6) + (w9l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 766784016 + w9l | 0;
          th = 2821834349 + w9h + (tl >>> 0 < w9l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w10l = w10l + w3l | 0;
          w10h = w10h + w3h + (w10l >>> 0 < w3l >>> 0 ? 1 : 0) | 0;
          xl = (w11l >>> 1 | w11h << 31) ^ (w11l >>> 8 | w11h << 24) ^ (w11l >>> 7 | w11h << 25) | 0;
          w10l = w10l + xl | 0;
          w10h = w10h + ((w11h >>> 1 | w11l << 31) ^ (w11h >>> 8 | w11l << 24) ^ w11h >>> 7) + (w10l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w8l >>> 19 | w8h << 13) ^ (w8l << 3 | w8h >>> 29) ^ (w8l >>> 6 | w8h << 26) | 0;
          w10l = w10l + xl | 0;
          w10h = w10h + ((w8h >>> 19 | w8l << 13) ^ (w8h << 3 | w8l >>> 29) ^ w8h >>> 6) + (w10l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2566594879 + w10l | 0;
          th = 2952996808 + w10h + (tl >>> 0 < w10l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w11l = w11l + w4l | 0;
          w11h = w11h + w4h + (w11l >>> 0 < w4l >>> 0 ? 1 : 0) | 0;
          xl = (w12l >>> 1 | w12h << 31) ^ (w12l >>> 8 | w12h << 24) ^ (w12l >>> 7 | w12h << 25) | 0;
          w11l = w11l + xl | 0;
          w11h = w11h + ((w12h >>> 1 | w12l << 31) ^ (w12h >>> 8 | w12l << 24) ^ w12h >>> 7) + (w11l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w9l >>> 19 | w9h << 13) ^ (w9l << 3 | w9h >>> 29) ^ (w9l >>> 6 | w9h << 26) | 0;
          w11l = w11l + xl | 0;
          w11h = w11h + ((w9h >>> 19 | w9l << 13) ^ (w9h << 3 | w9l >>> 29) ^ w9h >>> 6) + (w11l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3203337956 + w11l | 0;
          th = 3210313671 + w11h + (tl >>> 0 < w11l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w12l = w12l + w5l | 0;
          w12h = w12h + w5h + (w12l >>> 0 < w5l >>> 0 ? 1 : 0) | 0;
          xl = (w13l >>> 1 | w13h << 31) ^ (w13l >>> 8 | w13h << 24) ^ (w13l >>> 7 | w13h << 25) | 0;
          w12l = w12l + xl | 0;
          w12h = w12h + ((w13h >>> 1 | w13l << 31) ^ (w13h >>> 8 | w13l << 24) ^ w13h >>> 7) + (w12l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w10l >>> 19 | w10h << 13) ^ (w10l << 3 | w10h >>> 29) ^ (w10l >>> 6 | w10h << 26) | 0;
          w12l = w12l + xl | 0;
          w12h = w12h + ((w10h >>> 19 | w10l << 13) ^ (w10h << 3 | w10l >>> 29) ^ w10h >>> 6) + (w12l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1034457026 + w12l | 0;
          th = 3336571891 + w12h + (tl >>> 0 < w12l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w13l = w13l + w6l | 0;
          w13h = w13h + w6h + (w13l >>> 0 < w6l >>> 0 ? 1 : 0) | 0;
          xl = (w14l >>> 1 | w14h << 31) ^ (w14l >>> 8 | w14h << 24) ^ (w14l >>> 7 | w14h << 25) | 0;
          w13l = w13l + xl | 0;
          w13h = w13h + ((w14h >>> 1 | w14l << 31) ^ (w14h >>> 8 | w14l << 24) ^ w14h >>> 7) + (w13l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w11l >>> 19 | w11h << 13) ^ (w11l << 3 | w11h >>> 29) ^ (w11l >>> 6 | w11h << 26) | 0;
          w13l = w13l + xl | 0;
          w13h = w13h + ((w11h >>> 19 | w11l << 13) ^ (w11h << 3 | w11l >>> 29) ^ w11h >>> 6) + (w13l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2466948901 + w13l | 0;
          th = 3584528711 + w13h + (tl >>> 0 < w13l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w14l = w14l + w7l | 0;
          w14h = w14h + w7h + (w14l >>> 0 < w7l >>> 0 ? 1 : 0) | 0;
          xl = (w15l >>> 1 | w15h << 31) ^ (w15l >>> 8 | w15h << 24) ^ (w15l >>> 7 | w15h << 25) | 0;
          w14l = w14l + xl | 0;
          w14h = w14h + ((w15h >>> 1 | w15l << 31) ^ (w15h >>> 8 | w15l << 24) ^ w15h >>> 7) + (w14l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w12l >>> 19 | w12h << 13) ^ (w12l << 3 | w12h >>> 29) ^ (w12l >>> 6 | w12h << 26) | 0;
          w14l = w14l + xl | 0;
          w14h = w14h + ((w12h >>> 19 | w12l << 13) ^ (w12h << 3 | w12l >>> 29) ^ w12h >>> 6) + (w14l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3758326383 + w14l | 0;
          th = 113926993 + w14h + (tl >>> 0 < w14l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w15l = w15l + w8l | 0;
          w15h = w15h + w8h + (w15l >>> 0 < w8l >>> 0 ? 1 : 0) | 0;
          xl = (w0l >>> 1 | w0h << 31) ^ (w0l >>> 8 | w0h << 24) ^ (w0l >>> 7 | w0h << 25) | 0;
          w15l = w15l + xl | 0;
          w15h = w15h + ((w0h >>> 1 | w0l << 31) ^ (w0h >>> 8 | w0l << 24) ^ w0h >>> 7) + (w15l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w13l >>> 19 | w13h << 13) ^ (w13l << 3 | w13h >>> 29) ^ (w13l >>> 6 | w13h << 26) | 0;
          w15l = w15l + xl | 0;
          w15h = w15h + ((w13h >>> 19 | w13l << 13) ^ (w13h << 3 | w13l >>> 29) ^ w13h >>> 6) + (w15l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 168717936 + w15l | 0;
          th = 338241895 + w15h + (tl >>> 0 < w15l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w0l = w0l + w9l | 0;
          w0h = w0h + w9h + (w0l >>> 0 < w9l >>> 0 ? 1 : 0) | 0;
          xl = (w1l >>> 1 | w1h << 31) ^ (w1l >>> 8 | w1h << 24) ^ (w1l >>> 7 | w1h << 25) | 0;
          w0l = w0l + xl | 0;
          w0h = w0h + ((w1h >>> 1 | w1l << 31) ^ (w1h >>> 8 | w1l << 24) ^ w1h >>> 7) + (w0l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w14l >>> 19 | w14h << 13) ^ (w14l << 3 | w14h >>> 29) ^ (w14l >>> 6 | w14h << 26) | 0;
          w0l = w0l + xl | 0;
          w0h = w0h + ((w14h >>> 19 | w14l << 13) ^ (w14h << 3 | w14l >>> 29) ^ w14h >>> 6) + (w0l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1188179964 + w0l | 0;
          th = 666307205 + w0h + (tl >>> 0 < w0l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w1l = w1l + w10l | 0;
          w1h = w1h + w10h + (w1l >>> 0 < w10l >>> 0 ? 1 : 0) | 0;
          xl = (w2l >>> 1 | w2h << 31) ^ (w2l >>> 8 | w2h << 24) ^ (w2l >>> 7 | w2h << 25) | 0;
          w1l = w1l + xl | 0;
          w1h = w1h + ((w2h >>> 1 | w2l << 31) ^ (w2h >>> 8 | w2l << 24) ^ w2h >>> 7) + (w1l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w15l >>> 19 | w15h << 13) ^ (w15l << 3 | w15h >>> 29) ^ (w15l >>> 6 | w15h << 26) | 0;
          w1l = w1l + xl | 0;
          w1h = w1h + ((w15h >>> 19 | w15l << 13) ^ (w15h << 3 | w15l >>> 29) ^ w15h >>> 6) + (w1l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1546045734 + w1l | 0;
          th = 773529912 + w1h + (tl >>> 0 < w1l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w2l = w2l + w11l | 0;
          w2h = w2h + w11h + (w2l >>> 0 < w11l >>> 0 ? 1 : 0) | 0;
          xl = (w3l >>> 1 | w3h << 31) ^ (w3l >>> 8 | w3h << 24) ^ (w3l >>> 7 | w3h << 25) | 0;
          w2l = w2l + xl | 0;
          w2h = w2h + ((w3h >>> 1 | w3l << 31) ^ (w3h >>> 8 | w3l << 24) ^ w3h >>> 7) + (w2l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w0l >>> 19 | w0h << 13) ^ (w0l << 3 | w0h >>> 29) ^ (w0l >>> 6 | w0h << 26) | 0;
          w2l = w2l + xl | 0;
          w2h = w2h + ((w0h >>> 19 | w0l << 13) ^ (w0h << 3 | w0l >>> 29) ^ w0h >>> 6) + (w2l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1522805485 + w2l | 0;
          th = 1294757372 + w2h + (tl >>> 0 < w2l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w3l = w3l + w12l | 0;
          w3h = w3h + w12h + (w3l >>> 0 < w12l >>> 0 ? 1 : 0) | 0;
          xl = (w4l >>> 1 | w4h << 31) ^ (w4l >>> 8 | w4h << 24) ^ (w4l >>> 7 | w4h << 25) | 0;
          w3l = w3l + xl | 0;
          w3h = w3h + ((w4h >>> 1 | w4l << 31) ^ (w4h >>> 8 | w4l << 24) ^ w4h >>> 7) + (w3l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w1l >>> 19 | w1h << 13) ^ (w1l << 3 | w1h >>> 29) ^ (w1l >>> 6 | w1h << 26) | 0;
          w3l = w3l + xl | 0;
          w3h = w3h + ((w1h >>> 19 | w1l << 13) ^ (w1h << 3 | w1l >>> 29) ^ w1h >>> 6) + (w3l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2643833823 + w3l | 0;
          th = 1396182291 + w3h + (tl >>> 0 < w3l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w4l = w4l + w13l | 0;
          w4h = w4h + w13h + (w4l >>> 0 < w13l >>> 0 ? 1 : 0) | 0;
          xl = (w5l >>> 1 | w5h << 31) ^ (w5l >>> 8 | w5h << 24) ^ (w5l >>> 7 | w5h << 25) | 0;
          w4l = w4l + xl | 0;
          w4h = w4h + ((w5h >>> 1 | w5l << 31) ^ (w5h >>> 8 | w5l << 24) ^ w5h >>> 7) + (w4l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w2l >>> 19 | w2h << 13) ^ (w2l << 3 | w2h >>> 29) ^ (w2l >>> 6 | w2h << 26) | 0;
          w4l = w4l + xl | 0;
          w4h = w4h + ((w2h >>> 19 | w2l << 13) ^ (w2h << 3 | w2l >>> 29) ^ w2h >>> 6) + (w4l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2343527390 + w4l | 0;
          th = 1695183700 + w4h + (tl >>> 0 < w4l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w5l = w5l + w14l | 0;
          w5h = w5h + w14h + (w5l >>> 0 < w14l >>> 0 ? 1 : 0) | 0;
          xl = (w6l >>> 1 | w6h << 31) ^ (w6l >>> 8 | w6h << 24) ^ (w6l >>> 7 | w6h << 25) | 0;
          w5l = w5l + xl | 0;
          w5h = w5h + ((w6h >>> 1 | w6l << 31) ^ (w6h >>> 8 | w6l << 24) ^ w6h >>> 7) + (w5l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w3l >>> 19 | w3h << 13) ^ (w3l << 3 | w3h >>> 29) ^ (w3l >>> 6 | w3h << 26) | 0;
          w5l = w5l + xl | 0;
          w5h = w5h + ((w3h >>> 19 | w3l << 13) ^ (w3h << 3 | w3l >>> 29) ^ w3h >>> 6) + (w5l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1014477480 + w5l | 0;
          th = 1986661051 + w5h + (tl >>> 0 < w5l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w6l = w6l + w15l | 0;
          w6h = w6h + w15h + (w6l >>> 0 < w15l >>> 0 ? 1 : 0) | 0;
          xl = (w7l >>> 1 | w7h << 31) ^ (w7l >>> 8 | w7h << 24) ^ (w7l >>> 7 | w7h << 25) | 0;
          w6l = w6l + xl | 0;
          w6h = w6h + ((w7h >>> 1 | w7l << 31) ^ (w7h >>> 8 | w7l << 24) ^ w7h >>> 7) + (w6l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w4l >>> 19 | w4h << 13) ^ (w4l << 3 | w4h >>> 29) ^ (w4l >>> 6 | w4h << 26) | 0;
          w6l = w6l + xl | 0;
          w6h = w6h + ((w4h >>> 19 | w4l << 13) ^ (w4h << 3 | w4l >>> 29) ^ w4h >>> 6) + (w6l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1206759142 + w6l | 0;
          th = 2177026350 + w6h + (tl >>> 0 < w6l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w7l = w7l + w0l | 0;
          w7h = w7h + w0h + (w7l >>> 0 < w0l >>> 0 ? 1 : 0) | 0;
          xl = (w8l >>> 1 | w8h << 31) ^ (w8l >>> 8 | w8h << 24) ^ (w8l >>> 7 | w8h << 25) | 0;
          w7l = w7l + xl | 0;
          w7h = w7h + ((w8h >>> 1 | w8l << 31) ^ (w8h >>> 8 | w8l << 24) ^ w8h >>> 7) + (w7l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w5l >>> 19 | w5h << 13) ^ (w5l << 3 | w5h >>> 29) ^ (w5l >>> 6 | w5h << 26) | 0;
          w7l = w7l + xl | 0;
          w7h = w7h + ((w5h >>> 19 | w5l << 13) ^ (w5h << 3 | w5l >>> 29) ^ w5h >>> 6) + (w7l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 344077627 + w7l | 0;
          th = 2456956037 + w7h + (tl >>> 0 < w7l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w8l = w8l + w1l | 0;
          w8h = w8h + w1h + (w8l >>> 0 < w1l >>> 0 ? 1 : 0) | 0;
          xl = (w9l >>> 1 | w9h << 31) ^ (w9l >>> 8 | w9h << 24) ^ (w9l >>> 7 | w9h << 25) | 0;
          w8l = w8l + xl | 0;
          w8h = w8h + ((w9h >>> 1 | w9l << 31) ^ (w9h >>> 8 | w9l << 24) ^ w9h >>> 7) + (w8l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w6l >>> 19 | w6h << 13) ^ (w6l << 3 | w6h >>> 29) ^ (w6l >>> 6 | w6h << 26) | 0;
          w8l = w8l + xl | 0;
          w8h = w8h + ((w6h >>> 19 | w6l << 13) ^ (w6h << 3 | w6l >>> 29) ^ w6h >>> 6) + (w8l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1290863460 + w8l | 0;
          th = 2730485921 + w8h + (tl >>> 0 < w8l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w9l = w9l + w2l | 0;
          w9h = w9h + w2h + (w9l >>> 0 < w2l >>> 0 ? 1 : 0) | 0;
          xl = (w10l >>> 1 | w10h << 31) ^ (w10l >>> 8 | w10h << 24) ^ (w10l >>> 7 | w10h << 25) | 0;
          w9l = w9l + xl | 0;
          w9h = w9h + ((w10h >>> 1 | w10l << 31) ^ (w10h >>> 8 | w10l << 24) ^ w10h >>> 7) + (w9l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w7l >>> 19 | w7h << 13) ^ (w7l << 3 | w7h >>> 29) ^ (w7l >>> 6 | w7h << 26) | 0;
          w9l = w9l + xl | 0;
          w9h = w9h + ((w7h >>> 19 | w7l << 13) ^ (w7h << 3 | w7l >>> 29) ^ w7h >>> 6) + (w9l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3158454273 + w9l | 0;
          th = 2820302411 + w9h + (tl >>> 0 < w9l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w10l = w10l + w3l | 0;
          w10h = w10h + w3h + (w10l >>> 0 < w3l >>> 0 ? 1 : 0) | 0;
          xl = (w11l >>> 1 | w11h << 31) ^ (w11l >>> 8 | w11h << 24) ^ (w11l >>> 7 | w11h << 25) | 0;
          w10l = w10l + xl | 0;
          w10h = w10h + ((w11h >>> 1 | w11l << 31) ^ (w11h >>> 8 | w11l << 24) ^ w11h >>> 7) + (w10l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w8l >>> 19 | w8h << 13) ^ (w8l << 3 | w8h >>> 29) ^ (w8l >>> 6 | w8h << 26) | 0;
          w10l = w10l + xl | 0;
          w10h = w10h + ((w8h >>> 19 | w8l << 13) ^ (w8h << 3 | w8l >>> 29) ^ w8h >>> 6) + (w10l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3505952657 + w10l | 0;
          th = 3259730800 + w10h + (tl >>> 0 < w10l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w11l = w11l + w4l | 0;
          w11h = w11h + w4h + (w11l >>> 0 < w4l >>> 0 ? 1 : 0) | 0;
          xl = (w12l >>> 1 | w12h << 31) ^ (w12l >>> 8 | w12h << 24) ^ (w12l >>> 7 | w12h << 25) | 0;
          w11l = w11l + xl | 0;
          w11h = w11h + ((w12h >>> 1 | w12l << 31) ^ (w12h >>> 8 | w12l << 24) ^ w12h >>> 7) + (w11l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w9l >>> 19 | w9h << 13) ^ (w9l << 3 | w9h >>> 29) ^ (w9l >>> 6 | w9h << 26) | 0;
          w11l = w11l + xl | 0;
          w11h = w11h + ((w9h >>> 19 | w9l << 13) ^ (w9h << 3 | w9l >>> 29) ^ w9h >>> 6) + (w11l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 106217008 + w11l | 0;
          th = 3345764771 + w11h + (tl >>> 0 < w11l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w12l = w12l + w5l | 0;
          w12h = w12h + w5h + (w12l >>> 0 < w5l >>> 0 ? 1 : 0) | 0;
          xl = (w13l >>> 1 | w13h << 31) ^ (w13l >>> 8 | w13h << 24) ^ (w13l >>> 7 | w13h << 25) | 0;
          w12l = w12l + xl | 0;
          w12h = w12h + ((w13h >>> 1 | w13l << 31) ^ (w13h >>> 8 | w13l << 24) ^ w13h >>> 7) + (w12l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w10l >>> 19 | w10h << 13) ^ (w10l << 3 | w10h >>> 29) ^ (w10l >>> 6 | w10h << 26) | 0;
          w12l = w12l + xl | 0;
          w12h = w12h + ((w10h >>> 19 | w10l << 13) ^ (w10h << 3 | w10l >>> 29) ^ w10h >>> 6) + (w12l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3606008344 + w12l | 0;
          th = 3516065817 + w12h + (tl >>> 0 < w12l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w13l = w13l + w6l | 0;
          w13h = w13h + w6h + (w13l >>> 0 < w6l >>> 0 ? 1 : 0) | 0;
          xl = (w14l >>> 1 | w14h << 31) ^ (w14l >>> 8 | w14h << 24) ^ (w14l >>> 7 | w14h << 25) | 0;
          w13l = w13l + xl | 0;
          w13h = w13h + ((w14h >>> 1 | w14l << 31) ^ (w14h >>> 8 | w14l << 24) ^ w14h >>> 7) + (w13l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w11l >>> 19 | w11h << 13) ^ (w11l << 3 | w11h >>> 29) ^ (w11l >>> 6 | w11h << 26) | 0;
          w13l = w13l + xl | 0;
          w13h = w13h + ((w11h >>> 19 | w11l << 13) ^ (w11h << 3 | w11l >>> 29) ^ w11h >>> 6) + (w13l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1432725776 + w13l | 0;
          th = 3600352804 + w13h + (tl >>> 0 < w13l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w14l = w14l + w7l | 0;
          w14h = w14h + w7h + (w14l >>> 0 < w7l >>> 0 ? 1 : 0) | 0;
          xl = (w15l >>> 1 | w15h << 31) ^ (w15l >>> 8 | w15h << 24) ^ (w15l >>> 7 | w15h << 25) | 0;
          w14l = w14l + xl | 0;
          w14h = w14h + ((w15h >>> 1 | w15l << 31) ^ (w15h >>> 8 | w15l << 24) ^ w15h >>> 7) + (w14l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w12l >>> 19 | w12h << 13) ^ (w12l << 3 | w12h >>> 29) ^ (w12l >>> 6 | w12h << 26) | 0;
          w14l = w14l + xl | 0;
          w14h = w14h + ((w12h >>> 19 | w12l << 13) ^ (w12h << 3 | w12l >>> 29) ^ w12h >>> 6) + (w14l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1467031594 + w14l | 0;
          th = 4094571909 + w14h + (tl >>> 0 < w14l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w15l = w15l + w8l | 0;
          w15h = w15h + w8h + (w15l >>> 0 < w8l >>> 0 ? 1 : 0) | 0;
          xl = (w0l >>> 1 | w0h << 31) ^ (w0l >>> 8 | w0h << 24) ^ (w0l >>> 7 | w0h << 25) | 0;
          w15l = w15l + xl | 0;
          w15h = w15h + ((w0h >>> 1 | w0l << 31) ^ (w0h >>> 8 | w0l << 24) ^ w0h >>> 7) + (w15l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w13l >>> 19 | w13h << 13) ^ (w13l << 3 | w13h >>> 29) ^ (w13l >>> 6 | w13h << 26) | 0;
          w15l = w15l + xl | 0;
          w15h = w15h + ((w13h >>> 19 | w13l << 13) ^ (w13h << 3 | w13l >>> 29) ^ w13h >>> 6) + (w15l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 851169720 + w15l | 0;
          th = 275423344 + w15h + (tl >>> 0 < w15l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w0l = w0l + w9l | 0;
          w0h = w0h + w9h + (w0l >>> 0 < w9l >>> 0 ? 1 : 0) | 0;
          xl = (w1l >>> 1 | w1h << 31) ^ (w1l >>> 8 | w1h << 24) ^ (w1l >>> 7 | w1h << 25) | 0;
          w0l = w0l + xl | 0;
          w0h = w0h + ((w1h >>> 1 | w1l << 31) ^ (w1h >>> 8 | w1l << 24) ^ w1h >>> 7) + (w0l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w14l >>> 19 | w14h << 13) ^ (w14l << 3 | w14h >>> 29) ^ (w14l >>> 6 | w14h << 26) | 0;
          w0l = w0l + xl | 0;
          w0h = w0h + ((w14h >>> 19 | w14l << 13) ^ (w14h << 3 | w14l >>> 29) ^ w14h >>> 6) + (w0l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3100823752 + w0l | 0;
          th = 430227734 + w0h + (tl >>> 0 < w0l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w1l = w1l + w10l | 0;
          w1h = w1h + w10h + (w1l >>> 0 < w10l >>> 0 ? 1 : 0) | 0;
          xl = (w2l >>> 1 | w2h << 31) ^ (w2l >>> 8 | w2h << 24) ^ (w2l >>> 7 | w2h << 25) | 0;
          w1l = w1l + xl | 0;
          w1h = w1h + ((w2h >>> 1 | w2l << 31) ^ (w2h >>> 8 | w2l << 24) ^ w2h >>> 7) + (w1l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w15l >>> 19 | w15h << 13) ^ (w15l << 3 | w15h >>> 29) ^ (w15l >>> 6 | w15h << 26) | 0;
          w1l = w1l + xl | 0;
          w1h = w1h + ((w15h >>> 19 | w15l << 13) ^ (w15h << 3 | w15l >>> 29) ^ w15h >>> 6) + (w1l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1363258195 + w1l | 0;
          th = 506948616 + w1h + (tl >>> 0 < w1l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w2l = w2l + w11l | 0;
          w2h = w2h + w11h + (w2l >>> 0 < w11l >>> 0 ? 1 : 0) | 0;
          xl = (w3l >>> 1 | w3h << 31) ^ (w3l >>> 8 | w3h << 24) ^ (w3l >>> 7 | w3h << 25) | 0;
          w2l = w2l + xl | 0;
          w2h = w2h + ((w3h >>> 1 | w3l << 31) ^ (w3h >>> 8 | w3l << 24) ^ w3h >>> 7) + (w2l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w0l >>> 19 | w0h << 13) ^ (w0l << 3 | w0h >>> 29) ^ (w0l >>> 6 | w0h << 26) | 0;
          w2l = w2l + xl | 0;
          w2h = w2h + ((w0h >>> 19 | w0l << 13) ^ (w0h << 3 | w0l >>> 29) ^ w0h >>> 6) + (w2l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3750685593 + w2l | 0;
          th = 659060556 + w2h + (tl >>> 0 < w2l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w3l = w3l + w12l | 0;
          w3h = w3h + w12h + (w3l >>> 0 < w12l >>> 0 ? 1 : 0) | 0;
          xl = (w4l >>> 1 | w4h << 31) ^ (w4l >>> 8 | w4h << 24) ^ (w4l >>> 7 | w4h << 25) | 0;
          w3l = w3l + xl | 0;
          w3h = w3h + ((w4h >>> 1 | w4l << 31) ^ (w4h >>> 8 | w4l << 24) ^ w4h >>> 7) + (w3l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w1l >>> 19 | w1h << 13) ^ (w1l << 3 | w1h >>> 29) ^ (w1l >>> 6 | w1h << 26) | 0;
          w3l = w3l + xl | 0;
          w3h = w3h + ((w1h >>> 19 | w1l << 13) ^ (w1h << 3 | w1l >>> 29) ^ w1h >>> 6) + (w3l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3785050280 + w3l | 0;
          th = 883997877 + w3h + (tl >>> 0 < w3l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w4l = w4l + w13l | 0;
          w4h = w4h + w13h + (w4l >>> 0 < w13l >>> 0 ? 1 : 0) | 0;
          xl = (w5l >>> 1 | w5h << 31) ^ (w5l >>> 8 | w5h << 24) ^ (w5l >>> 7 | w5h << 25) | 0;
          w4l = w4l + xl | 0;
          w4h = w4h + ((w5h >>> 1 | w5l << 31) ^ (w5h >>> 8 | w5l << 24) ^ w5h >>> 7) + (w4l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w2l >>> 19 | w2h << 13) ^ (w2l << 3 | w2h >>> 29) ^ (w2l >>> 6 | w2h << 26) | 0;
          w4l = w4l + xl | 0;
          w4h = w4h + ((w2h >>> 19 | w2l << 13) ^ (w2h << 3 | w2l >>> 29) ^ w2h >>> 6) + (w4l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3318307427 + w4l | 0;
          th = 958139571 + w4h + (tl >>> 0 < w4l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w5l = w5l + w14l | 0;
          w5h = w5h + w14h + (w5l >>> 0 < w14l >>> 0 ? 1 : 0) | 0;
          xl = (w6l >>> 1 | w6h << 31) ^ (w6l >>> 8 | w6h << 24) ^ (w6l >>> 7 | w6h << 25) | 0;
          w5l = w5l + xl | 0;
          w5h = w5h + ((w6h >>> 1 | w6l << 31) ^ (w6h >>> 8 | w6l << 24) ^ w6h >>> 7) + (w5l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w3l >>> 19 | w3h << 13) ^ (w3l << 3 | w3h >>> 29) ^ (w3l >>> 6 | w3h << 26) | 0;
          w5l = w5l + xl | 0;
          w5h = w5h + ((w3h >>> 19 | w3l << 13) ^ (w3h << 3 | w3l >>> 29) ^ w3h >>> 6) + (w5l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3812723403 + w5l | 0;
          th = 1322822218 + w5h + (tl >>> 0 < w5l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w6l = w6l + w15l | 0;
          w6h = w6h + w15h + (w6l >>> 0 < w15l >>> 0 ? 1 : 0) | 0;
          xl = (w7l >>> 1 | w7h << 31) ^ (w7l >>> 8 | w7h << 24) ^ (w7l >>> 7 | w7h << 25) | 0;
          w6l = w6l + xl | 0;
          w6h = w6h + ((w7h >>> 1 | w7l << 31) ^ (w7h >>> 8 | w7l << 24) ^ w7h >>> 7) + (w6l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w4l >>> 19 | w4h << 13) ^ (w4l << 3 | w4h >>> 29) ^ (w4l >>> 6 | w4h << 26) | 0;
          w6l = w6l + xl | 0;
          w6h = w6h + ((w4h >>> 19 | w4l << 13) ^ (w4h << 3 | w4l >>> 29) ^ w4h >>> 6) + (w6l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2003034995 + w6l | 0;
          th = 1537002063 + w6h + (tl >>> 0 < w6l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w7l = w7l + w0l | 0;
          w7h = w7h + w0h + (w7l >>> 0 < w0l >>> 0 ? 1 : 0) | 0;
          xl = (w8l >>> 1 | w8h << 31) ^ (w8l >>> 8 | w8h << 24) ^ (w8l >>> 7 | w8h << 25) | 0;
          w7l = w7l + xl | 0;
          w7h = w7h + ((w8h >>> 1 | w8l << 31) ^ (w8h >>> 8 | w8l << 24) ^ w8h >>> 7) + (w7l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w5l >>> 19 | w5h << 13) ^ (w5l << 3 | w5h >>> 29) ^ (w5l >>> 6 | w5h << 26) | 0;
          w7l = w7l + xl | 0;
          w7h = w7h + ((w5h >>> 19 | w5l << 13) ^ (w5h << 3 | w5l >>> 29) ^ w5h >>> 6) + (w7l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3602036899 + w7l | 0;
          th = 1747873779 + w7h + (tl >>> 0 < w7l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w8l = w8l + w1l | 0;
          w8h = w8h + w1h + (w8l >>> 0 < w1l >>> 0 ? 1 : 0) | 0;
          xl = (w9l >>> 1 | w9h << 31) ^ (w9l >>> 8 | w9h << 24) ^ (w9l >>> 7 | w9h << 25) | 0;
          w8l = w8l + xl | 0;
          w8h = w8h + ((w9h >>> 1 | w9l << 31) ^ (w9h >>> 8 | w9l << 24) ^ w9h >>> 7) + (w8l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w6l >>> 19 | w6h << 13) ^ (w6l << 3 | w6h >>> 29) ^ (w6l >>> 6 | w6h << 26) | 0;
          w8l = w8l + xl | 0;
          w8h = w8h + ((w6h >>> 19 | w6l << 13) ^ (w6h << 3 | w6l >>> 29) ^ w6h >>> 6) + (w8l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1575990012 + w8l | 0;
          th = 1955562222 + w8h + (tl >>> 0 < w8l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w9l = w9l + w2l | 0;
          w9h = w9h + w2h + (w9l >>> 0 < w2l >>> 0 ? 1 : 0) | 0;
          xl = (w10l >>> 1 | w10h << 31) ^ (w10l >>> 8 | w10h << 24) ^ (w10l >>> 7 | w10h << 25) | 0;
          w9l = w9l + xl | 0;
          w9h = w9h + ((w10h >>> 1 | w10l << 31) ^ (w10h >>> 8 | w10l << 24) ^ w10h >>> 7) + (w9l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w7l >>> 19 | w7h << 13) ^ (w7l << 3 | w7h >>> 29) ^ (w7l >>> 6 | w7h << 26) | 0;
          w9l = w9l + xl | 0;
          w9h = w9h + ((w7h >>> 19 | w7l << 13) ^ (w7h << 3 | w7l >>> 29) ^ w7h >>> 6) + (w9l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1125592928 + w9l | 0;
          th = 2024104815 + w9h + (tl >>> 0 < w9l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w10l = w10l + w3l | 0;
          w10h = w10h + w3h + (w10l >>> 0 < w3l >>> 0 ? 1 : 0) | 0;
          xl = (w11l >>> 1 | w11h << 31) ^ (w11l >>> 8 | w11h << 24) ^ (w11l >>> 7 | w11h << 25) | 0;
          w10l = w10l + xl | 0;
          w10h = w10h + ((w11h >>> 1 | w11l << 31) ^ (w11h >>> 8 | w11l << 24) ^ w11h >>> 7) + (w10l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w8l >>> 19 | w8h << 13) ^ (w8l << 3 | w8h >>> 29) ^ (w8l >>> 6 | w8h << 26) | 0;
          w10l = w10l + xl | 0;
          w10h = w10h + ((w8h >>> 19 | w8l << 13) ^ (w8h << 3 | w8l >>> 29) ^ w8h >>> 6) + (w10l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2716904306 + w10l | 0;
          th = 2227730452 + w10h + (tl >>> 0 < w10l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w11l = w11l + w4l | 0;
          w11h = w11h + w4h + (w11l >>> 0 < w4l >>> 0 ? 1 : 0) | 0;
          xl = (w12l >>> 1 | w12h << 31) ^ (w12l >>> 8 | w12h << 24) ^ (w12l >>> 7 | w12h << 25) | 0;
          w11l = w11l + xl | 0;
          w11h = w11h + ((w12h >>> 1 | w12l << 31) ^ (w12h >>> 8 | w12l << 24) ^ w12h >>> 7) + (w11l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w9l >>> 19 | w9h << 13) ^ (w9l << 3 | w9h >>> 29) ^ (w9l >>> 6 | w9h << 26) | 0;
          w11l = w11l + xl | 0;
          w11h = w11h + ((w9h >>> 19 | w9l << 13) ^ (w9h << 3 | w9l >>> 29) ^ w9h >>> 6) + (w11l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 442776044 + w11l | 0;
          th = 2361852424 + w11h + (tl >>> 0 < w11l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w12l = w12l + w5l | 0;
          w12h = w12h + w5h + (w12l >>> 0 < w5l >>> 0 ? 1 : 0) | 0;
          xl = (w13l >>> 1 | w13h << 31) ^ (w13l >>> 8 | w13h << 24) ^ (w13l >>> 7 | w13h << 25) | 0;
          w12l = w12l + xl | 0;
          w12h = w12h + ((w13h >>> 1 | w13l << 31) ^ (w13h >>> 8 | w13l << 24) ^ w13h >>> 7) + (w12l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w10l >>> 19 | w10h << 13) ^ (w10l << 3 | w10h >>> 29) ^ (w10l >>> 6 | w10h << 26) | 0;
          w12l = w12l + xl | 0;
          w12h = w12h + ((w10h >>> 19 | w10l << 13) ^ (w10h << 3 | w10l >>> 29) ^ w10h >>> 6) + (w12l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 593698344 + w12l | 0;
          th = 2428436474 + w12h + (tl >>> 0 < w12l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w13l = w13l + w6l | 0;
          w13h = w13h + w6h + (w13l >>> 0 < w6l >>> 0 ? 1 : 0) | 0;
          xl = (w14l >>> 1 | w14h << 31) ^ (w14l >>> 8 | w14h << 24) ^ (w14l >>> 7 | w14h << 25) | 0;
          w13l = w13l + xl | 0;
          w13h = w13h + ((w14h >>> 1 | w14l << 31) ^ (w14h >>> 8 | w14l << 24) ^ w14h >>> 7) + (w13l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w11l >>> 19 | w11h << 13) ^ (w11l << 3 | w11h >>> 29) ^ (w11l >>> 6 | w11h << 26) | 0;
          w13l = w13l + xl | 0;
          w13h = w13h + ((w11h >>> 19 | w11l << 13) ^ (w11h << 3 | w11l >>> 29) ^ w11h >>> 6) + (w13l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3733110249 + w13l | 0;
          th = 2756734187 + w13h + (tl >>> 0 < w13l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w14l = w14l + w7l | 0;
          w14h = w14h + w7h + (w14l >>> 0 < w7l >>> 0 ? 1 : 0) | 0;
          xl = (w15l >>> 1 | w15h << 31) ^ (w15l >>> 8 | w15h << 24) ^ (w15l >>> 7 | w15h << 25) | 0;
          w14l = w14l + xl | 0;
          w14h = w14h + ((w15h >>> 1 | w15l << 31) ^ (w15h >>> 8 | w15l << 24) ^ w15h >>> 7) + (w14l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w12l >>> 19 | w12h << 13) ^ (w12l << 3 | w12h >>> 29) ^ (w12l >>> 6 | w12h << 26) | 0;
          w14l = w14l + xl | 0;
          w14h = w14h + ((w12h >>> 19 | w12l << 13) ^ (w12h << 3 | w12l >>> 29) ^ w12h >>> 6) + (w14l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2999351573 + w14l | 0;
          th = 3204031479 + w14h + (tl >>> 0 < w14l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w15l = w15l + w8l | 0;
          w15h = w15h + w8h + (w15l >>> 0 < w8l >>> 0 ? 1 : 0) | 0;
          xl = (w0l >>> 1 | w0h << 31) ^ (w0l >>> 8 | w0h << 24) ^ (w0l >>> 7 | w0h << 25) | 0;
          w15l = w15l + xl | 0;
          w15h = w15h + ((w0h >>> 1 | w0l << 31) ^ (w0h >>> 8 | w0l << 24) ^ w0h >>> 7) + (w15l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w13l >>> 19 | w13h << 13) ^ (w13l << 3 | w13h >>> 29) ^ (w13l >>> 6 | w13h << 26) | 0;
          w15l = w15l + xl | 0;
          w15h = w15h + ((w13h >>> 19 | w13l << 13) ^ (w13h << 3 | w13l >>> 29) ^ w13h >>> 6) + (w15l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3815920427 + w15l | 0;
          th = 3329325298 + w15h + (tl >>> 0 < w15l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w0l = w0l + w9l | 0;
          w0h = w0h + w9h + (w0l >>> 0 < w9l >>> 0 ? 1 : 0) | 0;
          xl = (w1l >>> 1 | w1h << 31) ^ (w1l >>> 8 | w1h << 24) ^ (w1l >>> 7 | w1h << 25) | 0;
          w0l = w0l + xl | 0;
          w0h = w0h + ((w1h >>> 1 | w1l << 31) ^ (w1h >>> 8 | w1l << 24) ^ w1h >>> 7) + (w0l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w14l >>> 19 | w14h << 13) ^ (w14l << 3 | w14h >>> 29) ^ (w14l >>> 6 | w14h << 26) | 0;
          w0l = w0l + xl | 0;
          w0h = w0h + ((w14h >>> 19 | w14l << 13) ^ (w14h << 3 | w14l >>> 29) ^ w14h >>> 6) + (w0l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3928383900 + w0l | 0;
          th = 3391569614 + w0h + (tl >>> 0 < w0l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w1l = w1l + w10l | 0;
          w1h = w1h + w10h + (w1l >>> 0 < w10l >>> 0 ? 1 : 0) | 0;
          xl = (w2l >>> 1 | w2h << 31) ^ (w2l >>> 8 | w2h << 24) ^ (w2l >>> 7 | w2h << 25) | 0;
          w1l = w1l + xl | 0;
          w1h = w1h + ((w2h >>> 1 | w2l << 31) ^ (w2h >>> 8 | w2l << 24) ^ w2h >>> 7) + (w1l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w15l >>> 19 | w15h << 13) ^ (w15l << 3 | w15h >>> 29) ^ (w15l >>> 6 | w15h << 26) | 0;
          w1l = w1l + xl | 0;
          w1h = w1h + ((w15h >>> 19 | w15l << 13) ^ (w15h << 3 | w15l >>> 29) ^ w15h >>> 6) + (w1l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 566280711 + w1l | 0;
          th = 3515267271 + w1h + (tl >>> 0 < w1l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w2l = w2l + w11l | 0;
          w2h = w2h + w11h + (w2l >>> 0 < w11l >>> 0 ? 1 : 0) | 0;
          xl = (w3l >>> 1 | w3h << 31) ^ (w3l >>> 8 | w3h << 24) ^ (w3l >>> 7 | w3h << 25) | 0;
          w2l = w2l + xl | 0;
          w2h = w2h + ((w3h >>> 1 | w3l << 31) ^ (w3h >>> 8 | w3l << 24) ^ w3h >>> 7) + (w2l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w0l >>> 19 | w0h << 13) ^ (w0l << 3 | w0h >>> 29) ^ (w0l >>> 6 | w0h << 26) | 0;
          w2l = w2l + xl | 0;
          w2h = w2h + ((w0h >>> 19 | w0l << 13) ^ (w0h << 3 | w0l >>> 29) ^ w0h >>> 6) + (w2l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3454069534 + w2l | 0;
          th = 3940187606 + w2h + (tl >>> 0 < w2l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w3l = w3l + w12l | 0;
          w3h = w3h + w12h + (w3l >>> 0 < w12l >>> 0 ? 1 : 0) | 0;
          xl = (w4l >>> 1 | w4h << 31) ^ (w4l >>> 8 | w4h << 24) ^ (w4l >>> 7 | w4h << 25) | 0;
          w3l = w3l + xl | 0;
          w3h = w3h + ((w4h >>> 1 | w4l << 31) ^ (w4h >>> 8 | w4l << 24) ^ w4h >>> 7) + (w3l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w1l >>> 19 | w1h << 13) ^ (w1l << 3 | w1h >>> 29) ^ (w1l >>> 6 | w1h << 26) | 0;
          w3l = w3l + xl | 0;
          w3h = w3h + ((w1h >>> 19 | w1l << 13) ^ (w1h << 3 | w1l >>> 29) ^ w1h >>> 6) + (w3l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 4000239992 + w3l | 0;
          th = 4118630271 + w3h + (tl >>> 0 < w3l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w4l = w4l + w13l | 0;
          w4h = w4h + w13h + (w4l >>> 0 < w13l >>> 0 ? 1 : 0) | 0;
          xl = (w5l >>> 1 | w5h << 31) ^ (w5l >>> 8 | w5h << 24) ^ (w5l >>> 7 | w5h << 25) | 0;
          w4l = w4l + xl | 0;
          w4h = w4h + ((w5h >>> 1 | w5l << 31) ^ (w5h >>> 8 | w5l << 24) ^ w5h >>> 7) + (w4l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w2l >>> 19 | w2h << 13) ^ (w2l << 3 | w2h >>> 29) ^ (w2l >>> 6 | w2h << 26) | 0;
          w4l = w4l + xl | 0;
          w4h = w4h + ((w2h >>> 19 | w2l << 13) ^ (w2h << 3 | w2l >>> 29) ^ w2h >>> 6) + (w4l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1914138554 + w4l | 0;
          th = 116418474 + w4h + (tl >>> 0 < w4l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w5l = w5l + w14l | 0;
          w5h = w5h + w14h + (w5l >>> 0 < w14l >>> 0 ? 1 : 0) | 0;
          xl = (w6l >>> 1 | w6h << 31) ^ (w6l >>> 8 | w6h << 24) ^ (w6l >>> 7 | w6h << 25) | 0;
          w5l = w5l + xl | 0;
          w5h = w5h + ((w6h >>> 1 | w6l << 31) ^ (w6h >>> 8 | w6l << 24) ^ w6h >>> 7) + (w5l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w3l >>> 19 | w3h << 13) ^ (w3l << 3 | w3h >>> 29) ^ (w3l >>> 6 | w3h << 26) | 0;
          w5l = w5l + xl | 0;
          w5h = w5h + ((w3h >>> 19 | w3l << 13) ^ (w3h << 3 | w3l >>> 29) ^ w3h >>> 6) + (w5l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2731055270 + w5l | 0;
          th = 174292421 + w5h + (tl >>> 0 < w5l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w6l = w6l + w15l | 0;
          w6h = w6h + w15h + (w6l >>> 0 < w15l >>> 0 ? 1 : 0) | 0;
          xl = (w7l >>> 1 | w7h << 31) ^ (w7l >>> 8 | w7h << 24) ^ (w7l >>> 7 | w7h << 25) | 0;
          w6l = w6l + xl | 0;
          w6h = w6h + ((w7h >>> 1 | w7l << 31) ^ (w7h >>> 8 | w7l << 24) ^ w7h >>> 7) + (w6l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w4l >>> 19 | w4h << 13) ^ (w4l << 3 | w4h >>> 29) ^ (w4l >>> 6 | w4h << 26) | 0;
          w6l = w6l + xl | 0;
          w6h = w6h + ((w4h >>> 19 | w4l << 13) ^ (w4h << 3 | w4l >>> 29) ^ w4h >>> 6) + (w6l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3203993006 + w6l | 0;
          th = 289380356 + w6h + (tl >>> 0 < w6l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w7l = w7l + w0l | 0;
          w7h = w7h + w0h + (w7l >>> 0 < w0l >>> 0 ? 1 : 0) | 0;
          xl = (w8l >>> 1 | w8h << 31) ^ (w8l >>> 8 | w8h << 24) ^ (w8l >>> 7 | w8h << 25) | 0;
          w7l = w7l + xl | 0;
          w7h = w7h + ((w8h >>> 1 | w8l << 31) ^ (w8h >>> 8 | w8l << 24) ^ w8h >>> 7) + (w7l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w5l >>> 19 | w5h << 13) ^ (w5l << 3 | w5h >>> 29) ^ (w5l >>> 6 | w5h << 26) | 0;
          w7l = w7l + xl | 0;
          w7h = w7h + ((w5h >>> 19 | w5l << 13) ^ (w5h << 3 | w5l >>> 29) ^ w5h >>> 6) + (w7l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 320620315 + w7l | 0;
          th = 460393269 + w7h + (tl >>> 0 < w7l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w8l = w8l + w1l | 0;
          w8h = w8h + w1h + (w8l >>> 0 < w1l >>> 0 ? 1 : 0) | 0;
          xl = (w9l >>> 1 | w9h << 31) ^ (w9l >>> 8 | w9h << 24) ^ (w9l >>> 7 | w9h << 25) | 0;
          w8l = w8l + xl | 0;
          w8h = w8h + ((w9h >>> 1 | w9l << 31) ^ (w9h >>> 8 | w9l << 24) ^ w9h >>> 7) + (w8l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w6l >>> 19 | w6h << 13) ^ (w6l << 3 | w6h >>> 29) ^ (w6l >>> 6 | w6h << 26) | 0;
          w8l = w8l + xl | 0;
          w8h = w8h + ((w6h >>> 19 | w6l << 13) ^ (w6h << 3 | w6l >>> 29) ^ w6h >>> 6) + (w8l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 587496836 + w8l | 0;
          th = 685471733 + w8h + (tl >>> 0 < w8l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w9l = w9l + w2l | 0;
          w9h = w9h + w2h + (w9l >>> 0 < w2l >>> 0 ? 1 : 0) | 0;
          xl = (w10l >>> 1 | w10h << 31) ^ (w10l >>> 8 | w10h << 24) ^ (w10l >>> 7 | w10h << 25) | 0;
          w9l = w9l + xl | 0;
          w9h = w9h + ((w10h >>> 1 | w10l << 31) ^ (w10h >>> 8 | w10l << 24) ^ w10h >>> 7) + (w9l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w7l >>> 19 | w7h << 13) ^ (w7l << 3 | w7h >>> 29) ^ (w7l >>> 6 | w7h << 26) | 0;
          w9l = w9l + xl | 0;
          w9h = w9h + ((w7h >>> 19 | w7l << 13) ^ (w7h << 3 | w7l >>> 29) ^ w7h >>> 6) + (w9l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1086792851 + w9l | 0;
          th = 852142971 + w9h + (tl >>> 0 < w9l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w10l = w10l + w3l | 0;
          w10h = w10h + w3h + (w10l >>> 0 < w3l >>> 0 ? 1 : 0) | 0;
          xl = (w11l >>> 1 | w11h << 31) ^ (w11l >>> 8 | w11h << 24) ^ (w11l >>> 7 | w11h << 25) | 0;
          w10l = w10l + xl | 0;
          w10h = w10h + ((w11h >>> 1 | w11l << 31) ^ (w11h >>> 8 | w11l << 24) ^ w11h >>> 7) + (w10l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w8l >>> 19 | w8h << 13) ^ (w8l << 3 | w8h >>> 29) ^ (w8l >>> 6 | w8h << 26) | 0;
          w10l = w10l + xl | 0;
          w10h = w10h + ((w8h >>> 19 | w8l << 13) ^ (w8h << 3 | w8l >>> 29) ^ w8h >>> 6) + (w10l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 365543100 + w10l | 0;
          th = 1017036298 + w10h + (tl >>> 0 < w10l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w11l = w11l + w4l | 0;
          w11h = w11h + w4h + (w11l >>> 0 < w4l >>> 0 ? 1 : 0) | 0;
          xl = (w12l >>> 1 | w12h << 31) ^ (w12l >>> 8 | w12h << 24) ^ (w12l >>> 7 | w12h << 25) | 0;
          w11l = w11l + xl | 0;
          w11h = w11h + ((w12h >>> 1 | w12l << 31) ^ (w12h >>> 8 | w12l << 24) ^ w12h >>> 7) + (w11l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w9l >>> 19 | w9h << 13) ^ (w9l << 3 | w9h >>> 29) ^ (w9l >>> 6 | w9h << 26) | 0;
          w11l = w11l + xl | 0;
          w11h = w11h + ((w9h >>> 19 | w9l << 13) ^ (w9h << 3 | w9l >>> 29) ^ w9h >>> 6) + (w11l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 2618297676 + w11l | 0;
          th = 1126000580 + w11h + (tl >>> 0 < w11l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w12l = w12l + w5l | 0;
          w12h = w12h + w5h + (w12l >>> 0 < w5l >>> 0 ? 1 : 0) | 0;
          xl = (w13l >>> 1 | w13h << 31) ^ (w13l >>> 8 | w13h << 24) ^ (w13l >>> 7 | w13h << 25) | 0;
          w12l = w12l + xl | 0;
          w12h = w12h + ((w13h >>> 1 | w13l << 31) ^ (w13h >>> 8 | w13l << 24) ^ w13h >>> 7) + (w12l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w10l >>> 19 | w10h << 13) ^ (w10l << 3 | w10h >>> 29) ^ (w10l >>> 6 | w10h << 26) | 0;
          w12l = w12l + xl | 0;
          w12h = w12h + ((w10h >>> 19 | w10l << 13) ^ (w10h << 3 | w10l >>> 29) ^ w10h >>> 6) + (w12l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 3409855158 + w12l | 0;
          th = 1288033470 + w12h + (tl >>> 0 < w12l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w13l = w13l + w6l | 0;
          w13h = w13h + w6h + (w13l >>> 0 < w6l >>> 0 ? 1 : 0) | 0;
          xl = (w14l >>> 1 | w14h << 31) ^ (w14l >>> 8 | w14h << 24) ^ (w14l >>> 7 | w14h << 25) | 0;
          w13l = w13l + xl | 0;
          w13h = w13h + ((w14h >>> 1 | w14l << 31) ^ (w14h >>> 8 | w14l << 24) ^ w14h >>> 7) + (w13l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w11l >>> 19 | w11h << 13) ^ (w11l << 3 | w11h >>> 29) ^ (w11l >>> 6 | w11h << 26) | 0;
          w13l = w13l + xl | 0;
          w13h = w13h + ((w11h >>> 19 | w11l << 13) ^ (w11h << 3 | w11l >>> 29) ^ w11h >>> 6) + (w13l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 4234509866 + w13l | 0;
          th = 1501505948 + w13h + (tl >>> 0 < w13l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w14l = w14l + w7l | 0;
          w14h = w14h + w7h + (w14l >>> 0 < w7l >>> 0 ? 1 : 0) | 0;
          xl = (w15l >>> 1 | w15h << 31) ^ (w15l >>> 8 | w15h << 24) ^ (w15l >>> 7 | w15h << 25) | 0;
          w14l = w14l + xl | 0;
          w14h = w14h + ((w15h >>> 1 | w15l << 31) ^ (w15h >>> 8 | w15l << 24) ^ w15h >>> 7) + (w14l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w12l >>> 19 | w12h << 13) ^ (w12l << 3 | w12h >>> 29) ^ (w12l >>> 6 | w12h << 26) | 0;
          w14l = w14l + xl | 0;
          w14h = w14h + ((w12h >>> 19 | w12l << 13) ^ (w12h << 3 | w12l >>> 29) ^ w12h >>> 6) + (w14l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 987167468 + w14l | 0;
          th = 1607167915 + w14h + (tl >>> 0 < w14l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          w15l = w15l + w8l | 0;
          w15h = w15h + w8h + (w15l >>> 0 < w8l >>> 0 ? 1 : 0) | 0;
          xl = (w0l >>> 1 | w0h << 31) ^ (w0l >>> 8 | w0h << 24) ^ (w0l >>> 7 | w0h << 25) | 0;
          w15l = w15l + xl | 0;
          w15h = w15h + ((w0h >>> 1 | w0l << 31) ^ (w0h >>> 8 | w0l << 24) ^ w0h >>> 7) + (w15l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = (w13l >>> 19 | w13h << 13) ^ (w13l << 3 | w13h >>> 29) ^ (w13l >>> 6 | w13h << 26) | 0;
          w15l = w15l + xl | 0;
          w15h = w15h + ((w13h >>> 19 | w13l << 13) ^ (w13h << 3 | w13l >>> 29) ^ w13h >>> 6) + (w15l >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          tl = 1246189591 + w15l | 0;
          th = 1816402316 + w15h + (tl >>> 0 < w15l >>> 0 ? 1 : 0) | 0;
          tl = tl + hl | 0;
          th = th + hh + (tl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
          xl = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9) | 0;
          tl = tl + xl | 0;
          th = th + ((eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          xl = gl ^ el & (fl ^ gl) | 0;
          tl = tl + xl | 0;
          th = th + (gh ^ eh & (fh ^ gh)) + (tl >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          hl = gl;
          hh = gh;
          gl = fl;
          gh = fh;
          fl = el;
          fh = eh;
          el = dl + tl | 0;
          eh = dh + th + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dl = cl;
          dh = ch;
          cl = bl;
          ch = bh;
          bl = al;
          bh = ah;
          al = tl + (bl & cl ^ dl & (bl ^ cl)) | 0;
          ah = th + (bh & ch ^ dh & (bh ^ ch)) + (al >>> 0 < tl >>> 0 ? 1 : 0) | 0;
          xl = (bl >>> 28 | bh << 4) ^ (bl << 30 | bh >>> 2) ^ (bl << 25 | bh >>> 7) | 0;
          al = al + xl | 0;
          ah = ah + ((bh >>> 28 | bl << 4) ^ (bh << 30 | bl >>> 2) ^ (bh << 25 | bl >>> 7)) + (al >>> 0 < xl >>> 0 ? 1 : 0) | 0;
          H0l = H0l + al | 0;
          H0h = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0) | 0;
          H1l = H1l + bl | 0;
          H1h = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0) | 0;
          H2l = H2l + cl | 0;
          H2h = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0) | 0;
          H3l = H3l + dl | 0;
          H3h = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          H4l = H4l + el | 0;
          H4h = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0) | 0;
          H5l = H5l + fl | 0;
          H5h = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0) | 0;
          H6l = H6l + gl | 0;
          H6h = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0) | 0;
          H7l = H7l + hl | 0;
          H7h = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0) | 0;
        }
        function _core_heap(offset) {
          offset = offset | 0;
          _core(HEAP[offset | 0] << 24 | HEAP[offset | 1] << 16 | HEAP[offset | 2] << 8 | HEAP[offset | 3], HEAP[offset | 4] << 24 | HEAP[offset | 5] << 16 | HEAP[offset | 6] << 8 | HEAP[offset | 7], HEAP[offset | 8] << 24 | HEAP[offset | 9] << 16 | HEAP[offset | 10] << 8 | HEAP[offset | 11], HEAP[offset | 12] << 24 | HEAP[offset | 13] << 16 | HEAP[offset | 14] << 8 | HEAP[offset | 15], HEAP[offset | 16] << 24 | HEAP[offset | 17] << 16 | HEAP[offset | 18] << 8 | HEAP[offset | 19], HEAP[offset | 20] << 24 | HEAP[offset | 21] << 16 | HEAP[offset | 22] << 8 | HEAP[offset | 23], HEAP[offset | 24] << 24 | HEAP[offset | 25] << 16 | HEAP[offset | 26] << 8 | HEAP[offset | 27], HEAP[offset | 28] << 24 | HEAP[offset | 29] << 16 | HEAP[offset | 30] << 8 | HEAP[offset | 31], HEAP[offset | 32] << 24 | HEAP[offset | 33] << 16 | HEAP[offset | 34] << 8 | HEAP[offset | 35], HEAP[offset | 36] << 24 | HEAP[offset | 37] << 16 | HEAP[offset | 38] << 8 | HEAP[offset | 39], HEAP[offset | 40] << 24 | HEAP[offset | 41] << 16 | HEAP[offset | 42] << 8 | HEAP[offset | 43], HEAP[offset | 44] << 24 | HEAP[offset | 45] << 16 | HEAP[offset | 46] << 8 | HEAP[offset | 47], HEAP[offset | 48] << 24 | HEAP[offset | 49] << 16 | HEAP[offset | 50] << 8 | HEAP[offset | 51], HEAP[offset | 52] << 24 | HEAP[offset | 53] << 16 | HEAP[offset | 54] << 8 | HEAP[offset | 55], HEAP[offset | 56] << 24 | HEAP[offset | 57] << 16 | HEAP[offset | 58] << 8 | HEAP[offset | 59], HEAP[offset | 60] << 24 | HEAP[offset | 61] << 16 | HEAP[offset | 62] << 8 | HEAP[offset | 63], HEAP[offset | 64] << 24 | HEAP[offset | 65] << 16 | HEAP[offset | 66] << 8 | HEAP[offset | 67], HEAP[offset | 68] << 24 | HEAP[offset | 69] << 16 | HEAP[offset | 70] << 8 | HEAP[offset | 71], HEAP[offset | 72] << 24 | HEAP[offset | 73] << 16 | HEAP[offset | 74] << 8 | HEAP[offset | 75], HEAP[offset | 76] << 24 | HEAP[offset | 77] << 16 | HEAP[offset | 78] << 8 | HEAP[offset | 79], HEAP[offset | 80] << 24 | HEAP[offset | 81] << 16 | HEAP[offset | 82] << 8 | HEAP[offset | 83], HEAP[offset | 84] << 24 | HEAP[offset | 85] << 16 | HEAP[offset | 86] << 8 | HEAP[offset | 87], HEAP[offset | 88] << 24 | HEAP[offset | 89] << 16 | HEAP[offset | 90] << 8 | HEAP[offset | 91], HEAP[offset | 92] << 24 | HEAP[offset | 93] << 16 | HEAP[offset | 94] << 8 | HEAP[offset | 95], HEAP[offset | 96] << 24 | HEAP[offset | 97] << 16 | HEAP[offset | 98] << 8 | HEAP[offset | 99], HEAP[offset | 100] << 24 | HEAP[offset | 101] << 16 | HEAP[offset | 102] << 8 | HEAP[offset | 103], HEAP[offset | 104] << 24 | HEAP[offset | 105] << 16 | HEAP[offset | 106] << 8 | HEAP[offset | 107], HEAP[offset | 108] << 24 | HEAP[offset | 109] << 16 | HEAP[offset | 110] << 8 | HEAP[offset | 111], HEAP[offset | 112] << 24 | HEAP[offset | 113] << 16 | HEAP[offset | 114] << 8 | HEAP[offset | 115], HEAP[offset | 116] << 24 | HEAP[offset | 117] << 16 | HEAP[offset | 118] << 8 | HEAP[offset | 119], HEAP[offset | 120] << 24 | HEAP[offset | 121] << 16 | HEAP[offset | 122] << 8 | HEAP[offset | 123], HEAP[offset | 124] << 24 | HEAP[offset | 125] << 16 | HEAP[offset | 126] << 8 | HEAP[offset | 127]);
        }
        function _state_to_heap(output) {
          output = output | 0;
          HEAP[output | 0] = H0h >>> 24;
          HEAP[output | 1] = H0h >>> 16 & 255;
          HEAP[output | 2] = H0h >>> 8 & 255;
          HEAP[output | 3] = H0h & 255;
          HEAP[output | 4] = H0l >>> 24;
          HEAP[output | 5] = H0l >>> 16 & 255;
          HEAP[output | 6] = H0l >>> 8 & 255;
          HEAP[output | 7] = H0l & 255;
          HEAP[output | 8] = H1h >>> 24;
          HEAP[output | 9] = H1h >>> 16 & 255;
          HEAP[output | 10] = H1h >>> 8 & 255;
          HEAP[output | 11] = H1h & 255;
          HEAP[output | 12] = H1l >>> 24;
          HEAP[output | 13] = H1l >>> 16 & 255;
          HEAP[output | 14] = H1l >>> 8 & 255;
          HEAP[output | 15] = H1l & 255;
          HEAP[output | 16] = H2h >>> 24;
          HEAP[output | 17] = H2h >>> 16 & 255;
          HEAP[output | 18] = H2h >>> 8 & 255;
          HEAP[output | 19] = H2h & 255;
          HEAP[output | 20] = H2l >>> 24;
          HEAP[output | 21] = H2l >>> 16 & 255;
          HEAP[output | 22] = H2l >>> 8 & 255;
          HEAP[output | 23] = H2l & 255;
          HEAP[output | 24] = H3h >>> 24;
          HEAP[output | 25] = H3h >>> 16 & 255;
          HEAP[output | 26] = H3h >>> 8 & 255;
          HEAP[output | 27] = H3h & 255;
          HEAP[output | 28] = H3l >>> 24;
          HEAP[output | 29] = H3l >>> 16 & 255;
          HEAP[output | 30] = H3l >>> 8 & 255;
          HEAP[output | 31] = H3l & 255;
          HEAP[output | 32] = H4h >>> 24;
          HEAP[output | 33] = H4h >>> 16 & 255;
          HEAP[output | 34] = H4h >>> 8 & 255;
          HEAP[output | 35] = H4h & 255;
          HEAP[output | 36] = H4l >>> 24;
          HEAP[output | 37] = H4l >>> 16 & 255;
          HEAP[output | 38] = H4l >>> 8 & 255;
          HEAP[output | 39] = H4l & 255;
          HEAP[output | 40] = H5h >>> 24;
          HEAP[output | 41] = H5h >>> 16 & 255;
          HEAP[output | 42] = H5h >>> 8 & 255;
          HEAP[output | 43] = H5h & 255;
          HEAP[output | 44] = H5l >>> 24;
          HEAP[output | 45] = H5l >>> 16 & 255;
          HEAP[output | 46] = H5l >>> 8 & 255;
          HEAP[output | 47] = H5l & 255;
          HEAP[output | 48] = H6h >>> 24;
          HEAP[output | 49] = H6h >>> 16 & 255;
          HEAP[output | 50] = H6h >>> 8 & 255;
          HEAP[output | 51] = H6h & 255;
          HEAP[output | 52] = H6l >>> 24;
          HEAP[output | 53] = H6l >>> 16 & 255;
          HEAP[output | 54] = H6l >>> 8 & 255;
          HEAP[output | 55] = H6l & 255;
          HEAP[output | 56] = H7h >>> 24;
          HEAP[output | 57] = H7h >>> 16 & 255;
          HEAP[output | 58] = H7h >>> 8 & 255;
          HEAP[output | 59] = H7h & 255;
          HEAP[output | 60] = H7l >>> 24;
          HEAP[output | 61] = H7l >>> 16 & 255;
          HEAP[output | 62] = H7l >>> 8 & 255;
          HEAP[output | 63] = H7l & 255;
        }
        function reset() {
          H0h = 1779033703;
          H0l = 4089235720;
          H1h = 3144134277;
          H1l = 2227873595;
          H2h = 1013904242;
          H2l = 4271175723;
          H3h = 2773480762;
          H3l = 1595750129;
          H4h = 1359893119;
          H4l = 2917565137;
          H5h = 2600822924;
          H5l = 725511199;
          H6h = 528734635;
          H6l = 4215389547;
          H7h = 1541459225;
          H7l = 327033209;
          TOTAL0 = TOTAL1 = 0;
        }
        function init(h0h, h0l, h1h, h1l, h2h, h2l, h3h, h3l, h4h, h4l, h5h, h5l, h6h, h6l, h7h, h7l, total0, total1) {
          h0h = h0h | 0;
          h0l = h0l | 0;
          h1h = h1h | 0;
          h1l = h1l | 0;
          h2h = h2h | 0;
          h2l = h2l | 0;
          h3h = h3h | 0;
          h3l = h3l | 0;
          h4h = h4h | 0;
          h4l = h4l | 0;
          h5h = h5h | 0;
          h5l = h5l | 0;
          h6h = h6h | 0;
          h6l = h6l | 0;
          h7h = h7h | 0;
          h7l = h7l | 0;
          total0 = total0 | 0;
          total1 = total1 | 0;
          H0h = h0h;
          H0l = h0l;
          H1h = h1h;
          H1l = h1l;
          H2h = h2h;
          H2l = h2l;
          H3h = h3h;
          H3l = h3l;
          H4h = h4h;
          H4l = h4l;
          H5h = h5h;
          H5l = h5l;
          H6h = h6h;
          H6l = h6l;
          H7h = h7h;
          H7l = h7l;
          TOTAL0 = total0;
          TOTAL1 = total1;
        }
        function process2(offset, length) {
          offset = offset | 0;
          length = length | 0;
          var hashed = 0;
          if (offset & 127)
            return -1;
          while ((length | 0) >= 128) {
            _core_heap(offset);
            offset = offset + 128 | 0;
            length = length - 128 | 0;
            hashed = hashed + 128 | 0;
          }
          TOTAL0 = TOTAL0 + hashed | 0;
          if (TOTAL0 >>> 0 < hashed >>> 0)
            TOTAL1 = TOTAL1 + 1 | 0;
          return hashed | 0;
        }
        function finish(offset, length, output) {
          offset = offset | 0;
          length = length | 0;
          output = output | 0;
          var hashed = 0, i = 0;
          if (offset & 127)
            return -1;
          if (~output) {
            if (output & 63)
              return -1;
          }
          if ((length | 0) >= 128) {
            hashed = process2(offset, length) | 0;
            if ((hashed | 0) == -1)
              return -1;
            offset = offset + hashed | 0;
            length = length - hashed | 0;
          }
          hashed = hashed + length | 0;
          TOTAL0 = TOTAL0 + length | 0;
          if (TOTAL0 >>> 0 < length >>> 0)
            TOTAL1 = TOTAL1 + 1 | 0;
          HEAP[offset | length] = 128;
          if ((length | 0) >= 112) {
            for (i = length + 1 | 0; (i | 0) < 128; i = i + 1 | 0)
              HEAP[offset | i] = 0;
            _core_heap(offset);
            length = 0;
            HEAP[offset | 0] = 0;
          }
          for (i = length + 1 | 0; (i | 0) < 123; i = i + 1 | 0)
            HEAP[offset | i] = 0;
          HEAP[offset | 120] = TOTAL1 >>> 21 & 255;
          HEAP[offset | 121] = TOTAL1 >>> 13 & 255;
          HEAP[offset | 122] = TOTAL1 >>> 5 & 255;
          HEAP[offset | 123] = TOTAL1 << 3 & 255 | TOTAL0 >>> 29;
          HEAP[offset | 124] = TOTAL0 >>> 21 & 255;
          HEAP[offset | 125] = TOTAL0 >>> 13 & 255;
          HEAP[offset | 126] = TOTAL0 >>> 5 & 255;
          HEAP[offset | 127] = TOTAL0 << 3 & 255;
          _core_heap(offset);
          if (~output)
            _state_to_heap(output);
          return hashed | 0;
        }
        function hmac_reset() {
          H0h = I0h;
          H0l = I0l;
          H1h = I1h;
          H1l = I1l;
          H2h = I2h;
          H2l = I2l;
          H3h = I3h;
          H3l = I3l;
          H4h = I4h;
          H4l = I4l;
          H5h = I5h;
          H5l = I5l;
          H6h = I6h;
          H6l = I6l;
          H7h = I7h;
          H7l = I7l;
          TOTAL0 = 128;
          TOTAL1 = 0;
        }
        function _hmac_opad() {
          H0h = O0h;
          H0l = O0l;
          H1h = O1h;
          H1l = O1l;
          H2h = O2h;
          H2l = O2l;
          H3h = O3h;
          H3l = O3l;
          H4h = O4h;
          H4l = O4l;
          H5h = O5h;
          H5l = O5l;
          H6h = O6h;
          H6l = O6l;
          H7h = O7h;
          H7l = O7l;
          TOTAL0 = 128;
          TOTAL1 = 0;
        }
        function hmac_init(p0h, p0l, p1h, p1l, p2h, p2l, p3h, p3l, p4h, p4l, p5h, p5l, p6h, p6l, p7h, p7l, p8h, p8l, p9h, p9l, p10h, p10l, p11h, p11l, p12h, p12l, p13h, p13l, p14h, p14l, p15h, p15l) {
          p0h = p0h | 0;
          p0l = p0l | 0;
          p1h = p1h | 0;
          p1l = p1l | 0;
          p2h = p2h | 0;
          p2l = p2l | 0;
          p3h = p3h | 0;
          p3l = p3l | 0;
          p4h = p4h | 0;
          p4l = p4l | 0;
          p5h = p5h | 0;
          p5l = p5l | 0;
          p6h = p6h | 0;
          p6l = p6l | 0;
          p7h = p7h | 0;
          p7l = p7l | 0;
          p8h = p8h | 0;
          p8l = p8l | 0;
          p9h = p9h | 0;
          p9l = p9l | 0;
          p10h = p10h | 0;
          p10l = p10l | 0;
          p11h = p11h | 0;
          p11l = p11l | 0;
          p12h = p12h | 0;
          p12l = p12l | 0;
          p13h = p13h | 0;
          p13l = p13l | 0;
          p14h = p14h | 0;
          p14l = p14l | 0;
          p15h = p15h | 0;
          p15l = p15l | 0;
          reset();
          _core(p0h ^ 1549556828, p0l ^ 1549556828, p1h ^ 1549556828, p1l ^ 1549556828, p2h ^ 1549556828, p2l ^ 1549556828, p3h ^ 1549556828, p3l ^ 1549556828, p4h ^ 1549556828, p4l ^ 1549556828, p5h ^ 1549556828, p5l ^ 1549556828, p6h ^ 1549556828, p6l ^ 1549556828, p7h ^ 1549556828, p7l ^ 1549556828, p8h ^ 1549556828, p8l ^ 1549556828, p9h ^ 1549556828, p9l ^ 1549556828, p10h ^ 1549556828, p10l ^ 1549556828, p11h ^ 1549556828, p11l ^ 1549556828, p12h ^ 1549556828, p12l ^ 1549556828, p13h ^ 1549556828, p13l ^ 1549556828, p14h ^ 1549556828, p14l ^ 1549556828, p15h ^ 1549556828, p15l ^ 1549556828);
          O0h = H0h;
          O0l = H0l;
          O1h = H1h;
          O1l = H1l;
          O2h = H2h;
          O2l = H2l;
          O3h = H3h;
          O3l = H3l;
          O4h = H4h;
          O4l = H4l;
          O5h = H5h;
          O5l = H5l;
          O6h = H6h;
          O6l = H6l;
          O7h = H7h;
          O7l = H7l;
          reset();
          _core(p0h ^ 909522486, p0l ^ 909522486, p1h ^ 909522486, p1l ^ 909522486, p2h ^ 909522486, p2l ^ 909522486, p3h ^ 909522486, p3l ^ 909522486, p4h ^ 909522486, p4l ^ 909522486, p5h ^ 909522486, p5l ^ 909522486, p6h ^ 909522486, p6l ^ 909522486, p7h ^ 909522486, p7l ^ 909522486, p8h ^ 909522486, p8l ^ 909522486, p9h ^ 909522486, p9l ^ 909522486, p10h ^ 909522486, p10l ^ 909522486, p11h ^ 909522486, p11l ^ 909522486, p12h ^ 909522486, p12l ^ 909522486, p13h ^ 909522486, p13l ^ 909522486, p14h ^ 909522486, p14l ^ 909522486, p15h ^ 909522486, p15l ^ 909522486);
          I0h = H0h;
          I0l = H0l;
          I1h = H1h;
          I1l = H1l;
          I2h = H2h;
          I2l = H2l;
          I3h = H3h;
          I3l = H3l;
          I4h = H4h;
          I4l = H4l;
          I5h = H5h;
          I5l = H5l;
          I6h = H6h;
          I6l = H6l;
          I7h = H7h;
          I7l = H7l;
          TOTAL0 = 128;
          TOTAL1 = 0;
        }
        function hmac_finish(offset, length, output) {
          offset = offset | 0;
          length = length | 0;
          output = output | 0;
          var t0h = 0, t0l = 0, t1h = 0, t1l = 0, t2h = 0, t2l = 0, t3h = 0, t3l = 0, t4h = 0, t4l = 0, t5h = 0, t5l = 0, t6h = 0, t6l = 0, t7h = 0, t7l = 0, hashed = 0;
          if (offset & 127)
            return -1;
          if (~output) {
            if (output & 63)
              return -1;
          }
          hashed = finish(offset, length, -1) | 0;
          t0h = H0h;
          t0l = H0l;
          t1h = H1h;
          t1l = H1l;
          t2h = H2h;
          t2l = H2l;
          t3h = H3h;
          t3l = H3l;
          t4h = H4h;
          t4l = H4l;
          t5h = H5h;
          t5l = H5l;
          t6h = H6h;
          t6l = H6l;
          t7h = H7h;
          t7l = H7l;
          _hmac_opad();
          _core(t0h, t0l, t1h, t1l, t2h, t2l, t3h, t3l, t4h, t4l, t5h, t5l, t6h, t6l, t7h, t7l, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1536);
          if (~output)
            _state_to_heap(output);
          return hashed | 0;
        }
        function pbkdf2_generate_block(offset, length, block, count, output) {
          offset = offset | 0;
          length = length | 0;
          block = block | 0;
          count = count | 0;
          output = output | 0;
          var h0h = 0, h0l = 0, h1h = 0, h1l = 0, h2h = 0, h2l = 0, h3h = 0, h3l = 0, h4h = 0, h4l = 0, h5h = 0, h5l = 0, h6h = 0, h6l = 0, h7h = 0, h7l = 0, t0h = 0, t0l = 0, t1h = 0, t1l = 0, t2h = 0, t2l = 0, t3h = 0, t3l = 0, t4h = 0, t4l = 0, t5h = 0, t5l = 0, t6h = 0, t6l = 0, t7h = 0, t7l = 0;
          if (offset & 127)
            return -1;
          if (~output) {
            if (output & 63)
              return -1;
          }
          HEAP[offset + length | 0] = block >>> 24;
          HEAP[offset + length + 1 | 0] = block >>> 16 & 255;
          HEAP[offset + length + 2 | 0] = block >>> 8 & 255;
          HEAP[offset + length + 3 | 0] = block & 255;
          hmac_finish(offset, length + 4 | 0, -1) | 0;
          h0h = t0h = H0h;
          h0l = t0l = H0l;
          h1h = t1h = H1h;
          h1l = t1l = H1l;
          h2h = t2h = H2h;
          h2l = t2l = H2l;
          h3h = t3h = H3h;
          h3l = t3l = H3l;
          h4h = t4h = H4h;
          h4l = t4l = H4l;
          h5h = t5h = H5h;
          h5l = t5l = H5l;
          h6h = t6h = H6h;
          h6l = t6l = H6l;
          h7h = t7h = H7h;
          h7l = t7l = H7l;
          count = count - 1 | 0;
          while ((count | 0) > 0) {
            hmac_reset();
            _core(t0h, t0l, t1h, t1l, t2h, t2l, t3h, t3l, t4h, t4l, t5h, t5l, t6h, t6l, t7h, t7l, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1536);
            t0h = H0h;
            t0l = H0l;
            t1h = H1h;
            t1l = H1l;
            t2h = H2h;
            t2l = H2l;
            t3h = H3h;
            t3l = H3l;
            t4h = H4h;
            t4l = H4l;
            t5h = H5h;
            t5l = H5l;
            t6h = H6h;
            t6l = H6l;
            t7h = H7h;
            t7l = H7l;
            _hmac_opad();
            _core(t0h, t0l, t1h, t1l, t2h, t2l, t3h, t3l, t4h, t4l, t5h, t5l, t6h, t6l, t7h, t7l, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1536);
            t0h = H0h;
            t0l = H0l;
            t1h = H1h;
            t1l = H1l;
            t2h = H2h;
            t2l = H2l;
            t3h = H3h;
            t3l = H3l;
            t4h = H4h;
            t4l = H4l;
            t5h = H5h;
            t5l = H5l;
            t6h = H6h;
            t6l = H6l;
            t7h = H7h;
            t7l = H7l;
            h0h = h0h ^ H0h;
            h0l = h0l ^ H0l;
            h1h = h1h ^ H1h;
            h1l = h1l ^ H1l;
            h2h = h2h ^ H2h;
            h2l = h2l ^ H2l;
            h3h = h3h ^ H3h;
            h3l = h3l ^ H3l;
            h4h = h4h ^ H4h;
            h4l = h4l ^ H4l;
            h5h = h5h ^ H5h;
            h5l = h5l ^ H5l;
            h6h = h6h ^ H6h;
            h6l = h6l ^ H6l;
            h7h = h7h ^ H7h;
            h7l = h7l ^ H7l;
            count = count - 1 | 0;
          }
          H0h = h0h;
          H0l = h0l;
          H1h = h1h;
          H1l = h1l;
          H2h = h2h;
          H2l = h2l;
          H3h = h3h;
          H3l = h3l;
          H4h = h4h;
          H4l = h4l;
          H5h = h5h;
          H5l = h5l;
          H6h = h6h;
          H6l = h6l;
          H7h = h7h;
          H7l = h7l;
          if (~output)
            _state_to_heap(output);
          return 0;
        }
        return {
          reset,
          init,
          process: process2,
          finish,
          hmac_reset,
          hmac_init,
          hmac_finish,
          pbkdf2_generate_block
        };
      };
      var __extends$b = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var _sha512_block_size = 128;
      var _sha512_hash_size = 64;
      var Sha512 = function(_super) {
        __extends$b(Sha5122, _super);
        function Sha5122() {
          var _this = _super.call(this) || this;
          _this.NAME = "sha512";
          _this.BLOCK_SIZE = _sha512_block_size;
          _this.HASH_SIZE = _sha512_hash_size;
          _this.heap = _heap_init();
          _this.asm = sha512_asm({ Uint8Array }, null, _this.heap.buffer);
          _this.reset();
          return _this;
        }
        Sha5122.NAME = "sha512";
        return Sha5122;
      }(Hash);
      var Hmac = function() {
        function Hmac2(hash, password, verify) {
          if (!hash.HASH_SIZE)
            throw new SyntaxError("option 'hash' supplied doesn't seem to be a valid hash function");
          this.hash = hash;
          this.BLOCK_SIZE = this.hash.BLOCK_SIZE;
          this.HMAC_SIZE = this.hash.HASH_SIZE;
          this.result = null;
          this.key = _hmac_key(this.hash, password);
          var ipad = new Uint8Array(this.key);
          for (var i = 0; i < ipad.length; ++i)
            ipad[i] ^= 54;
          this.hash.reset().process(ipad);
          if (verify !== void 0) {
            this._hmac_init_verify(verify);
          } else {
            this.verify = null;
          }
        }
        Hmac2.prototype.process = function(data) {
          if (this.result !== null)
            throw new IllegalStateError("state must be reset before processing new data");
          this.hash.process(data);
          return this;
        };
        Hmac2.prototype.finish = function() {
          if (this.result !== null)
            throw new IllegalStateError("state must be reset before processing new data");
          var inner_result = this.hash.finish().result;
          var opad = new Uint8Array(this.key);
          for (var i = 0; i < opad.length; ++i)
            opad[i] ^= 92;
          var verify = this.verify;
          var result = this.hash.reset().process(opad).process(inner_result).finish().result;
          if (verify) {
            if (verify.length === result.length) {
              var diff = 0;
              for (var i = 0; i < verify.length; i++) {
                diff |= verify[i] ^ result[i];
              }
              if (diff !== 0)
                throw new Error("HMAC verification failed, hash value doesn't match");
            } else {
              throw new Error("HMAC verification failed, lengths doesn't match");
            }
          }
          this.result = result;
          return this;
        };
        Hmac2.prototype._hmac_init_verify = function(verify) {
          if (verify.length !== this.HMAC_SIZE)
            throw new IllegalArgumentError("illegal verification tag size");
          this.verify = verify;
        };
        return Hmac2;
      }();
      function _hmac_key(hash, password) {
        var key = new Uint8Array(hash.BLOCK_SIZE);
        if (password.length > hash.BLOCK_SIZE) {
          key.set(hash.reset().process(password).finish().result);
        } else {
          key.set(password);
        }
        return key;
      }
      var __extends$c = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var HmacSha1 = function(_super) {
        __extends$c(HmacSha12, _super);
        function HmacSha12(password, verify) {
          var _this = this;
          var hash = new Sha1();
          _this = _super.call(this, hash, password, verify) || this;
          _this.reset();
          if (verify !== void 0) {
            _this._hmac_init_verify(verify);
          } else {
            _this.verify = null;
          }
          return _this;
        }
        HmacSha12.prototype.reset = function() {
          this.result = null;
          var key = this.key;
          this.hash.reset().asm.hmac_init(key[0] << 24 | key[1] << 16 | key[2] << 8 | key[3], key[4] << 24 | key[5] << 16 | key[6] << 8 | key[7], key[8] << 24 | key[9] << 16 | key[10] << 8 | key[11], key[12] << 24 | key[13] << 16 | key[14] << 8 | key[15], key[16] << 24 | key[17] << 16 | key[18] << 8 | key[19], key[20] << 24 | key[21] << 16 | key[22] << 8 | key[23], key[24] << 24 | key[25] << 16 | key[26] << 8 | key[27], key[28] << 24 | key[29] << 16 | key[30] << 8 | key[31], key[32] << 24 | key[33] << 16 | key[34] << 8 | key[35], key[36] << 24 | key[37] << 16 | key[38] << 8 | key[39], key[40] << 24 | key[41] << 16 | key[42] << 8 | key[43], key[44] << 24 | key[45] << 16 | key[46] << 8 | key[47], key[48] << 24 | key[49] << 16 | key[50] << 8 | key[51], key[52] << 24 | key[53] << 16 | key[54] << 8 | key[55], key[56] << 24 | key[57] << 16 | key[58] << 8 | key[59], key[60] << 24 | key[61] << 16 | key[62] << 8 | key[63]);
          return this;
        };
        HmacSha12.prototype.finish = function() {
          if (this.result !== null)
            throw new IllegalStateError("state must be reset before processing new data");
          var hash = this.hash;
          var asm = this.hash.asm;
          var heap = this.hash.heap;
          asm.hmac_finish(hash.pos, hash.len, 0);
          var verify = this.verify;
          var result = new Uint8Array(_sha1_hash_size);
          result.set(heap.subarray(0, _sha1_hash_size));
          if (verify) {
            if (verify.length === result.length) {
              var diff = 0;
              for (var i = 0; i < verify.length; i++) {
                diff |= verify[i] ^ result[i];
              }
              if (diff !== 0)
                throw new Error("HMAC verification failed, hash value doesn't match");
            } else {
              throw new Error("HMAC verification failed, lengths doesn't match");
            }
          } else {
            this.result = result;
          }
          return this;
        };
        return HmacSha12;
      }(Hmac);
      var __extends$d = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var HmacSha256 = function(_super) {
        __extends$d(HmacSha2562, _super);
        function HmacSha2562(password, verify) {
          var _this = this;
          var hash = new Sha256();
          _this = _super.call(this, hash, password, verify) || this;
          _this.reset();
          if (verify !== void 0) {
            _this._hmac_init_verify(verify);
          } else {
            _this.verify = null;
          }
          return _this;
        }
        HmacSha2562.prototype.reset = function() {
          var key = this.key;
          this.hash.reset().asm.hmac_init(key[0] << 24 | key[1] << 16 | key[2] << 8 | key[3], key[4] << 24 | key[5] << 16 | key[6] << 8 | key[7], key[8] << 24 | key[9] << 16 | key[10] << 8 | key[11], key[12] << 24 | key[13] << 16 | key[14] << 8 | key[15], key[16] << 24 | key[17] << 16 | key[18] << 8 | key[19], key[20] << 24 | key[21] << 16 | key[22] << 8 | key[23], key[24] << 24 | key[25] << 16 | key[26] << 8 | key[27], key[28] << 24 | key[29] << 16 | key[30] << 8 | key[31], key[32] << 24 | key[33] << 16 | key[34] << 8 | key[35], key[36] << 24 | key[37] << 16 | key[38] << 8 | key[39], key[40] << 24 | key[41] << 16 | key[42] << 8 | key[43], key[44] << 24 | key[45] << 16 | key[46] << 8 | key[47], key[48] << 24 | key[49] << 16 | key[50] << 8 | key[51], key[52] << 24 | key[53] << 16 | key[54] << 8 | key[55], key[56] << 24 | key[57] << 16 | key[58] << 8 | key[59], key[60] << 24 | key[61] << 16 | key[62] << 8 | key[63]);
          return this;
        };
        HmacSha2562.prototype.finish = function() {
          if (this.key === null)
            throw new IllegalStateError("no key is associated with the instance");
          if (this.result !== null)
            throw new IllegalStateError("state must be reset before processing new data");
          var hash = this.hash;
          var asm = this.hash.asm;
          var heap = this.hash.heap;
          asm.hmac_finish(hash.pos, hash.len, 0);
          var verify = this.verify;
          var result = new Uint8Array(_sha256_hash_size);
          result.set(heap.subarray(0, _sha256_hash_size));
          if (verify) {
            if (verify.length === result.length) {
              var diff = 0;
              for (var i = 0; i < verify.length; i++) {
                diff |= verify[i] ^ result[i];
              }
              if (diff !== 0)
                throw new Error("HMAC verification failed, hash value doesn't match");
            } else {
              throw new Error("HMAC verification failed, lengths doesn't match");
            }
          } else {
            this.result = result;
          }
          return this;
        };
        return HmacSha2562;
      }(Hmac);
      var __extends$e = function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var HmacSha512 = function(_super) {
        __extends$e(HmacSha5122, _super);
        function HmacSha5122(password, verify) {
          var _this = this;
          var hash = new Sha512();
          _this = _super.call(this, hash, password, verify) || this;
          _this.reset();
          if (verify !== void 0) {
            _this._hmac_init_verify(verify);
          } else {
            _this.verify = null;
          }
          return _this;
        }
        HmacSha5122.prototype.reset = function() {
          var key = this.key;
          this.hash.reset().asm.hmac_init(key[0] << 24 | key[1] << 16 | key[2] << 8 | key[3], key[4] << 24 | key[5] << 16 | key[6] << 8 | key[7], key[8] << 24 | key[9] << 16 | key[10] << 8 | key[11], key[12] << 24 | key[13] << 16 | key[14] << 8 | key[15], key[16] << 24 | key[17] << 16 | key[18] << 8 | key[19], key[20] << 24 | key[21] << 16 | key[22] << 8 | key[23], key[24] << 24 | key[25] << 16 | key[26] << 8 | key[27], key[28] << 24 | key[29] << 16 | key[30] << 8 | key[31], key[32] << 24 | key[33] << 16 | key[34] << 8 | key[35], key[36] << 24 | key[37] << 16 | key[38] << 8 | key[39], key[40] << 24 | key[41] << 16 | key[42] << 8 | key[43], key[44] << 24 | key[45] << 16 | key[46] << 8 | key[47], key[48] << 24 | key[49] << 16 | key[50] << 8 | key[51], key[52] << 24 | key[53] << 16 | key[54] << 8 | key[55], key[56] << 24 | key[57] << 16 | key[58] << 8 | key[59], key[60] << 24 | key[61] << 16 | key[62] << 8 | key[63], key[64] << 24 | key[65] << 16 | key[66] << 8 | key[67], key[68] << 24 | key[69] << 16 | key[70] << 8 | key[71], key[72] << 24 | key[73] << 16 | key[74] << 8 | key[75], key[76] << 24 | key[77] << 16 | key[78] << 8 | key[79], key[80] << 24 | key[81] << 16 | key[82] << 8 | key[83], key[84] << 24 | key[85] << 16 | key[86] << 8 | key[87], key[88] << 24 | key[89] << 16 | key[90] << 8 | key[91], key[92] << 24 | key[93] << 16 | key[94] << 8 | key[95], key[96] << 24 | key[97] << 16 | key[98] << 8 | key[99], key[100] << 24 | key[101] << 16 | key[102] << 8 | key[103], key[104] << 24 | key[105] << 16 | key[106] << 8 | key[107], key[108] << 24 | key[109] << 16 | key[110] << 8 | key[111], key[112] << 24 | key[113] << 16 | key[114] << 8 | key[115], key[116] << 24 | key[117] << 16 | key[118] << 8 | key[119], key[120] << 24 | key[121] << 16 | key[122] << 8 | key[123], key[124] << 24 | key[125] << 16 | key[126] << 8 | key[127]);
          return this;
        };
        HmacSha5122.prototype.finish = function() {
          if (this.key === null)
            throw new IllegalStateError("no key is associated with the instance");
          if (this.result !== null)
            throw new IllegalStateError("state must be reset before processing new data");
          var hash = this.hash;
          var asm = this.hash.asm;
          var heap = this.hash.heap;
          asm.hmac_finish(hash.pos, hash.len, 0);
          var verify = this.verify;
          var result = new Uint8Array(_sha512_hash_size);
          result.set(heap.subarray(0, _sha512_hash_size));
          if (verify) {
            if (verify.length === result.length) {
              var diff = 0;
              for (var i = 0; i < verify.length; i++) {
                diff |= verify[i] ^ result[i];
              }
              if (diff !== 0)
                throw new Error("HMAC verification failed, hash value doesn't match");
            } else {
              throw new Error("HMAC verification failed, lengths doesn't match");
            }
          } else {
            this.result = result;
          }
          return this;
        };
        return HmacSha5122;
      }(Hmac);
      function Pbkdf2HmacSha1(password, salt, count, length) {
        var hmac = new HmacSha1(password);
        var result = new Uint8Array(length);
        var blocks = Math.ceil(length / hmac.HMAC_SIZE);
        for (var i = 1; i <= blocks; ++i) {
          var j = (i - 1) * hmac.HMAC_SIZE;
          var l = (i < blocks ? 0 : length % hmac.HMAC_SIZE) || hmac.HMAC_SIZE;
          hmac.reset().process(salt);
          hmac.hash.asm.pbkdf2_generate_block(hmac.hash.pos, hmac.hash.len, i, count, 0);
          result.set(hmac.hash.heap.subarray(0, l), j);
        }
        return result;
      }
      function Pbkdf2HmacSha256(password, salt, count, length) {
        var hmac = new HmacSha256(password);
        var result = new Uint8Array(length);
        var blocks = Math.ceil(length / hmac.HMAC_SIZE);
        for (var i = 1; i <= blocks; ++i) {
          var j = (i - 1) * hmac.HMAC_SIZE;
          var l = (i < blocks ? 0 : length % hmac.HMAC_SIZE) || hmac.HMAC_SIZE;
          hmac.reset().process(salt);
          hmac.hash.asm.pbkdf2_generate_block(hmac.hash.pos, hmac.hash.len, i, count, 0);
          result.set(hmac.hash.heap.subarray(0, l), j);
        }
        return result;
      }
      function Pbkdf2HmacSha512(password, salt, count, length) {
        var hmac = new HmacSha512(password);
        var result = new Uint8Array(length);
        var blocks = Math.ceil(length / hmac.HMAC_SIZE);
        for (var i = 1; i <= blocks; ++i) {
          var j = (i - 1) * hmac.HMAC_SIZE;
          var l = (i < blocks ? 0 : length % hmac.HMAC_SIZE) || hmac.HMAC_SIZE;
          hmac.reset().process(salt);
          hmac.hash.asm.pbkdf2_generate_block(hmac.hash.pos, hmac.hash.len, i, count, 0);
          result.set(hmac.hash.heap.subarray(0, l), j);
        }
        return result;
      }
      var RSA = function() {
        function RSA2(key) {
          var l = key.length;
          if (l !== 2 && l !== 3 && l !== 8)
            throw new SyntaxError("unexpected key type");
          var k0 = new Modulus(new BigNumber(key[0]));
          var k1 = new BigNumber(key[1]);
          this.key = {
            0: k0,
            1: k1
          };
          if (l > 2) {
            this.key[2] = new BigNumber(key[2]);
          }
          if (l > 3) {
            this.key[3] = new Modulus(new BigNumber(key[3]));
            this.key[4] = new Modulus(new BigNumber(key[4]));
            this.key[5] = new BigNumber(key[5]);
            this.key[6] = new BigNumber(key[6]);
            this.key[7] = new BigNumber(key[7]);
          }
        }
        RSA2.prototype.encrypt = function(msg) {
          if (!this.key)
            throw new IllegalStateError("no key is associated with the instance");
          if (this.key[0].compare(msg) <= 0)
            throw new RangeError("data too large");
          var m = this.key[0];
          var e = this.key[1];
          var result = m.power(msg, e).toBytes();
          var bytelen = m.bitLength + 7 >> 3;
          if (result.length < bytelen) {
            var r = new Uint8Array(bytelen);
            r.set(result, bytelen - result.length);
            result = r;
          }
          this.result = result;
          return this;
        };
        RSA2.prototype.decrypt = function(msg) {
          if (this.key[0].compare(msg) <= 0)
            throw new RangeError("data too large");
          var result;
          var m;
          if (this.key[3] !== void 0) {
            m = this.key[0];
            var p = this.key[3];
            var q = this.key[4];
            var dp = this.key[5];
            var dq = this.key[6];
            var u = this.key[7];
            var x = p.power(msg, dp);
            var y = q.power(msg, dq);
            var t = x.subtract(y);
            while (t.sign < 0)
              t = t.add(p);
            var h = p.reduce(u.multiply(t));
            result = h.multiply(q).add(y).clamp(m.bitLength).toBytes();
          } else {
            m = this.key[0];
            var d = this.key[2];
            result = m.power(msg, d).toBytes();
          }
          var bytelen = m.bitLength + 7 >> 3;
          if (result.length < bytelen) {
            var r = new Uint8Array(bytelen);
            r.set(result, bytelen - result.length);
            result = r;
          }
          this.result = result;
          return this;
        };
        return RSA2;
      }();
      var RSA_OAEP = function() {
        function RSA_OAEP2(key, hash, label) {
          this.rsa = new RSA(key);
          this.hash = hash;
          if (label !== void 0) {
            this.label = label.length > 0 ? label : null;
          } else {
            this.label = null;
          }
        }
        RSA_OAEP2.prototype.encrypt = function(data, random) {
          var key_size = Math.ceil(this.rsa.key[0].bitLength / 8);
          var hash_size = this.hash.HASH_SIZE;
          var data_length = data.byteLength || data.length || 0;
          var ps_length = key_size - data_length - 2 * hash_size - 2;
          if (data_length > key_size - 2 * this.hash.HASH_SIZE - 2)
            throw new IllegalArgumentError("data too large");
          var message = new Uint8Array(key_size);
          var seed = message.subarray(1, hash_size + 1);
          var data_block = message.subarray(hash_size + 1);
          data_block.set(data, hash_size + ps_length + 1);
          data_block.set(this.hash.process(this.label || new Uint8Array(0)).finish().result, 0);
          data_block[hash_size + ps_length] = 1;
          if (random !== void 0) {
            if (seed.length !== random.length)
              throw new IllegalArgumentError("random size must equal the hash size");
            seed.set(random);
          } else {
            getRandomValues2(seed);
          }
          var data_block_mask = this.RSA_MGF1_generate(seed, data_block.length);
          for (var i = 0; i < data_block.length; i++)
            data_block[i] ^= data_block_mask[i];
          var seed_mask = this.RSA_MGF1_generate(data_block, seed.length);
          for (var i = 0; i < seed.length; i++)
            seed[i] ^= seed_mask[i];
          this.rsa.encrypt(new BigNumber(message));
          return new Uint8Array(this.rsa.result);
        };
        RSA_OAEP2.prototype.decrypt = function(data) {
          if (!this.rsa.key)
            throw new IllegalStateError("no key is associated with the instance");
          var key_size = Math.ceil(this.rsa.key[0].bitLength / 8);
          var hash_size = this.hash.HASH_SIZE;
          var data_length = data.byteLength || data.length || 0;
          if (data_length !== key_size)
            throw new IllegalArgumentError("bad data");
          this.rsa.decrypt(new BigNumber(data));
          var z = this.rsa.result[0];
          var seed = this.rsa.result.subarray(1, hash_size + 1);
          var data_block = this.rsa.result.subarray(hash_size + 1);
          if (z !== 0)
            throw new SecurityError("decryption failed");
          var seed_mask = this.RSA_MGF1_generate(data_block, seed.length);
          for (var i = 0; i < seed.length; i++)
            seed[i] ^= seed_mask[i];
          var data_block_mask = this.RSA_MGF1_generate(seed, data_block.length);
          for (var i = 0; i < data_block.length; i++)
            data_block[i] ^= data_block_mask[i];
          var lhash = this.hash.reset().process(this.label || new Uint8Array(0)).finish().result;
          for (var i = 0; i < hash_size; i++) {
            if (lhash[i] !== data_block[i])
              throw new SecurityError("decryption failed");
          }
          var ps_end = hash_size;
          for (; ps_end < data_block.length; ps_end++) {
            var psz = data_block[ps_end];
            if (psz === 1)
              break;
            if (psz !== 0)
              throw new SecurityError("decryption failed");
          }
          if (ps_end === data_block.length)
            throw new SecurityError("decryption failed");
          this.rsa.result = data_block.subarray(ps_end + 1);
          return new Uint8Array(this.rsa.result);
        };
        RSA_OAEP2.prototype.RSA_MGF1_generate = function(seed, length) {
          if (length === void 0) {
            length = 0;
          }
          var hash_size = this.hash.HASH_SIZE;
          var mask = new Uint8Array(length);
          var counter = new Uint8Array(4);
          var chunks = Math.ceil(length / hash_size);
          for (var i = 0; i < chunks; i++) {
            counter[0] = i >>> 24, counter[1] = i >>> 16 & 255, counter[2] = i >>> 8 & 255, counter[3] = i & 255;
            var submask = mask.subarray(i * hash_size);
            var chunk = this.hash.reset().process(seed).process(counter).finish().result;
            if (chunk.length > submask.length)
              chunk = chunk.subarray(0, submask.length);
            submask.set(chunk);
          }
          return mask;
        };
        return RSA_OAEP2;
      }();
      var RSA_PSS = function() {
        function RSA_PSS2(key, hash, saltLength) {
          if (saltLength === void 0) {
            saltLength = 4;
          }
          this.rsa = new RSA(key);
          this.hash = hash;
          this.saltLength = saltLength;
          if (this.saltLength < 0)
            throw new TypeError("saltLength should be a non-negative number");
          if (this.rsa.key !== null && Math.ceil((this.rsa.key[0].bitLength - 1) / 8) < this.hash.HASH_SIZE + this.saltLength + 2)
            throw new SyntaxError("saltLength is too large");
        }
        RSA_PSS2.prototype.sign = function(data, random) {
          var key_bits = this.rsa.key[0].bitLength;
          var hash_size = this.hash.HASH_SIZE;
          var message_length = Math.ceil((key_bits - 1) / 8);
          var salt_length = this.saltLength;
          var ps_length = message_length - salt_length - hash_size - 2;
          var message = new Uint8Array(message_length);
          var h_block = message.subarray(message_length - hash_size - 1, message_length - 1);
          var d_block = message.subarray(0, message_length - hash_size - 1);
          var d_salt = d_block.subarray(ps_length + 1);
          var m_block = new Uint8Array(8 + hash_size + salt_length);
          var m_hash = m_block.subarray(8, 8 + hash_size);
          var m_salt = m_block.subarray(8 + hash_size);
          m_hash.set(this.hash.process(data).finish().result);
          if (salt_length > 0) {
            if (random !== void 0) {
              if (m_salt.length !== random.length)
                throw new IllegalArgumentError("random size must equal the salt size");
              m_salt.set(random);
            } else {
              getRandomValues2(m_salt);
            }
          }
          d_block[ps_length] = 1;
          d_salt.set(m_salt);
          h_block.set(this.hash.reset().process(m_block).finish().result);
          var d_block_mask = this.RSA_MGF1_generate(h_block, d_block.length);
          for (var i = 0; i < d_block.length; i++)
            d_block[i] ^= d_block_mask[i];
          message[message_length - 1] = 188;
          var zbits = 8 * message_length - key_bits + 1;
          if (zbits % 8)
            message[0] &= 255 >>> zbits;
          this.rsa.decrypt(new BigNumber(message));
          return this.rsa.result;
        };
        RSA_PSS2.prototype.verify = function(signature, data) {
          var key_bits = this.rsa.key[0].bitLength;
          var hash_size = this.hash.HASH_SIZE;
          var message_length = Math.ceil((key_bits - 1) / 8);
          var salt_length = this.saltLength;
          var ps_length = message_length - salt_length - hash_size - 2;
          this.rsa.encrypt(new BigNumber(signature));
          var message = this.rsa.result;
          if (message[message_length - 1] !== 188)
            throw new SecurityError("bad signature");
          var h_block = message.subarray(message_length - hash_size - 1, message_length - 1);
          var d_block = message.subarray(0, message_length - hash_size - 1);
          var d_salt = d_block.subarray(ps_length + 1);
          var zbits = 8 * message_length - key_bits + 1;
          if (zbits % 8 && message[0] >>> 8 - zbits)
            throw new SecurityError("bad signature");
          var d_block_mask = this.RSA_MGF1_generate(h_block, d_block.length);
          for (var i = 0; i < d_block.length; i++)
            d_block[i] ^= d_block_mask[i];
          if (zbits % 8)
            message[0] &= 255 >>> zbits;
          for (var i = 0; i < ps_length; i++) {
            if (d_block[i] !== 0)
              throw new SecurityError("bad signature");
          }
          if (d_block[ps_length] !== 1)
            throw new SecurityError("bad signature");
          var m_block = new Uint8Array(8 + hash_size + salt_length);
          var m_hash = m_block.subarray(8, 8 + hash_size);
          var m_salt = m_block.subarray(8 + hash_size);
          m_hash.set(this.hash.reset().process(data).finish().result);
          m_salt.set(d_salt);
          var h_block_verify = this.hash.reset().process(m_block).finish().result;
          for (var i = 0; i < hash_size; i++) {
            if (h_block[i] !== h_block_verify[i])
              throw new SecurityError("bad signature");
          }
        };
        RSA_PSS2.prototype.RSA_MGF1_generate = function(seed, length) {
          if (length === void 0) {
            length = 0;
          }
          var hash_size = this.hash.HASH_SIZE;
          var mask = new Uint8Array(length);
          var counter = new Uint8Array(4);
          var chunks = Math.ceil(length / hash_size);
          for (var i = 0; i < chunks; i++) {
            counter[0] = i >>> 24, counter[1] = i >>> 16 & 255, counter[2] = i >>> 8 & 255, counter[3] = i & 255;
            var submask = mask.subarray(i * hash_size);
            var chunk = this.hash.reset().process(seed).process(counter).finish().result;
            if (chunk.length > submask.length)
              chunk = chunk.subarray(0, submask.length);
            submask.set(chunk);
          }
          return mask;
        };
        return RSA_PSS2;
      }();
      var RSA_PKCS1_v1_5 = function() {
        function RSA_PKCS1_v1_52(key, hash) {
          this.rsa = new RSA(key);
          this.hash = hash;
        }
        RSA_PKCS1_v1_52.prototype.sign = function(data) {
          if (!this.rsa.key) {
            throw new IllegalStateError("no key is associated with the instance");
          }
          var prefix = getHashPrefix(this.hash);
          var hash_size = this.hash.HASH_SIZE;
          var t_len = prefix.length + hash_size;
          var k = this.rsa.key[0].bitLength + 7 >> 3;
          if (k < t_len + 11) {
            throw new Error("Message too long");
          }
          var m_hash = new Uint8Array(hash_size);
          m_hash.set(this.hash.process(data).finish().result);
          var em = new Uint8Array(k);
          var i = 0;
          em[i++] = 0;
          em[i++] = 1;
          for (i; i < k - t_len - 1; i++) {
            em[i] = 255;
          }
          em[i++] = 0;
          em.set(prefix, i);
          em.set(m_hash, em.length - hash_size);
          this.rsa.decrypt(new BigNumber(em));
          return this.rsa.result;
        };
        RSA_PKCS1_v1_52.prototype.verify = function(signature, data) {
          var prefix = getHashPrefix(this.hash);
          var hash_size = this.hash.HASH_SIZE;
          var t_len = prefix.length + hash_size;
          var k = this.rsa.key[0].bitLength + 7 >> 3;
          if (k < t_len + 11) {
            throw new SecurityError("Bad signature");
          }
          this.rsa.encrypt(new BigNumber(signature));
          var m_hash = new Uint8Array(hash_size);
          m_hash.set(this.hash.process(data).finish().result);
          var res = 1;
          var decryptedSignature = this.rsa.result;
          var i = 0;
          res &= decryptedSignature[i++] === 0 ? 1 : 0;
          res &= decryptedSignature[i++] === 1 ? 1 : 0;
          for (i; i < k - t_len - 1; i++) {
            res &= decryptedSignature[i] === 255 ? 1 : 0;
          }
          res &= decryptedSignature[i++] === 0 ? 1 : 0;
          var j = 0;
          var n = i + prefix.length;
          for (i; i < n; i++) {
            res &= decryptedSignature[i] === prefix[j++] ? 1 : 0;
          }
          j = 0;
          n = i + m_hash.length;
          for (i; i < n; i++) {
            res &= decryptedSignature[i] === m_hash[j++] ? 1 : 0;
          }
          if (!res) {
            throw new SecurityError("Bad signature");
          }
        };
        return RSA_PKCS1_v1_52;
      }();
      var HASH_PREFIXES = {
        sha1: new Uint8Array([48, 33, 48, 9, 6, 5, 43, 14, 3, 2, 26, 5, 0, 4, 20]),
        sha256: new Uint8Array([
          48,
          49,
          48,
          13,
          6,
          9,
          96,
          134,
          72,
          1,
          101,
          3,
          4,
          2,
          1,
          5,
          0,
          4,
          32
        ]),
        sha384: new Uint8Array([
          48,
          65,
          48,
          13,
          6,
          9,
          96,
          134,
          72,
          1,
          101,
          3,
          4,
          2,
          2,
          5,
          0,
          4,
          48
        ]),
        sha512: new Uint8Array([
          48,
          81,
          48,
          13,
          6,
          9,
          96,
          134,
          72,
          1,
          101,
          3,
          4,
          2,
          3,
          5,
          0,
          4,
          64
        ])
      };
      function getHashPrefix(hash) {
        var prefix = HASH_PREFIXES[hash.NAME];
        if (!prefix) {
          throw new Error("Cannot get hash prefix for hash algorithm '" + hash.NAME + "'");
        }
        return prefix;
      }
      exports.string_to_bytes = string_to_bytes;
      exports.hex_to_bytes = hex_to_bytes;
      exports.base64_to_bytes = base64_to_bytes;
      exports.bytes_to_string = bytes_to_string;
      exports.bytes_to_hex = bytes_to_hex;
      exports.bytes_to_base64 = bytes_to_base64;
      exports.IllegalStateError = IllegalStateError;
      exports.IllegalArgumentError = IllegalArgumentError;
      exports.SecurityError = SecurityError;
      exports.AES_CBC = AES_CBC;
      exports.AES_CCM = AES_CCM;
      exports.AES_CFB = AES_CFB;
      exports.AES_CMAC = AES_CMAC;
      exports.AES_CTR = AES_CTR;
      exports.AES_ECB = AES_ECB;
      exports.AES_GCM = AES_GCM;
      exports.AES_OFB = AES_OFB;
      exports.BigNumber = BigNumber;
      exports.Modulus = Modulus;
      exports.Sha1 = Sha1;
      exports.Sha256 = Sha256;
      exports.Sha512 = Sha512;
      exports.HmacSha1 = HmacSha1;
      exports.HmacSha256 = HmacSha256;
      exports.HmacSha512 = HmacSha512;
      exports.Pbkdf2HmacSha1 = Pbkdf2HmacSha1;
      exports.Pbkdf2HmacSha256 = Pbkdf2HmacSha256;
      exports.Pbkdf2HmacSha512 = Pbkdf2HmacSha512;
      exports.RSA_OAEP = RSA_OAEP;
      exports.RSA_PKCS1_v1_5 = RSA_PKCS1_v1_5;
      exports.RSA_PSS = RSA_PSS;
      exports.RSA = RSA;
    }
  });

  // node_modules/uuid/dist/esm-browser/rng.js
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var getRandomValues, rnds8;
  var init_rng = __esm({
    "node_modules/uuid/dist/esm-browser/rng.js"() {
      rnds8 = new Uint8Array(16);
    }
  });

  // node_modules/uuid/dist/esm-browser/regex.js
  var regex_default;
  var init_regex = __esm({
    "node_modules/uuid/dist/esm-browser/regex.js"() {
      regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    }
  });

  // node_modules/uuid/dist/esm-browser/validate.js
  function validate(uuid) {
    return typeof uuid === "string" && regex_default.test(uuid);
  }
  var validate_default;
  var init_validate = __esm({
    "node_modules/uuid/dist/esm-browser/validate.js"() {
      init_regex();
      validate_default = validate;
    }
  });

  // node_modules/uuid/dist/esm-browser/stringify.js
  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate_default(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var byteToHex, stringify_default;
  var init_stringify = __esm({
    "node_modules/uuid/dist/esm-browser/stringify.js"() {
      init_validate();
      byteToHex = [];
      for (var i = 0; i < 256; ++i) {
        byteToHex.push((i + 256).toString(16).substr(1));
      }
      stringify_default = stringify;
    }
  });

  // node_modules/uuid/dist/esm-browser/v1.js
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || new Array(16);
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = options.random || (options.rng || rng)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || stringify_default(b);
  }
  var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
  var init_v1 = __esm({
    "node_modules/uuid/dist/esm-browser/v1.js"() {
      init_rng();
      init_stringify();
      _lastMSecs = 0;
      _lastNSecs = 0;
      v1_default = v1;
    }
  });

  // node_modules/uuid/dist/esm-browser/parse.js
  function parse(uuid) {
    if (!validate_default(uuid)) {
      throw TypeError("Invalid UUID");
    }
    var v;
    var arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var parse_default;
  var init_parse = __esm({
    "node_modules/uuid/dist/esm-browser/parse.js"() {
      init_validate();
      parse_default = parse;
    }
  });

  // node_modules/uuid/dist/esm-browser/v35.js
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    var bytes = [];
    for (var i = 0; i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  function v35_default(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = parse_default(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      var bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return stringify_default(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
  }
  var DNS, URL;
  var init_v35 = __esm({
    "node_modules/uuid/dist/esm-browser/v35.js"() {
      init_stringify();
      init_parse();
      DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    }
  });

  // node_modules/uuid/dist/esm-browser/md5.js
  function md5(bytes) {
    if (typeof bytes === "string") {
      var msg = unescape(encodeURIComponent(bytes));
      bytes = new Uint8Array(msg.length);
      for (var i = 0; i < msg.length; ++i) {
        bytes[i] = msg.charCodeAt(i);
      }
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
  }
  function md5ToHexEncodedArray(input) {
    var output = [];
    var length32 = input.length * 32;
    var hexTab = "0123456789abcdef";
    for (var i = 0; i < length32; i += 8) {
      var x = input[i >> 5] >>> i % 32 & 255;
      var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
      output.push(hex);
    }
    return output;
  }
  function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
  }
  function wordsToMd5(x, len) {
    x[len >> 5] |= 128 << len % 32;
    x[getOutputLength(len) - 1] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for (var i = 0; i < x.length; i += 16) {
      var olda = a;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      a = md5ff(a, b, c, d, x[i], 7, -680876936);
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5gg(b, c, d, a, x[i], 20, -373897302);
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5hh(d, a, b, c, x[i], 11, -358537222);
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5ii(a, b, c, d, x[i], 6, -198630844);
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safeAdd(a, olda);
      b = safeAdd(b, oldb);
      c = safeAdd(c, oldc);
      d = safeAdd(d, oldd);
    }
    return [a, b, c, d];
  }
  function bytesToWords(input) {
    if (input.length === 0) {
      return [];
    }
    var length8 = input.length * 8;
    var output = new Uint32Array(getOutputLength(length8));
    for (var i = 0; i < length8; i += 8) {
      output[i >> 5] |= (input[i / 8] & 255) << i % 32;
    }
    return output;
  }
  function safeAdd(x, y) {
    var lsw = (x & 65535) + (y & 65535);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
  function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }
  function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
  }
  function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
  }
  function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
  }
  function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
  }
  function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  var md5_default;
  var init_md5 = __esm({
    "node_modules/uuid/dist/esm-browser/md5.js"() {
      md5_default = md5;
    }
  });

  // node_modules/uuid/dist/esm-browser/v3.js
  var v3, v3_default;
  var init_v3 = __esm({
    "node_modules/uuid/dist/esm-browser/v3.js"() {
      init_v35();
      init_md5();
      v3 = v35_default("v3", 48, md5_default);
      v3_default = v3;
    }
  });

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return stringify_default(rnds);
  }
  var v4_default;
  var init_v4 = __esm({
    "node_modules/uuid/dist/esm-browser/v4.js"() {
      init_rng();
      init_stringify();
      v4_default = v4;
    }
  });

  // node_modules/uuid/dist/esm-browser/sha1.js
  function f(s, x, y, z) {
    switch (s) {
      case 0:
        return x & y ^ ~x & z;
      case 1:
        return x ^ y ^ z;
      case 2:
        return x & y ^ x & z ^ y & z;
      case 3:
        return x ^ y ^ z;
    }
  }
  function ROTL(x, n) {
    return x << n | x >>> 32 - n;
  }
  function sha1(bytes) {
    var K = [1518500249, 1859775393, 2400959708, 3395469782];
    var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof bytes === "string") {
      var msg = unescape(encodeURIComponent(bytes));
      bytes = [];
      for (var i = 0; i < msg.length; ++i) {
        bytes.push(msg.charCodeAt(i));
      }
    } else if (!Array.isArray(bytes)) {
      bytes = Array.prototype.slice.call(bytes);
    }
    bytes.push(128);
    var l = bytes.length / 4 + 2;
    var N = Math.ceil(l / 16);
    var M = new Array(N);
    for (var _i = 0; _i < N; ++_i) {
      var arr = new Uint32Array(16);
      for (var j = 0; j < 16; ++j) {
        arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
      }
      M[_i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
    for (var _i2 = 0; _i2 < N; ++_i2) {
      var W = new Uint32Array(80);
      for (var t = 0; t < 16; ++t) {
        W[t] = M[_i2][t];
      }
      for (var _t = 16; _t < 80; ++_t) {
        W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
      }
      var a = H[0];
      var b = H[1];
      var c = H[2];
      var d = H[3];
      var e = H[4];
      for (var _t2 = 0; _t2 < 80; ++_t2) {
        var s = Math.floor(_t2 / 20);
        var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
        e = d;
        d = c;
        c = ROTL(b, 30) >>> 0;
        b = a;
        a = T;
      }
      H[0] = H[0] + a >>> 0;
      H[1] = H[1] + b >>> 0;
      H[2] = H[2] + c >>> 0;
      H[3] = H[3] + d >>> 0;
      H[4] = H[4] + e >>> 0;
    }
    return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
  }
  var sha1_default;
  var init_sha1 = __esm({
    "node_modules/uuid/dist/esm-browser/sha1.js"() {
      sha1_default = sha1;
    }
  });

  // node_modules/uuid/dist/esm-browser/v5.js
  var v5, v5_default;
  var init_v5 = __esm({
    "node_modules/uuid/dist/esm-browser/v5.js"() {
      init_v35();
      init_sha1();
      v5 = v35_default("v5", 80, sha1_default);
      v5_default = v5;
    }
  });

  // node_modules/uuid/dist/esm-browser/nil.js
  var nil_default;
  var init_nil = __esm({
    "node_modules/uuid/dist/esm-browser/nil.js"() {
      nil_default = "00000000-0000-0000-0000-000000000000";
    }
  });

  // node_modules/uuid/dist/esm-browser/version.js
  function version(uuid) {
    if (!validate_default(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  }
  var version_default;
  var init_version = __esm({
    "node_modules/uuid/dist/esm-browser/version.js"() {
      init_validate();
      version_default = version;
    }
  });

  // node_modules/uuid/dist/esm-browser/index.js
  var esm_browser_exports = {};
  __export(esm_browser_exports, {
    NIL: () => nil_default,
    parse: () => parse_default,
    stringify: () => stringify_default,
    v1: () => v1_default,
    v3: () => v3_default,
    v4: () => v4_default,
    v5: () => v5_default,
    validate: () => validate_default,
    version: () => version_default
  });
  var init_esm_browser = __esm({
    "node_modules/uuid/dist/esm-browser/index.js"() {
      init_v1();
      init_v3();
      init_v4();
      init_v5();
      init_nil();
      init_version();
      init_validate();
      init_stringify();
      init_parse();
    }
  });

  // node_modules/isomorphic-ws/browser.js
  var require_browser = __commonJS({
    "node_modules/isomorphic-ws/browser.js"(exports, module) {
      var ws = null;
      if (typeof WebSocket !== "undefined") {
        ws = WebSocket;
      } else if (typeof MozWebSocket !== "undefined") {
        ws = MozWebSocket;
      } else if (typeof global !== "undefined") {
        ws = global.WebSocket || global.MozWebSocket;
      } else if (typeof window !== "undefined") {
        ws = window.WebSocket || window.MozWebSocket;
      } else if (typeof self !== "undefined") {
        ws = self.WebSocket || self.MozWebSocket;
      }
      module.exports = ws;
    }
  });

  // node_modules/anchor-link/lib/anchor-link.js
  var require_anchor_link = __commonJS({
    "node_modules/anchor-link/lib/anchor-link.js"(exports, module) {
      "use strict";
      var tslib = require_tslib();
      var zlib = require_pako();
      var eosio = require_eosio_core();
      var eosioSigningRequest = require_esr();
      var makeFetch = require_fetch_browser();
      var asmcrypto_js = require_asmcrypto_all();
      var uuid = (init_esm_browser(), esm_browser_exports);
      var WebSocket2 = require_browser();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      function _interopNamespace(e) {
        if (e && e.__esModule)
          return e;
        var n = Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                  return e[k];
                }
              });
            }
          });
        }
        n["default"] = e;
        return Object.freeze(n);
      }
      var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
      var eosio__namespace = /* @__PURE__ */ _interopNamespace(eosio);
      var eosioSigningRequest__namespace = /* @__PURE__ */ _interopNamespace(eosioSigningRequest);
      var makeFetch__default = /* @__PURE__ */ _interopDefaultLegacy(makeFetch);
      var WebSocket__default = /* @__PURE__ */ _interopDefaultLegacy(WebSocket2);
      var CancelError = function(_super) {
        tslib.__extends(CancelError2, _super);
        function CancelError2(reason) {
          var _this = _super.call(this, "User canceled request " + (reason ? "(" + reason + ")" : "")) || this;
          _this.code = "E_CANCEL";
          return _this;
        }
        return CancelError2;
      }(Error);
      var IdentityError = function(_super) {
        tslib.__extends(IdentityError2, _super);
        function IdentityError2(reason) {
          var _this = _super.call(this, "Unable to verify identity " + (reason ? "(" + reason + ")" : "")) || this;
          _this.code = "E_IDENTITY";
          return _this;
        }
        return IdentityError2;
      }(Error);
      var SessionError = function(_super) {
        tslib.__extends(SessionError2, _super);
        function SessionError2(reason, code) {
          var _this = _super.call(this, reason) || this;
          _this.code = code;
          return _this;
        }
        return SessionError2;
      }(Error);
      var LinkOptions;
      (function(LinkOptions2) {
        LinkOptions2.defaults = {
          service: "https://cb.anchor.link",
          verifyProofs: false,
          encodeChainIds: true
        };
      })(LinkOptions || (LinkOptions = {}));
      var SealedMessage = function(_super) {
        tslib.__extends(SealedMessage2, _super);
        function SealedMessage2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        tslib.__decorate([
          eosio.Struct.field("public_key")
        ], SealedMessage2.prototype, "from", void 0);
        tslib.__decorate([
          eosio.Struct.field("uint64")
        ], SealedMessage2.prototype, "nonce", void 0);
        tslib.__decorate([
          eosio.Struct.field("bytes")
        ], SealedMessage2.prototype, "ciphertext", void 0);
        tslib.__decorate([
          eosio.Struct.field("uint32")
        ], SealedMessage2.prototype, "checksum", void 0);
        SealedMessage2 = tslib.__decorate([
          eosio.Struct.type("sealed_message")
        ], SealedMessage2);
        return SealedMessage2;
      }(eosio.Struct);
      var LinkCreate = function(_super) {
        tslib.__extends(LinkCreate2, _super);
        function LinkCreate2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        tslib.__decorate([
          eosio.Struct.field("name")
        ], LinkCreate2.prototype, "session_name", void 0);
        tslib.__decorate([
          eosio.Struct.field("public_key")
        ], LinkCreate2.prototype, "request_key", void 0);
        tslib.__decorate([
          eosio.Struct.field("string", { extension: true })
        ], LinkCreate2.prototype, "user_agent", void 0);
        LinkCreate2 = tslib.__decorate([
          eosio.Struct.type("link_create")
        ], LinkCreate2);
        return LinkCreate2;
      }(eosio.Struct);
      var LinkInfo = function(_super) {
        tslib.__extends(LinkInfo2, _super);
        function LinkInfo2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        tslib.__decorate([
          eosio.Struct.field("time_point_sec")
        ], LinkInfo2.prototype, "expiration", void 0);
        LinkInfo2 = tslib.__decorate([
          eosio.Struct.type("link_info")
        ], LinkInfo2);
        return LinkInfo2;
      }(eosio.Struct);
      var fetch2 = makeFetch__default["default"]().fetch;
      function sealMessage(message, privateKey, publicKey, nonce) {
        var secret = privateKey.sharedSecret(publicKey);
        if (!nonce) {
          nonce = eosio.UInt64.random();
        }
        var key2 = eosio.Checksum512.hash(eosio.Serializer.encode({ object: nonce }).appending(secret.array));
        var cbc = new asmcrypto_js.AES_CBC(key2.array.slice(0, 32), key2.array.slice(32, 48));
        var ciphertext = eosio.Bytes.from(cbc.encrypt(eosio.Bytes.from(message, "utf8").array));
        var checksumView = new DataView(eosio.Checksum256.hash(key2.array).array.buffer);
        var checksum = checksumView.getUint32(0, true);
        return SealedMessage.from({
          from: privateKey.toPublic(),
          nonce,
          ciphertext,
          checksum
        });
      }
      var LinkSession = function() {
        function LinkSession2() {
        }
        LinkSession2.prototype.remove = function() {
          return tslib.__awaiter(this, void 0, void 0, function() {
            return tslib.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (!this.link.storage)
                    return [3, 2];
                  return [4, this.link.removeSession(this.identifier, this.auth, this.chainId)];
                case 1:
                  _a2.sent();
                  _a2.label = 2;
                case 2:
                  return [2];
              }
            });
          });
        };
        Object.defineProperty(LinkSession2.prototype, "client", {
          get: function() {
            return this.link.getChain(this.chainId).client;
          },
          enumerable: false,
          configurable: true
        });
        LinkSession2.restore = function(link, data) {
          switch (data.type) {
            case "channel":
              return new LinkChannelSession(link, data.data, data.metadata);
            case "fallback":
              return new LinkFallbackSession(link, data.data, data.metadata);
            default:
              throw new Error("Unable to restore, session data invalid");
          }
        };
        return LinkSession2;
      }();
      var LinkChannelSession = function(_super) {
        tslib.__extends(LinkChannelSession2, _super);
        function LinkChannelSession2(link, data, metadata) {
          var _this = _super.call(this) || this;
          _this.type = "channel";
          _this.timeout = 2 * 60 * 1e3;
          _this.link = link;
          _this.chainId = eosioSigningRequest.ChainId.from(data.chainId);
          _this.auth = eosio.PermissionLevel.from(data.auth);
          _this.publicKey = eosio.PublicKey.from(data.publicKey);
          _this.channel = data.channel;
          _this.identifier = eosio.Name.from(data.identifier);
          var privateKey = eosio.PrivateKey.from(data.requestKey);
          var publicKey = eosio.PublicKey.from(data.channel.key);
          _this.encrypt = function(request) {
            return sealMessage(request.encode(true, false), privateKey, publicKey);
          };
          _this.metadata = tslib.__assign(tslib.__assign({}, metadata || {}), { timeout: _this.timeout, name: _this.channel.name });
          _this.serialize = function() {
            return {
              type: "channel",
              data,
              metadata: _this.metadata
            };
          };
          return _this;
        }
        LinkChannelSession2.prototype.onSuccess = function(request, result) {
          if (this.link.transport.onSuccess) {
            this.link.transport.onSuccess(request, result);
          }
        };
        LinkChannelSession2.prototype.onFailure = function(request, error) {
          if (this.link.transport.onFailure) {
            this.link.transport.onFailure(request, error);
          }
        };
        LinkChannelSession2.prototype.onRequest = function(request, cancel) {
          var info = LinkInfo.from({
            expiration: new Date(Date.now() + this.timeout).toISOString().slice(0, -1)
          });
          if (this.link.transport.onSessionRequest) {
            this.link.transport.onSessionRequest(this, request, cancel);
          }
          setTimeout(function() {
            cancel(new SessionError("Wallet did not respond in time", "E_TIMEOUT"));
          }, this.timeout + 500);
          request.setInfoKey("link", info);
          var payloadSent = false;
          var payload = eosio.Serializer.encode({ object: this.encrypt(request) });
          if (this.link.transport.sendSessionPayload) {
            try {
              payloadSent = this.link.transport.sendSessionPayload(payload, this);
            } catch (error) {
              console.warn("Unexpected error when transport tried to send session payload", error);
            }
          }
          if (payloadSent) {
            return;
          }
          fetch2(this.channel.url, {
            method: "POST",
            headers: {
              "X-Buoy-Wait": (this.timeout / 1e3).toFixed(0)
            },
            body: payload.array
          }).then(function(response) {
            if (response.status !== 200) {
              cancel(new SessionError("Unable to push message", "E_DELIVERY"));
            }
          }).catch(function(error) {
            cancel(new SessionError("Unable to reach link service (" + (error.message || String(error)) + ")", "E_DELIVERY"));
          });
        };
        LinkChannelSession2.prototype.prepare = function(request) {
          if (this.link.transport.prepare) {
            return this.link.transport.prepare(request, this);
          }
          return Promise.resolve(request);
        };
        LinkChannelSession2.prototype.showLoading = function() {
          if (this.link.transport.showLoading) {
            return this.link.transport.showLoading();
          }
        };
        LinkChannelSession2.prototype.makeSignatureProvider = function() {
          return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);
        };
        LinkChannelSession2.prototype.transact = function(args, options) {
          return this.link.transact(args, tslib.__assign(tslib.__assign({}, options), { chain: this.chainId }), this);
        };
        return LinkChannelSession2;
      }(LinkSession);
      var LinkFallbackSession = function(_super) {
        tslib.__extends(LinkFallbackSession2, _super);
        function LinkFallbackSession2(link, data, metadata) {
          var _this = _super.call(this) || this;
          _this.type = "fallback";
          _this.link = link;
          _this.auth = eosio.PermissionLevel.from(data.auth);
          _this.publicKey = eosio.PublicKey.from(data.publicKey);
          _this.chainId = eosioSigningRequest.ChainId.from(data.chainId);
          _this.metadata = metadata || {};
          _this.identifier = eosio.Name.from(data.identifier);
          _this.serialize = function() {
            return {
              type: _this.type,
              data,
              metadata: _this.metadata
            };
          };
          return _this;
        }
        LinkFallbackSession2.prototype.onSuccess = function(request, result) {
          if (this.link.transport.onSuccess) {
            this.link.transport.onSuccess(request, result);
          }
        };
        LinkFallbackSession2.prototype.onFailure = function(request, error) {
          if (this.link.transport.onFailure) {
            this.link.transport.onFailure(request, error);
          }
        };
        LinkFallbackSession2.prototype.onRequest = function(request, cancel) {
          if (this.link.transport.onSessionRequest) {
            this.link.transport.onSessionRequest(this, request, cancel);
          } else {
            this.link.transport.onRequest(request, cancel);
          }
        };
        LinkFallbackSession2.prototype.prepare = function(request) {
          if (this.link.transport.prepare) {
            return this.link.transport.prepare(request, this);
          }
          return Promise.resolve(request);
        };
        LinkFallbackSession2.prototype.showLoading = function() {
          if (this.link.transport.showLoading) {
            return this.link.transport.showLoading();
          }
        };
        LinkFallbackSession2.prototype.makeSignatureProvider = function() {
          return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);
        };
        LinkFallbackSession2.prototype.transact = function(args, options) {
          return this.link.transact(args, tslib.__assign(tslib.__assign({}, options), { chain: this.chainId }), this);
        };
        return LinkFallbackSession2;
      }(LinkSession);
      var BuoyCallbackService = function() {
        function BuoyCallbackService2(address) {
          this.address = address.trim().replace(/\/$/, "");
        }
        BuoyCallbackService2.prototype.create = function() {
          var url = this.address + "/" + uuid.v4();
          return new BuoyCallback(url);
        };
        return BuoyCallbackService2;
      }();
      var BuoyCallback = function() {
        function BuoyCallback2(url) {
          this.url = url;
          this.ctx = {};
        }
        BuoyCallback2.prototype.wait = function() {
          if (this.url.includes("hyperbuoy")) {
            return pollForCallback(this.url, this.ctx);
          } else {
            return waitForCallback(this.url, this.ctx);
          }
        };
        BuoyCallback2.prototype.cancel = function() {
          if (this.ctx.cancel) {
            this.ctx.cancel();
          }
        };
        return BuoyCallback2;
      }();
      function waitForCallback(url, ctx) {
        return new Promise(function(resolve, reject) {
          var active = true;
          var retries = 0;
          var socketUrl = url.replace(/^http/, "ws");
          var handleResponse = function(response) {
            try {
              resolve(JSON.parse(response));
            } catch (error) {
              error.message = "Unable to parse callback JSON: " + error.message;
              reject(error);
            }
          };
          var connect = function() {
            var socket = new WebSocket__default["default"](socketUrl);
            ctx.cancel = function() {
              active = false;
              if (socket.readyState === WebSocket__default["default"].OPEN || socket.readyState === WebSocket__default["default"].CONNECTING) {
                socket.close();
              }
            };
            socket.onmessage = function(event) {
              active = false;
              if (socket.readyState === WebSocket__default["default"].OPEN) {
                socket.close();
              }
              if (typeof Blob !== "undefined" && event.data instanceof Blob) {
                var reader_1 = new FileReader();
                reader_1.onload = function() {
                  handleResponse(reader_1.result);
                };
                reader_1.onerror = function(error) {
                  reject(error);
                };
                reader_1.readAsText(event.data);
              } else {
                if (typeof event.data === "string") {
                  handleResponse(event.data);
                } else {
                  handleResponse(event.data.toString());
                }
              }
            };
            socket.onopen = function() {
              retries = 0;
            };
            socket.onclose = function() {
              if (active) {
                setTimeout(connect, backoff(retries++));
              }
            };
          };
          connect();
        });
      }
      function pollForCallback(url, ctx) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var active, res, error_1;
          return tslib.__generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                active = true;
                ctx.cancel = function() {
                  active = false;
                };
                _a2.label = 1;
              case 1:
                if (!active)
                  return [3, 11];
                _a2.label = 2;
              case 2:
                _a2.trys.push([2, 8, , 9]);
                return [4, fetch2(url)];
              case 3:
                res = _a2.sent();
                if (!(res.status === 408))
                  return [3, 4];
                return [3, 1];
              case 4:
                if (!(res.status === 200))
                  return [3, 6];
                return [4, res.json()];
              case 5:
                return [2, _a2.sent()];
              case 6:
                throw new Error("HTTP " + res.status + ": " + res.statusText);
              case 7:
                return [3, 9];
              case 8:
                error_1 = _a2.sent();
                console.warn("Unexpected hyperbuoy error", error_1);
                return [3, 9];
              case 9:
                return [4, sleep(1e3)];
              case 10:
                _a2.sent();
                return [3, 1];
              case 11:
                return [2, null];
            }
          });
        });
      }
      function backoff(tries) {
        return Math.min(Math.pow(tries * 10, 2), 10 * 1e3);
      }
      function sleep(ms) {
        return new Promise(function(resolve) {
          setTimeout(resolve, ms);
        });
      }
      var LinkChain = function() {
        function LinkChain2(chainId, clientOrUrl) {
          this.abiCache = new Map();
          this.pendingAbis = new Map();
          this.chainId = eosioSigningRequest.ChainId.from(chainId);
          this.client = typeof clientOrUrl === "string" ? new eosio.APIClient({ url: clientOrUrl }) : clientOrUrl;
        }
        LinkChain2.prototype.getAbi = function(account) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var key2, rv, getAbi;
            return tslib.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  key2 = String(account);
                  rv = this.abiCache.get(key2);
                  if (!!rv)
                    return [3, 2];
                  getAbi = this.pendingAbis.get(key2);
                  if (!getAbi) {
                    getAbi = this.client.v1.chain.get_abi(account);
                    this.pendingAbis.set(key2, getAbi);
                  }
                  return [4, getAbi];
                case 1:
                  rv = _a2.sent().abi;
                  this.pendingAbis.delete(key2);
                  if (rv) {
                    this.abiCache.set(key2, rv);
                  }
                  _a2.label = 2;
                case 2:
                  return [2, rv];
              }
            });
          });
        };
        return LinkChain2;
      }();
      var Link = function() {
        function Link2(options) {
          if (typeof options !== "object") {
            throw new TypeError("Missing options object");
          }
          if (!options.transport) {
            throw new TypeError("options.transport is required");
          }
          var chains = options.chains || [];
          if (options.chainId && options.client) {
            chains = [{ chainId: options.chainId, nodeUrl: options.client }];
          }
          if (chains.length === 0) {
            throw new TypeError("options.chains is required");
          }
          this.chains = chains.map(function(_a2) {
            var chainId = _a2.chainId, nodeUrl = _a2.nodeUrl;
            if (!chainId) {
              throw new Error("options.chains[].chainId is required");
            }
            if (!nodeUrl) {
              throw new Error("options.chains[].nodeUrl is required");
            }
            return new LinkChain(chainId, nodeUrl);
          });
          if (options.service === void 0 || typeof options.service === "string") {
            this.callbackService = new BuoyCallbackService(options.service || LinkOptions.defaults.service);
          } else {
            this.callbackService = options.service;
          }
          this.transport = options.transport;
          if (options.storage !== null) {
            this.storage = options.storage || this.transport.storage;
          }
          this.verifyProofs = options.verifyProofs !== void 0 ? options.verifyProofs : LinkOptions.defaults.verifyProofs;
          this.encodeChainIds = options.encodeChainIds !== void 0 ? options.encodeChainIds : LinkOptions.defaults.encodeChainIds;
        }
        Object.defineProperty(Link2.prototype, "client", {
          get: function() {
            return this.chains[0].client;
          },
          enumerable: false,
          configurable: true
        });
        Link2.prototype.getChain = function(chain) {
          if (chain instanceof LinkChain) {
            return chain;
          }
          if (typeof chain === "number") {
            var rv_1 = this.chains[chain];
            if (!rv_1) {
              throw new Error("Invalid chain index: " + chain);
            }
            return rv_1;
          }
          var id = eosioSigningRequest.ChainId.from(chain);
          var rv = this.chains.find(function(c) {
            return c.chainId.equals(id);
          });
          if (!rv) {
            throw new Error("Unsupported chain: " + id);
          }
          return rv;
        };
        Link2.prototype.createRequest = function(args, chain, transport) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var t, request, c, callback;
            return tslib.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  t = transport || this.transport;
                  if (!(chain || this.chains.length === 1))
                    return [3, 2];
                  c = chain || this.chains[0];
                  return [4, eosioSigningRequest.SigningRequest.create(tslib.__assign(tslib.__assign({}, args), { chainId: c.chainId, broadcast: false }), { abiProvider: c, zlib: zlib__default["default"] })];
                case 1:
                  request = _a2.sent();
                  return [3, 4];
                case 2:
                  return [4, eosioSigningRequest.SigningRequest.create(tslib.__assign(tslib.__assign({}, args), { chainId: null, chainIds: this.encodeChainIds ? this.chains.map(function(c2) {
                    return c2.chainId;
                  }) : void 0, broadcast: false }), { abiProvider: this.chains[0], zlib: zlib__default["default"] })];
                case 3:
                  request = _a2.sent();
                  _a2.label = 4;
                case 4:
                  if (!t.prepare)
                    return [3, 6];
                  return [4, t.prepare(request)];
                case 5:
                  request = _a2.sent();
                  _a2.label = 6;
                case 6:
                  callback = this.callbackService.create();
                  request.setCallback(callback.url, true);
                  return [2, { request, callback }];
              }
            });
          });
        };
        Link2.prototype.sendRequest = function(request, callback, chain, transport, broadcast) {
          if (broadcast === void 0) {
            broadcast = false;
          }
          return tslib.__awaiter(this, void 0, void 0, function() {
            var t, linkUrl, cancel, callbackResponse, payload_1, signer, signatures, c, resolved, cosignerSig, result, signedTx, res, error_1;
            return tslib.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  t = transport || this.transport;
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 6, , 7]);
                  linkUrl = request.data.callback;
                  if (linkUrl !== callback.url) {
                    throw new Error("Invalid request callback");
                  }
                  if (request.data.flags.broadcast === true || request.data.flags.background === false) {
                    throw new Error("Invalid request flags");
                  }
                  cancel = new Promise(function(resolve, reject) {
                    t.onRequest(request, function(reason) {
                      callback.cancel();
                      if (typeof reason === "string") {
                        reject(new CancelError(reason));
                      } else {
                        reject(reason);
                      }
                    });
                  });
                  return [4, Promise.race([callback.wait(), cancel])];
                case 2:
                  callbackResponse = _a2.sent();
                  if (typeof callbackResponse.rejected === "string") {
                    throw new CancelError(callbackResponse.rejected);
                  }
                  payload_1 = callbackResponse;
                  signer = eosio.PermissionLevel.from({
                    actor: payload_1.sa,
                    permission: payload_1.sp
                  });
                  signatures = Object.keys(payload_1).filter(function(key2) {
                    return key2.startsWith("sig") && key2 !== "sig0";
                  }).map(function(key2) {
                    return eosio.Signature.from(payload_1[key2]);
                  });
                  c = void 0;
                  if (!chain && this.chains.length > 1) {
                    if (!payload_1.cid) {
                      throw new Error("Multi chain response payload must specify resolved chain id (cid)");
                    }
                    c = this.getChain(payload_1.cid);
                  } else {
                    c = chain || this.getChain(0);
                    if (payload_1.cid && !c.chainId.equals(payload_1.cid)) {
                      throw new Error("Got response for wrong chain id");
                    }
                  }
                  return [
                    4,
                    eosioSigningRequest.ResolvedSigningRequest.fromPayload(payload_1, {
                      zlib: zlib__default["default"],
                      abiProvider: c
                    })
                  ];
                case 3:
                  resolved = _a2.sent();
                  cosignerSig = resolved.request.getInfoKey("cosig", {
                    type: eosio.Signature,
                    array: true
                  });
                  if (cosignerSig) {
                    signatures.unshift.apply(signatures, tslib.__spreadArray([], tslib.__read(cosignerSig)));
                  }
                  result = {
                    resolved,
                    chain: c,
                    transaction: resolved.transaction,
                    resolvedTransaction: resolved.resolvedTransaction,
                    signatures,
                    payload: payload_1,
                    signer
                  };
                  if (!broadcast)
                    return [3, 5];
                  signedTx = eosio.SignedTransaction.from(tslib.__assign(tslib.__assign({}, resolved.transaction), { signatures }));
                  return [4, c.client.v1.chain.push_transaction(signedTx)];
                case 4:
                  res = _a2.sent();
                  result.processed = res.processed;
                  _a2.label = 5;
                case 5:
                  if (t.onSuccess) {
                    t.onSuccess(request, result);
                  }
                  return [2, result];
                case 6:
                  error_1 = _a2.sent();
                  if (t.onFailure) {
                    t.onFailure(request, error_1);
                  }
                  throw error_1;
                case 7:
                  return [2];
              }
            });
          });
        };
        Link2.prototype.transact = function(args, options, transport) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var o, t, c, broadcast, noModify, anyArgs, _a2, request, callback, result;
            return tslib.__generator(this, function(_b2) {
              switch (_b2.label) {
                case 0:
                  o = options || {};
                  t = transport || this.transport;
                  c = o.chain !== void 0 ? this.getChain(o.chain) : void 0;
                  broadcast = o.broadcast !== false;
                  noModify = o.noModify !== void 0 ? o.noModify : !broadcast;
                  if (t && t.showLoading) {
                    t.showLoading();
                  }
                  anyArgs = args;
                  if (args.actions && (anyArgs.expiration || anyArgs.ref_block_num || anyArgs.ref_block_prefix || anyArgs.max_net_usage_words || anyArgs.max_cpu_usage_ms || anyArgs.delay_sec)) {
                    args = {
                      transaction: tslib.__assign({ expiration: "1970-01-01T00:00:00", ref_block_num: 0, ref_block_prefix: 0, max_net_usage_words: 0, max_cpu_usage_ms: 0, delay_sec: 0 }, anyArgs)
                    };
                  }
                  return [4, this.createRequest(args, c, t)];
                case 1:
                  _a2 = _b2.sent(), request = _a2.request, callback = _a2.callback;
                  if (noModify) {
                    request.setInfoKey("no_modify", true, "bool");
                  }
                  return [4, this.sendRequest(request, callback, c, t, broadcast)];
                case 2:
                  result = _b2.sent();
                  return [2, result];
              }
            });
          });
        };
        Link2.prototype.identify = function(args) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var _a2, request, callback, res, account, proof, accountPermission, proofValid, perm;
            return tslib.__generator(this, function(_b2) {
              switch (_b2.label) {
                case 0:
                  return [4, this.createRequest({
                    identity: { permission: args.requestPermission, scope: args.scope },
                    info: args.info
                  })];
                case 1:
                  _a2 = _b2.sent(), request = _a2.request, callback = _a2.callback;
                  return [4, this.sendRequest(request, callback)];
                case 2:
                  res = _b2.sent();
                  if (!res.resolved.request.isIdentity()) {
                    throw new IdentityError("Unexpected response");
                  }
                  proof = res.resolved.getIdentityProof(res.signatures[0]);
                  if (!this.verifyProofs)
                    return [3, 4];
                  return [4, res.chain.client.v1.chain.get_account(res.signer.actor)];
                case 3:
                  account = _b2.sent();
                  if (!account) {
                    throw new IdentityError("Signature from unknown account: " + proof.signer.actor);
                  }
                  accountPermission = account.permissions.find(function(_a3) {
                    var perm_name = _a3.perm_name;
                    return proof.signer.permission.equals(perm_name);
                  });
                  if (!accountPermission) {
                    throw new IdentityError(proof.signer.actor + " signed for unknown permission: " + proof.signer.permission);
                  }
                  proofValid = proof.verify(accountPermission.required_auth, account.head_block_time);
                  if (!proofValid) {
                    throw new IdentityError("Invalid identify proof for: " + proof.signer);
                  }
                  _b2.label = 4;
                case 4:
                  if (args.requestPermission) {
                    perm = eosio.PermissionLevel.from(args.requestPermission);
                    if (!perm.actor.equals(eosioSigningRequest.PlaceholderName) && !perm.actor.equals(proof.signer.actor) || !perm.permission.equals(eosioSigningRequest.PlaceholderPermission) && !perm.permission.equals(proof.signer.permission)) {
                      throw new IdentityError("Identity proof singed by " + proof.signer + ", expected: " + formatAuth(perm) + " ");
                    }
                  }
                  return [2, tslib.__assign(tslib.__assign({}, res), {
                    account,
                    proof
                  })];
              }
            });
          });
        };
        Link2.prototype.login = function(identifier) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var privateKey, requestKey, createInfo, res, metadata, parsed, _a2, _b2, key2, signerKey, session;
            var e_12, _c2;
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  privateKey = eosio.PrivateKey.generate("K1");
                  requestKey = privateKey.toPublic();
                  createInfo = LinkCreate.from({
                    session_name: identifier,
                    request_key: requestKey,
                    user_agent: this.getUserAgent()
                  });
                  return [4, this.identify({
                    scope: identifier,
                    info: {
                      link: createInfo,
                      scope: identifier
                    }
                  })];
                case 1:
                  res = _d.sent();
                  metadata = {
                    sameDevice: res.resolved.request.getRawInfo()["return_path"] !== void 0
                  };
                  if (res.payload.link_meta) {
                    try {
                      parsed = JSON.parse(res.payload.link_meta);
                      try {
                        for (_a2 = tslib.__values(Object.keys(parsed)), _b2 = _a2.next(); !_b2.done; _b2 = _a2.next()) {
                          key2 = _b2.value;
                          metadata[snakeToCamel(key2)] = parsed[key2];
                        }
                      } catch (e_1_1) {
                        e_12 = { error: e_1_1 };
                      } finally {
                        try {
                          if (_b2 && !_b2.done && (_c2 = _a2.return))
                            _c2.call(_a2);
                        } finally {
                          if (e_12)
                            throw e_12.error;
                        }
                      }
                    } catch (error) {
                      console.warn("Unable to parse link metadata", error, res.payload.link_meta);
                    }
                  }
                  signerKey = res.proof.recover();
                  if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {
                    session = new LinkChannelSession(this, {
                      identifier,
                      chainId: res.chain.chainId,
                      auth: res.signer,
                      publicKey: signerKey,
                      channel: {
                        url: res.payload.link_ch,
                        key: res.payload.link_key,
                        name: res.payload.link_name
                      },
                      requestKey: privateKey
                    }, metadata);
                  } else {
                    session = new LinkFallbackSession(this, {
                      identifier,
                      chainId: res.chain.chainId,
                      auth: res.signer,
                      publicKey: signerKey
                    }, metadata);
                  }
                  if (!this.storage)
                    return [3, 3];
                  return [4, this.storeSession(identifier, session)];
                case 2:
                  _d.sent();
                  _d.label = 3;
                case 3:
                  return [2, tslib.__assign(tslib.__assign({}, res), { session })];
              }
            });
          });
        };
        Link2.prototype.restoreSession = function(identifier, auth, chainId) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var key2, list, id_1, latest, data, sessionData, session;
            return tslib.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (!this.storage) {
                    throw new Error("Unable to restore session: No storage adapter configured");
                  }
                  if (!(auth && chainId))
                    return [3, 1];
                  key2 = this.sessionKey(identifier, formatAuth(eosio.PermissionLevel.from(auth)), String(eosioSigningRequest.ChainId.from(chainId)));
                  return [3, 3];
                case 1:
                  return [4, this.listSessions(identifier)];
                case 2:
                  list = _a2.sent();
                  if (auth) {
                    list = list.filter(function(item) {
                      return item.auth.equals(auth);
                    });
                  }
                  if (chainId) {
                    id_1 = eosioSigningRequest.ChainId.from(chainId);
                    list = list.filter(function(item) {
                      return item.chainId.equals(id_1);
                    });
                  }
                  latest = list[0];
                  if (!latest) {
                    return [2, null];
                  }
                  key2 = this.sessionKey(identifier, formatAuth(latest.auth), String(latest.chainId));
                  _a2.label = 3;
                case 3:
                  return [4, this.storage.read(key2)];
                case 4:
                  data = _a2.sent();
                  if (!data) {
                    return [2, null];
                  }
                  try {
                    sessionData = JSON.parse(data);
                  } catch (error) {
                    throw new Error("Unable to restore session: Stored JSON invalid (" + (error.message || String(error)) + ")");
                  }
                  session = LinkSession.restore(this, sessionData);
                  if (!(auth || chainId))
                    return [3, 6];
                  return [4, this.touchSession(identifier, session.auth, session.chainId)];
                case 5:
                  _a2.sent();
                  _a2.label = 6;
                case 6:
                  return [2, session];
              }
            });
          });
        };
        Link2.prototype.listSessions = function(identifier) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var key2, list, _a2, _b2, error_2;
            return tslib.__generator(this, function(_c2) {
              switch (_c2.label) {
                case 0:
                  if (!this.storage) {
                    throw new Error("Unable to list sessions: No storage adapter configured");
                  }
                  key2 = this.sessionKey(identifier, "list");
                  _c2.label = 1;
                case 1:
                  _c2.trys.push([1, 3, , 4]);
                  _b2 = (_a2 = JSON).parse;
                  return [4, this.storage.read(key2)];
                case 2:
                  list = _b2.apply(_a2, [_c2.sent() || "[]"]);
                  return [3, 4];
                case 3:
                  error_2 = _c2.sent();
                  throw new Error("Unable to list sessions: " + (error_2.message || String(error_2)));
                case 4:
                  return [2, list.map(function(_a3) {
                    var auth = _a3.auth, chainId = _a3.chainId;
                    return {
                      auth: eosio.PermissionLevel.from(auth),
                      chainId: eosioSigningRequest.ChainId.from(chainId)
                    };
                  })];
              }
            });
          });
        };
        Link2.prototype.removeSession = function(identifier, auth, chainId) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var key2;
            return tslib.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (!this.storage) {
                    throw new Error("Unable to remove session: No storage adapter configured");
                  }
                  key2 = this.sessionKey(identifier, formatAuth(auth), String(chainId));
                  return [4, this.storage.remove(key2)];
                case 1:
                  _a2.sent();
                  return [4, this.touchSession(identifier, auth, chainId, true)];
                case 2:
                  _a2.sent();
                  return [2];
              }
            });
          });
        };
        Link2.prototype.clearSessions = function(identifier) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var _a2, _b2, _c2, auth, chainId, e_2_1;
            var e_2, _d;
            return tslib.__generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  if (!this.storage) {
                    throw new Error("Unable to clear sessions: No storage adapter configured");
                  }
                  _e.label = 1;
                case 1:
                  _e.trys.push([1, 7, 8, 9]);
                  return [4, this.listSessions(identifier)];
                case 2:
                  _a2 = tslib.__values.apply(void 0, [_e.sent()]), _b2 = _a2.next();
                  _e.label = 3;
                case 3:
                  if (!!_b2.done)
                    return [3, 6];
                  _c2 = _b2.value, auth = _c2.auth, chainId = _c2.chainId;
                  return [4, this.removeSession(identifier, auth, chainId)];
                case 4:
                  _e.sent();
                  _e.label = 5;
                case 5:
                  _b2 = _a2.next();
                  return [3, 3];
                case 6:
                  return [3, 9];
                case 7:
                  e_2_1 = _e.sent();
                  e_2 = { error: e_2_1 };
                  return [3, 9];
                case 8:
                  try {
                    if (_b2 && !_b2.done && (_d = _a2.return))
                      _d.call(_a2);
                  } finally {
                    if (e_2)
                      throw e_2.error;
                  }
                  return [7];
                case 9:
                  return [2];
              }
            });
          });
        };
        Link2.prototype.makeSignatureProvider = function(availableKeys, chain, transport) {
          var _this = this;
          return {
            getAvailableKeys: function() {
              return tslib.__awaiter(_this, void 0, void 0, function() {
                return tslib.__generator(this, function(_a2) {
                  return [2, availableKeys];
                });
              });
            },
            sign: function(args) {
              return tslib.__awaiter(_this, void 0, void 0, function() {
                var t, c, request, callback, _a2, transaction, signatures, serializedTransaction;
                return tslib.__generator(this, function(_b2) {
                  switch (_b2.label) {
                    case 0:
                      t = transport || this.transport;
                      c = chain ? this.getChain(chain) : this.chains[0];
                      request = eosioSigningRequest.SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, { abiProvider: c, zlib: zlib__default["default"] });
                      callback = this.callbackService.create();
                      request.setCallback(callback.url, true);
                      request.setBroadcast(false);
                      if (!t.prepare)
                        return [3, 2];
                      return [4, t.prepare(request)];
                    case 1:
                      request = _b2.sent();
                      _b2.label = 2;
                    case 2:
                      return [4, this.sendRequest(request, callback, c, t)];
                    case 3:
                      _a2 = _b2.sent(), transaction = _a2.transaction, signatures = _a2.signatures;
                      serializedTransaction = eosio.Serializer.encode({ object: transaction });
                      return [2, tslib.__assign(tslib.__assign({}, args), {
                        serializedTransaction,
                        signatures
                      })];
                  }
                });
              });
            }
          };
        };
        Link2.prototype.touchSession = function(identifier, auth, chainId, remove) {
          if (remove === void 0) {
            remove = false;
          }
          return tslib.__awaiter(this, void 0, void 0, function() {
            var list, existing, key2;
            return tslib.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.listSessions(identifier)];
                case 1:
                  list = _a2.sent();
                  existing = list.findIndex(function(item) {
                    return item.auth.equals(auth) && item.chainId.equals(chainId);
                  });
                  if (existing >= 0) {
                    list.splice(existing, 1);
                  }
                  if (remove === false) {
                    list.unshift({ auth, chainId });
                  }
                  key2 = this.sessionKey(identifier, "list");
                  return [4, this.storage.write(key2, JSON.stringify(list))];
                case 2:
                  _a2.sent();
                  return [2];
              }
            });
          });
        };
        Link2.prototype.storeSession = function(identifier, session) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var key2, data;
            return tslib.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  key2 = this.sessionKey(identifier, formatAuth(session.auth), String(session.chainId));
                  data = JSON.stringify(session.serialize());
                  return [4, this.storage.write(key2, data)];
                case 1:
                  _a2.sent();
                  return [4, this.touchSession(identifier, session.auth, session.chainId)];
                case 2:
                  _a2.sent();
                  return [2];
              }
            });
          });
        };
        Link2.prototype.sessionKey = function(identifier) {
          var suffix = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            suffix[_i - 1] = arguments[_i];
          }
          return tslib.__spreadArray([String(eosio.Name.from(identifier))], tslib.__read(suffix)).join("-");
        };
        Link2.prototype.getUserAgent = function() {
          var rv = "AnchorLink/" + Link2.version;
          if (this.transport.userAgent) {
            rv += " " + this.transport.userAgent();
          }
          return rv;
        };
        Link2.version = "3.2.3";
        return Link2;
      }();
      function formatAuth(auth) {
        var a = eosio.PermissionLevel.from(auth);
        var actor = a.actor.equals(eosioSigningRequest.PlaceholderName) ? "<any>" : String(a.actor);
        var permission;
        if (a.permission.equals(eosioSigningRequest.PlaceholderName) || a.permission.equals(eosioSigningRequest.PlaceholderPermission)) {
          permission = "<any>";
        } else {
          permission = String(a.permission);
        }
        return actor + "@" + permission;
      }
      function snakeToPascal(name) {
        return name.split("_").map(function(v) {
          return (v[0] ? v[0].toUpperCase() : "_") + v.slice(1);
        }).join("");
      }
      function snakeToCamel(name) {
        var pascal = snakeToPascal(name);
        return pascal[0].toLowerCase() + pascal.slice(1);
      }
      var pkg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), eosioSigningRequest__namespace, eosio__namespace, {
        "default": Link,
        IdentityProof: eosioSigningRequest.IdentityProof,
        ChainId: eosioSigningRequest.ChainId,
        ChainName: eosioSigningRequest.ChainName,
        LinkChain,
        Link,
        LinkSession,
        LinkChannelSession,
        LinkFallbackSession,
        CancelError,
        IdentityError,
        SessionError
      }));
      var e_1;
      var _a;
      var AnchorLink = Link;
      try {
        for (_b = tslib.__values(Object.keys(pkg)), _c = _b.next(); !_c.done; _c = _b.next()) {
          key = _c.value;
          if (key === "default")
            continue;
          AnchorLink[key] = pkg[key];
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var key;
      var _b;
      var _c;
      module.exports = AnchorLink;
    }
  });

  // node_modules/anchor-link-browser-transport/lib/anchor-link-browser-transport.js
  var require_anchor_link_browser_transport = __commonJS({
    "node_modules/anchor-link-browser-transport/lib/anchor-link-browser-transport.js"(exports, module) {
      "use strict";
      var tslib = require_tslib();
      var anchorLink = require_anchor_link();
      var styleText = `
/* Anchor Link */

.%prefix% * {
    box-sizing: border-box;
    line-height: 1;
}

.%prefix% {
    font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue',
        Arial, sans-serif;
    font-size: 13px;
    background: rgba(0, 0, 0, 0.65);
    position: fixed;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    z-index: 2147483647;
    display: none;
    align-items: center;
    justify-content: center;
}

.%prefix%-active {
    display: flex;
}

.%prefix%-inner {
    background: #EFF1F7;
    margin: 20px;
    padding-top: 50px;
    border-radius: 20px;
    box-shadow: 0px 4px 100px rgba(0, 0, 0, .5);
    width: 340px;
    position: relative;
}

.%prefix%-close {
    display: block;
    position: absolute;
    top: 11px;
    right: 16px;
    width: 28px;
    height: 28px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M.57 12.1a.96.96 0 000 1.34c.37.36 1 .36 1.34 0L7 8.37l5.09 5.09c.36.35.97.35 1.34-.01a.96.96 0 000-1.34L8.34 7.01l5.08-5.08a.95.95 0 000-1.33.97.97 0 00-1.34-.01L6.99 5.68 1.91.59a.96.96 0 00-1.33 0 .97.97 0 00-.01 1.34l5.09 5.08-5.1 5.1z' fill='%23007AFF'/%3E%3C/svg%3E");
    background-size: 14px;
    background-repeat: no-repeat;
    background-position: 50% 7px;
    border-radius: 100%;
    cursor: pointer;
}

.%prefix%-close:hover {
    background-color: white;
}

.%prefix%-version {
    position: absolute;
    top: 19px;
    left: 20px;
    cursor: help;
    color: #B8C0DA;
    opacity: 0.1;
}

.%prefix%-version:hover {
    opacity: 1;
}

.%prefix%-logo {
    width: 70px;
    height: 70px;
    margin: 0 auto;
    margin-top: -56px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23fff' d='M18.81 9.19h33.25V59.5H18.81z'/%3E%3Cpath d='M38.45 28.88h-6.9L35 21.77l3.45 7.1z' fill='%233650A2'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M35 70a35 35 0 100-70 35 35 0 000 70zm2.36-55.4a2.62 2.62 0 00-4.72 0L21.9 36.75h5.84l1.7-3.5h11.13l1.7 3.5h5.83L37.36 14.6zM48.13 44.2h-5.26a7.76 7.76 0 01-5.24 7v-10.5a2.62 2.62 0 10-5.25 0v10.5a7.76 7.76 0 01-5.25-7h-5.25c.16 7.06 6 12.69 13.12 12.69 7.12 0 12.97-5.63 13.13-12.7z' fill='%233650A2'/%3E%3C/svg%3E");
}

.%prefix%-fuel {
    width: 70px;
    height: 70px;
    margin: 0 auto;
    margin-top: -56px;
    background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3ClinearGradient id='linear-gradient-25' x1='104.79' y1='197.49' x2='131.55' y2='108.35' gradientUnits='userSpaceOnUse'%3E%3Cstop offset='0.38' stop-color='%23f6b621'/%3E%3Cstop offset='0.59' stop-color='%23e89124'/%3E%3C/linearGradient%3E%3C/defs%3E%3Cg id='brain-logo' style='' transform='matrix(1, 0, 0, 1, -0.005538, -0.040005)'%3E%3Cg%3E%3Cpath class='cls-4' d='M251.93,111.13,221.28,71.51A23.76,23.76,0,0,0,209,63.61l-77.7-18.09a25.86,25.86,0,0,0-5.78-.6,28.22,28.22,0,0,0-7.88,1L99.06,51.58a6.31,6.31,0,0,0-.61-5l-5.3-9a6.36,6.36,0,0,0-5.47-3.13h0a6.57,6.57,0,0,0-1.92.29L49.61,46.21a6.34,6.34,0,0,0-4.41,6.28l.46,12.2a6.2,6.2,0,0,0,.78,2.81L38.2,70a21.1,21.1,0,0,0-11.73,9.76L3,125.21a17.78,17.78,0,0,0,.54,16.32l12.68,21A16.19,16.19,0,0,0,29.69,170a13.25,13.25,0,0,0,1.67-.1L65,165.81a17.22,17.22,0,0,0,9.2,13.64l12.86,6.08a32.51,32.51,0,0,0,12.26,2.63c.35,0,.7,0,1,0l29.17-1.61a6.12,6.12,0,0,1,2.64,1l29.05,28.79a20,20,0,0,0,13.27,5.29c.52,0,1,0,1.53-.07l23.93-2.47c4.31-.44,7.67-2.87,9-6.48s.36-7.64-2.63-10.78l-10.09-10.64,19.07-5.64a15.76,15.76,0,0,0,10.83-13.09L227.65,157a10.69,10.69,0,0,1,1.86-4.19l21.74-24a14,14,0,0,0,.68-17.65Z' style='fill: rgb(255, 255, 255);'/%3E%3Cg%3E%3Ccircle class='cls-2' cx='173.24' cy='107.45' r='6.19' transform='translate(7.67 226.39) rotate(-67.5)' style='fill: rgb(246, 182, 33);'/%3E%3Cpath class='cls-2' d='M101,97.06a3.71,3.71,0,1,0-3.71-3.71A3.71,3.71,0,0,0,101,97.06Z' style='fill: rgb(246, 182, 33);'/%3E%3Ccircle class='cls-2' cx='135.4' cy='76.29' r='3.71' style='fill: rgb(246, 182, 33);'/%3E%3Cg%3E%3Cpath class='cls-21' d='M79.24,128c-16.71,0-37.79,7.36-48.93,11.68a2.39,2.39,0,0,0-1.19,3.46L33.8,151a2.38,2.38,0,0,0,2.34,1.14L69.27,148a12.74,12.74,0,0,1,1.63-.1,13.22,13.22,0,0,1,13.26,12.74l0,1.1a2.4,2.4,0,0,0,1.37,2.07l10.56,5a14.8,14.8,0,0,0,4.69.95H101L129,168.24c.28,0,.57,0,.85,0a21.23,21.23,0,0,1,14.06,5.68l27.82,27.56a4,4,0,0,0,1.26.45l6.07-.75a1.22,1.22,0,0,0,.86-1.9l-3-4.36a11.51,11.51,0,0,1,5.21-19.44l23.4-6.93a1.44,1.44,0,0,0,1-1.23l1.26-12.72v0a1.44,1.44,0,0,0-1.81-1.54c-8.26,2.21-22.73,5.72-31.63,5.72C136.65,158.74,108.72,128,79.24,128Zm32.48,27a2.77,2.77,0,0,1-1,1,3.78,3.78,0,0,1-5.23-5.23,2.77,2.77,0,0,1,1-1A3.78,3.78,0,0,1,111.72,155Zm63.76,13.39a2.62,2.62,0,0,1-1,1,3.78,3.78,0,0,1-5.23-5.23,2.77,2.77,0,0,1,1-1A3.78,3.78,0,0,1,175.48,168.36Z' style='fill: url(%23linear-gradient-25);'/%3E%3Cpath class='cls-2' d='M173.34,127.62c-37.69,0-69.59-16.73-92.46-16.73-16.08,0-43.36,12.17-55.32,21a2,2,0,0,0-.65,2.46c.35.8.82,1.84,1.26,2.82a2,2,0,0,0,2.62,1C39.07,134,61,125.9,79.24,125.9c30.45,0,58.48,27,91.13,27,14.49,0,35.75-5.69,41.3-10.16,2.42-2.52,10.36-11.93,16-17.78a2.39,2.39,0,0,0-2.32-3.94C214.49,123.51,193.73,127.62,173.34,127.62Zm-1.68,14.25a5.28,5.28,0,0,1-2.49,2.49,6.27,6.27,0,0,1-8.48-8.48,5.37,5.37,0,0,1,2.49-2.49A6.27,6.27,0,0,1,171.66,141.87Z' style='fill: rgb(246, 182, 33);'/%3E%3C/g%3E%3Cpath class='cls-1' d='M248.71,113.13,218.06,73.51a20.05,20.05,0,0,0-10-6.43L130.34,49a25.7,25.7,0,0,0-11.57.38L91.41,57.65a.05.05,0,0,1-.07,0L89.56,53a.05.05,0,0,1,0-.07l4.06-1.46a2.45,2.45,0,0,0,1-.62,2.29,2.29,0,0,0,.29-2.72l-5.29-9a2.3,2.3,0,0,0-2.67-1L50.83,49.59a2.28,2.28,0,0,0-1.59,2.27l.46,12.2a2.27,2.27,0,0,0,1,1.8,2.3,2.3,0,0,0,1.28.4,2.33,2.33,0,0,0,.78-.14l9.18-3.29a0,0,0,0,1,.06,0L63.58,66a0,0,0,0,1,0,.07L39.37,73.4a17.25,17.25,0,0,0-9.31,7.74L6.58,126.59A13.67,13.67,0,0,0,7,139l12.68,21a12.1,12.1,0,0,0,11.19,5.45l37.08-4.54a.83.83,0,0,1,.68.18.82.82,0,0,1,.28.64l.14,3.22a13.25,13.25,0,0,0,6.88,10.39l12.86,6.08a28,28,0,0,0,11.32,2.21l29.2-1.61a9.38,9.38,0,0,1,5.68,2.16L164,212.94a16,16,0,0,0,10.41,4.12,10,10,0,0,0,1.11-.06l23.93-2.46c2.77-.29,4.82-1.69,5.62-3.85s.15-4.56-1.77-6.58l-14.6-15.38a.06.06,0,0,1,0-.09l25.35-7.5a11.74,11.74,0,0,0,7.94-9.59l1.53-15.46a14.22,14.22,0,0,1,2.9-6.52l21.74-24A9.94,9.94,0,0,0,248.71,113.13ZM56.08,56.65,56,54.81a1.29,1.29,0,0,1,.88-1.29l28-9a1.28,1.28,0,0,1,1.48.57l.48.83a1.27,1.27,0,0,1-.68,1.83l-28.35,10A1.27,1.27,0,0,1,56.08,56.65Zm186.57,63.93-21.71,24a21.37,21.37,0,0,0-4.79,10.8l-1.54,15.46A4.37,4.37,0,0,1,212,174l-26.5,7.84a6.52,6.52,0,0,0-3,11.2L194,205.17a1.49,1.49,0,0,1-.93,2.5l-18.31,1.89a8.37,8.37,0,0,1-5.49-1.94l-29.06-28.8a16.74,16.74,0,0,0-10.77-4.33l-.59,0-29.21,1.61a20.07,20.07,0,0,1-7.69-1.5l-12.87-6.09a5,5,0,0,1-2.61-3.93l-.13-3.22A8.27,8.27,0,0,0,67,153.44L29.94,158a4.75,4.75,0,0,1-3.87-1.88l-12.68-21a6.38,6.38,0,0,1-.17-5.05L36.71,84.58a10.08,10.08,0,0,1,4.82-4l79.41-24a18.68,18.68,0,0,1,7.7-.25l77.7,18.09a12.72,12.72,0,0,1,5.8,3.72l30.62,39.59A2.35,2.35,0,0,1,242.65,120.58Z' style='fill: rgb(42, 54, 64);'/%3E%3C/g%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
}

.%prefix%-logo.loading {
    border-radius: 100%;
    background-color: #3650A2;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0.5 0.5 45 45' xmlns='http://www.w3.org/2000/svg' stroke='%23fff'%3E%3Cg fill='none' fill-rule='evenodd' transform='translate(1 1)' stroke-width='2'%3E%3Ccircle cx='22' cy='22' r='6' stroke-opacity='0'%3E%3Canimate attributeName='r' begin='1.5s' dur='3s' values='6;22' calcMode='linear' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-opacity' begin='1.5s' dur='3s' values='1;0' calcMode='linear' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-width' begin='1.5s' dur='3s' values='2;0' calcMode='linear' repeatCount='indefinite' /%3E%3C/circle%3E%3Ccircle cx='22' cy='22' r='6' stroke-opacity='0'%3E%3Canimate attributeName='r' begin='3s' dur='3s' values='6;22' calcMode='linear' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-opacity' begin='3s' dur='3s' values='1;0' calcMode='linear' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-width' begin='3s' dur='3s' values='2;0' calcMode='linear' repeatCount='indefinite' /%3E%3C/circle%3E%3Ccircle cx='22' cy='22' r='8'%3E%3Canimate attributeName='r' begin='0s' dur='1.5s' values='6;1;2;3;4;5;6' calcMode='linear' repeatCount='indefinite' /%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");
}

.%prefix%-logo.error {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 70 70'%3E%3Cdefs/%3E%3Ccircle cx='35' cy='35' r='35' fill='%23FC3D39'/%3E%3Cpath fill='%23fff' d='M22.3 48h25.4c2.5 0 4-1.7 4-4a4 4 0 00-.5-2L38.5 19.3a4 4 0 00-3.5-2 4 4 0 00-3.5 2L18.8 42.1c-.3.6-.5 1.3-.5 2 0 2.2 1.6 4 4 4zM35 37c-.9 0-1.4-.6-1.4-1.5l-.2-7.7c0-.9.6-1.6 1.6-1.6s1.7.7 1.7 1.6l-.3 7.7c0 1-.5 1.5-1.4 1.5zm0 6c-1 0-1.9-.8-1.9-1.8s.9-1.8 2-1.8c1 0 1.8.7 1.8 1.8 0 1-.9 1.8-1.9 1.8z'/%3E%3C/svg%3E");
}

.%prefix%-logo.success {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 70 70'%3E%3Cdefs/%3E%3Ccircle cx='35' cy='35' r='35' fill='%233DC55D'/%3E%3Cpath fill='%23fff' d='M30.9 49.7a2 2 0 001.8-1L48 24.9c.3-.5.4-1 .4-1.4 0-1-.7-1.7-1.7-1.7-.8 0-1.2.3-1.6 1L30.8 45.4 23.5 36c-.5-.6-1-.9-1.6-.9-1 0-1.8.8-1.8 1.8 0 .4.2.9.6 1.3L29 48.7c.6.7 1.1 1 1.9 1z'/%3E%3C/svg%3E");
}

.%prefix%-request {
    padding: 20px;
    border-radius: 20px;
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    background: white;
}

.%prefix%-fee,
.%prefix%-info {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.%prefix%-title {
    color: #000000;
    font-size: 25px;
    margin-top: 14px;
    font-weight: 700;
    line-height: 30px;
    letter-spacing: 0.5px;
}

.%prefix%-subtitle {
    margin-top: 14px;
    color: #5C5C5C;
    text-align: center;
    line-height: 1.4;
    word-break: break-word;
}

.%prefix%-subtitle a {
    color: #000000;
    cursor: pointer;
    text-decoration: underline;
}

.%prefix%-actions {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.%prefix%-uri {
    width: 100%;
}

.%prefix%-button {
    color: #007AFF;
    background: #EFF1F7;
    border: 1px solid #EFF1F7;
    text-decoration: none;
    font-size: 17px;
    flex-grow: 1;
    flex: 1;
    width: 100%;
    line-height: 1;
    padding: 20px 18px;
    border-radius: 12px;
    font-weight: 400;
    text-align: center;
    display: block;
    margin-top: 21px;
    cursor: pointer;
}

.%prefix%-button:hover {
    border: 1px solid #007AFF;
}

.%prefix%-qr {
    margin-top: 21px;
}

.%prefix%-qr svg {
    width: 100%;
    display: block;
    shape-rendering: crispEdges;
}

.%prefix%-qr svg rect {
    fill: black;
}

.%prefix%-footnote {
    text-align: center;
    width: 100%;
    position: absolute;
    bottom: -26px;
    left: 0;
    color: white;
}

.%prefix%-footnote a {
    color: white;
    text-decoration: underline;
}

.%prefix%-wskeepalive {
    display: none;
}

.%prefix%-choice {
    text-align: center;
    width: 100%;
    color: #666;
}

.%prefix%-choice span {
    display: block;
    margin-top: 1em;
}

.%prefix%-choice a:not(.%prefix%-button) {
    display: block;
    cursor: pointer;
    text-decoration: underline;
    margin-top: 1em;
}

@media (prefers-color-scheme: dark) {
    .%prefix%-inner {
        background: #262D43;
        color: white;
    }
    .%prefix%-request {
        background: #131B33;
    }
    .%prefix%-title {
        color: #FCFCFC;
    }
    .%prefix%-subtitle {
        color: #B8C0DA;
    }
    .%prefix%-subtitle a {
        color: #FCFCFC;
    }
    .%prefix%-qr svg rect {
        fill: white;
    }
    .%prefix%-version {
        color: #546AAF;
    }
    .%prefix%-choice {
        color: #888ea1;
    }
    .%prefix%-button {
        color: #FCFCFC;
        background: #262D43;
        border: 1px solid #262D43;
    }
    .%prefix%-button:hover {
        color: #FCFCFC;
        border: 1px solid #FCFCFC;
        background: #333A50;
    }
    .%prefix%-close {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M.57 12.1a.96.96 0 000 1.34c.37.36 1 .36 1.34 0L7 8.37l5.09 5.09c.36.35.97.35 1.34-.01a.96.96 0 000-1.34L8.34 7.01l5.08-5.08a.95.95 0 000-1.33.97.97 0 00-1.34-.01L6.99 5.68 1.91.59a.96.96 0 00-1.33 0 .97.97 0 00-.01 1.34l5.09 5.08-5.1 5.1z' fill='%23FCFCFC'/%3E%3C/svg%3E");
    }
    .%prefix%-close:hover {
        background-color: black;
    }
}

@media (max-height: 600px) { .%prefix%-inner { transform: scale(0.9); } }
@media (max-height: 540px) { .%prefix%-inner { transform: scale(0.8); } }
@media (max-height: 480px) { .%prefix%-inner { transform: scale(0.7); } }
@media (max-height: 420px) { .%prefix%-inner { transform: scale(0.6); } }
@media (max-height: 360px) { .%prefix%-inner { transform: scale(0.5); } }
@media (max-height: 300px) { .%prefix%-inner { transform: scale(0.4); } }

`;
      var ErrorCorrectLevel = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
      };
      var Mode = {
        MODE_NUMBER: 1 << 0,
        MODE_ALPHA_NUM: 1 << 1,
        MODE_8BIT_BYTE: 1 << 2,
        MODE_KANJI: 1 << 3
      };
      var QR8bitByte = function() {
        function QR8bitByte2(data) {
          this.mode = Mode.MODE_8BIT_BYTE;
          this.data = data;
        }
        QR8bitByte2.prototype.getLength = function() {
          return this.data.length;
        };
        QR8bitByte2.prototype.write = function(buffer) {
          for (var i2 = 0; i2 < this.data.length; i2++) {
            buffer.put(this.data.charCodeAt(i2), 8);
          }
        };
        return QR8bitByte2;
      }();
      var QRBitBuffer = function() {
        function QRBitBuffer2() {
          this.buffer = [];
          this.length = 0;
        }
        QRBitBuffer2.prototype.get = function(index) {
          var bufIndex = Math.floor(index / 8);
          return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
        };
        QRBitBuffer2.prototype.put = function(num, length) {
          for (var i2 = 0; i2 < length; i2++) {
            this.putBit((num >>> length - i2 - 1 & 1) == 1);
          }
        };
        QRBitBuffer2.prototype.getLengthInBits = function() {
          return this.length;
        };
        QRBitBuffer2.prototype.putBit = function(bit) {
          var bufIndex = Math.floor(this.length / 8);
          if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
          }
          if (bit) {
            this.buffer[bufIndex] |= 128 >>> this.length % 8;
          }
          this.length++;
        };
        return QRBitBuffer2;
      }();
      var QRMath = {
        glog: function(n) {
          if (n < 1) {
            throw new Error("glog(" + n + ")");
          }
          return QRMath.LOG_TABLE[n];
        },
        gexp: function(n) {
          while (n < 0) {
            n += 255;
          }
          while (n >= 256) {
            n -= 255;
          }
          return QRMath.EXP_TABLE[n];
        },
        EXP_TABLE: new Array(256),
        LOG_TABLE: new Array(256)
      };
      for (var i = 0; i < 8; i++) {
        QRMath.EXP_TABLE[i] = 1 << i;
      }
      for (var i = 8; i < 256; i++) {
        QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
      }
      for (var i = 0; i < 255; i++) {
        QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
      }
      var QRPolynomial = function() {
        function QRPolynomial2(num, shift) {
          if (num.length == void 0) {
            throw new Error(num.length + "/" + shift);
          }
          var offset = 0;
          while (offset < num.length && num[offset] == 0) {
            offset++;
          }
          this.num = new Array(num.length - offset + shift);
          for (var i2 = 0; i2 < num.length - offset; i2++) {
            this.num[i2] = num[i2 + offset];
          }
        }
        QRPolynomial2.prototype.get = function(index) {
          return this.num[index];
        };
        QRPolynomial2.prototype.getLength = function() {
          return this.num.length;
        };
        QRPolynomial2.prototype.multiply = function(e) {
          var num = new Array(this.getLength() + e.getLength() - 1);
          for (var i2 = 0; i2 < this.getLength(); i2++) {
            for (var j = 0; j < e.getLength(); j++) {
              num[i2 + j] ^= QRMath.gexp(QRMath.glog(this.get(i2)) + QRMath.glog(e.get(j)));
            }
          }
          return new QRPolynomial2(num, 0);
        };
        QRPolynomial2.prototype.mod = function(e) {
          if (this.getLength() - e.getLength() < 0) {
            return this;
          }
          var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
          var num = new Array(this.getLength());
          for (var i2 = 0; i2 < this.getLength(); i2++) {
            num[i2] = this.get(i2);
          }
          for (var i2 = 0; i2 < e.getLength(); i2++) {
            num[i2] ^= QRMath.gexp(QRMath.glog(e.get(i2)) + ratio);
          }
          return new QRPolynomial2(num, 0).mod(e);
        };
        return QRPolynomial2;
      }();
      var QRRSBlock = function() {
        function QRRSBlock2(totalCount, dataCount) {
          this.totalCount = totalCount;
          this.dataCount = dataCount;
        }
        QRRSBlock2.getRSBlocks = function(typeNumber, errorCorrectLevel) {
          var rsBlock = QRRSBlock2.getRsBlockTable(typeNumber, errorCorrectLevel);
          if (rsBlock == void 0) {
            throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
          }
          var length = rsBlock.length / 3;
          var list = [];
          for (var i2 = 0; i2 < length; i2++) {
            var count = rsBlock[i2 * 3 + 0];
            var totalCount = rsBlock[i2 * 3 + 1];
            var dataCount = rsBlock[i2 * 3 + 2];
            for (var j = 0; j < count; j++) {
              list.push(new QRRSBlock2(totalCount, dataCount));
            }
          }
          return list;
        };
        QRRSBlock2.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
          switch (errorCorrectLevel) {
            case ErrorCorrectLevel.L:
              return QRRSBlock2.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
            case ErrorCorrectLevel.M:
              return QRRSBlock2.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
            case ErrorCorrectLevel.Q:
              return QRRSBlock2.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
            case ErrorCorrectLevel.H:
              return QRRSBlock2.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
            default:
              return void 0;
          }
        };
        QRRSBlock2.RS_BLOCK_TABLE = [
          [1, 26, 19],
          [1, 26, 16],
          [1, 26, 13],
          [1, 26, 9],
          [1, 44, 34],
          [1, 44, 28],
          [1, 44, 22],
          [1, 44, 16],
          [1, 70, 55],
          [1, 70, 44],
          [2, 35, 17],
          [2, 35, 13],
          [1, 100, 80],
          [2, 50, 32],
          [2, 50, 24],
          [4, 25, 9],
          [1, 134, 108],
          [2, 67, 43],
          [2, 33, 15, 2, 34, 16],
          [2, 33, 11, 2, 34, 12],
          [2, 86, 68],
          [4, 43, 27],
          [4, 43, 19],
          [4, 43, 15],
          [2, 98, 78],
          [4, 49, 31],
          [2, 32, 14, 4, 33, 15],
          [4, 39, 13, 1, 40, 14],
          [2, 121, 97],
          [2, 60, 38, 2, 61, 39],
          [4, 40, 18, 2, 41, 19],
          [4, 40, 14, 2, 41, 15],
          [2, 146, 116],
          [3, 58, 36, 2, 59, 37],
          [4, 36, 16, 4, 37, 17],
          [4, 36, 12, 4, 37, 13],
          [2, 86, 68, 2, 87, 69],
          [4, 69, 43, 1, 70, 44],
          [6, 43, 19, 2, 44, 20],
          [6, 43, 15, 2, 44, 16],
          [4, 101, 81],
          [1, 80, 50, 4, 81, 51],
          [4, 50, 22, 4, 51, 23],
          [3, 36, 12, 8, 37, 13],
          [2, 116, 92, 2, 117, 93],
          [6, 58, 36, 2, 59, 37],
          [4, 46, 20, 6, 47, 21],
          [7, 42, 14, 4, 43, 15],
          [4, 133, 107],
          [8, 59, 37, 1, 60, 38],
          [8, 44, 20, 4, 45, 21],
          [12, 33, 11, 4, 34, 12],
          [3, 145, 115, 1, 146, 116],
          [4, 64, 40, 5, 65, 41],
          [11, 36, 16, 5, 37, 17],
          [11, 36, 12, 5, 37, 13],
          [5, 109, 87, 1, 110, 88],
          [5, 65, 41, 5, 66, 42],
          [5, 54, 24, 7, 55, 25],
          [11, 36, 12],
          [5, 122, 98, 1, 123, 99],
          [7, 73, 45, 3, 74, 46],
          [15, 43, 19, 2, 44, 20],
          [3, 45, 15, 13, 46, 16],
          [1, 135, 107, 5, 136, 108],
          [10, 74, 46, 1, 75, 47],
          [1, 50, 22, 15, 51, 23],
          [2, 42, 14, 17, 43, 15],
          [5, 150, 120, 1, 151, 121],
          [9, 69, 43, 4, 70, 44],
          [17, 50, 22, 1, 51, 23],
          [2, 42, 14, 19, 43, 15],
          [3, 141, 113, 4, 142, 114],
          [3, 70, 44, 11, 71, 45],
          [17, 47, 21, 4, 48, 22],
          [9, 39, 13, 16, 40, 14],
          [3, 135, 107, 5, 136, 108],
          [3, 67, 41, 13, 68, 42],
          [15, 54, 24, 5, 55, 25],
          [15, 43, 15, 10, 44, 16],
          [4, 144, 116, 4, 145, 117],
          [17, 68, 42],
          [17, 50, 22, 6, 51, 23],
          [19, 46, 16, 6, 47, 17],
          [2, 139, 111, 7, 140, 112],
          [17, 74, 46],
          [7, 54, 24, 16, 55, 25],
          [34, 37, 13],
          [4, 151, 121, 5, 152, 122],
          [4, 75, 47, 14, 76, 48],
          [11, 54, 24, 14, 55, 25],
          [16, 45, 15, 14, 46, 16],
          [6, 147, 117, 4, 148, 118],
          [6, 73, 45, 14, 74, 46],
          [11, 54, 24, 16, 55, 25],
          [30, 46, 16, 2, 47, 17],
          [8, 132, 106, 4, 133, 107],
          [8, 75, 47, 13, 76, 48],
          [7, 54, 24, 22, 55, 25],
          [22, 45, 15, 13, 46, 16],
          [10, 142, 114, 2, 143, 115],
          [19, 74, 46, 4, 75, 47],
          [28, 50, 22, 6, 51, 23],
          [33, 46, 16, 4, 47, 17],
          [8, 152, 122, 4, 153, 123],
          [22, 73, 45, 3, 74, 46],
          [8, 53, 23, 26, 54, 24],
          [12, 45, 15, 28, 46, 16],
          [3, 147, 117, 10, 148, 118],
          [3, 73, 45, 23, 74, 46],
          [4, 54, 24, 31, 55, 25],
          [11, 45, 15, 31, 46, 16],
          [7, 146, 116, 7, 147, 117],
          [21, 73, 45, 7, 74, 46],
          [1, 53, 23, 37, 54, 24],
          [19, 45, 15, 26, 46, 16],
          [5, 145, 115, 10, 146, 116],
          [19, 75, 47, 10, 76, 48],
          [15, 54, 24, 25, 55, 25],
          [23, 45, 15, 25, 46, 16],
          [13, 145, 115, 3, 146, 116],
          [2, 74, 46, 29, 75, 47],
          [42, 54, 24, 1, 55, 25],
          [23, 45, 15, 28, 46, 16],
          [17, 145, 115],
          [10, 74, 46, 23, 75, 47],
          [10, 54, 24, 35, 55, 25],
          [19, 45, 15, 35, 46, 16],
          [17, 145, 115, 1, 146, 116],
          [14, 74, 46, 21, 75, 47],
          [29, 54, 24, 19, 55, 25],
          [11, 45, 15, 46, 46, 16],
          [13, 145, 115, 6, 146, 116],
          [14, 74, 46, 23, 75, 47],
          [44, 54, 24, 7, 55, 25],
          [59, 46, 16, 1, 47, 17],
          [12, 151, 121, 7, 152, 122],
          [12, 75, 47, 26, 76, 48],
          [39, 54, 24, 14, 55, 25],
          [22, 45, 15, 41, 46, 16],
          [6, 151, 121, 14, 152, 122],
          [6, 75, 47, 34, 76, 48],
          [46, 54, 24, 10, 55, 25],
          [2, 45, 15, 64, 46, 16],
          [17, 152, 122, 4, 153, 123],
          [29, 74, 46, 14, 75, 47],
          [49, 54, 24, 10, 55, 25],
          [24, 45, 15, 46, 46, 16],
          [4, 152, 122, 18, 153, 123],
          [13, 74, 46, 32, 75, 47],
          [48, 54, 24, 14, 55, 25],
          [42, 45, 15, 32, 46, 16],
          [20, 147, 117, 4, 148, 118],
          [40, 75, 47, 7, 76, 48],
          [43, 54, 24, 22, 55, 25],
          [10, 45, 15, 67, 46, 16],
          [19, 148, 118, 6, 149, 119],
          [18, 75, 47, 31, 76, 48],
          [34, 54, 24, 34, 55, 25],
          [20, 45, 15, 61, 46, 16]
        ];
        return QRRSBlock2;
      }();
      var QRMaskPattern = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
      };
      var QRUtil = {
        PATTERN_POSITION_TABLE: [
          [],
          [6, 18],
          [6, 22],
          [6, 26],
          [6, 30],
          [6, 34],
          [6, 22, 38],
          [6, 24, 42],
          [6, 26, 46],
          [6, 28, 50],
          [6, 30, 54],
          [6, 32, 58],
          [6, 34, 62],
          [6, 26, 46, 66],
          [6, 26, 48, 70],
          [6, 26, 50, 74],
          [6, 30, 54, 78],
          [6, 30, 56, 82],
          [6, 30, 58, 86],
          [6, 34, 62, 90],
          [6, 28, 50, 72, 94],
          [6, 26, 50, 74, 98],
          [6, 30, 54, 78, 102],
          [6, 28, 54, 80, 106],
          [6, 32, 58, 84, 110],
          [6, 30, 58, 86, 114],
          [6, 34, 62, 90, 118],
          [6, 26, 50, 74, 98, 122],
          [6, 30, 54, 78, 102, 126],
          [6, 26, 52, 78, 104, 130],
          [6, 30, 56, 82, 108, 134],
          [6, 34, 60, 86, 112, 138],
          [6, 30, 58, 86, 114, 142],
          [6, 34, 62, 90, 118, 146],
          [6, 30, 54, 78, 102, 126, 150],
          [6, 24, 50, 76, 102, 128, 154],
          [6, 28, 54, 80, 106, 132, 158],
          [6, 32, 58, 84, 110, 136, 162],
          [6, 26, 54, 82, 110, 138, 166],
          [6, 30, 58, 86, 114, 142, 170]
        ],
        G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
        G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
        G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
        getBCHTypeInfo: function(data) {
          var d = data << 10;
          while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
            d ^= QRUtil.G15 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15);
          }
          return (data << 10 | d) ^ QRUtil.G15_MASK;
        },
        getBCHTypeNumber: function(data) {
          var d = data << 12;
          while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
            d ^= QRUtil.G18 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18);
          }
          return data << 12 | d;
        },
        getBCHDigit: function(data) {
          var digit = 0;
          while (data != 0) {
            digit++;
            data >>>= 1;
          }
          return digit;
        },
        getPatternPosition: function(typeNumber) {
          return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
        },
        getMask: function(maskPattern, i2, j) {
          switch (maskPattern) {
            case QRMaskPattern.PATTERN000:
              return (i2 + j) % 2 == 0;
            case QRMaskPattern.PATTERN001:
              return i2 % 2 == 0;
            case QRMaskPattern.PATTERN010:
              return j % 3 == 0;
            case QRMaskPattern.PATTERN011:
              return (i2 + j) % 3 == 0;
            case QRMaskPattern.PATTERN100:
              return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 == 0;
            case QRMaskPattern.PATTERN101:
              return i2 * j % 2 + i2 * j % 3 == 0;
            case QRMaskPattern.PATTERN110:
              return (i2 * j % 2 + i2 * j % 3) % 2 == 0;
            case QRMaskPattern.PATTERN111:
              return (i2 * j % 3 + (i2 + j) % 2) % 2 == 0;
            default:
              throw new Error("bad maskPattern:" + maskPattern);
          }
        },
        getErrorCorrectPolynomial: function(errorCorrectLength) {
          var a = new QRPolynomial([1], 0);
          for (var i2 = 0; i2 < errorCorrectLength; i2++) {
            a = a.multiply(new QRPolynomial([1, QRMath.gexp(i2)], 0));
          }
          return a;
        },
        getLengthInBits: function(mode, type) {
          if (1 <= type && type < 10) {
            switch (mode) {
              case Mode.MODE_NUMBER:
                return 10;
              case Mode.MODE_ALPHA_NUM:
                return 9;
              case Mode.MODE_8BIT_BYTE:
                return 8;
              case Mode.MODE_KANJI:
                return 8;
              default:
                throw new Error("mode:" + mode);
            }
          } else if (type < 27) {
            switch (mode) {
              case Mode.MODE_NUMBER:
                return 12;
              case Mode.MODE_ALPHA_NUM:
                return 11;
              case Mode.MODE_8BIT_BYTE:
                return 16;
              case Mode.MODE_KANJI:
                return 10;
              default:
                throw new Error("mode:" + mode);
            }
          } else if (type < 41) {
            switch (mode) {
              case Mode.MODE_NUMBER:
                return 14;
              case Mode.MODE_ALPHA_NUM:
                return 13;
              case Mode.MODE_8BIT_BYTE:
                return 16;
              case Mode.MODE_KANJI:
                return 12;
              default:
                throw new Error("mode:" + mode);
            }
          } else {
            throw new Error("type:" + type);
          }
        },
        getLostPoint: function(qrCode) {
          var moduleCount = qrCode.getModuleCount();
          var lostPoint = 0;
          for (var row = 0; row < moduleCount; row++) {
            for (var col = 0; col < moduleCount; col++) {
              var sameCount = 0;
              var dark = qrCode.isDark(row, col);
              for (var r = -1; r <= 1; r++) {
                if (row + r < 0 || moduleCount <= row + r) {
                  continue;
                }
                for (var c = -1; c <= 1; c++) {
                  if (col + c < 0 || moduleCount <= col + c) {
                    continue;
                  }
                  if (r == 0 && c == 0) {
                    continue;
                  }
                  if (dark == qrCode.isDark(row + r, col + c)) {
                    sameCount++;
                  }
                }
              }
              if (sameCount > 5) {
                lostPoint += 3 + sameCount - 5;
              }
            }
          }
          for (var row = 0; row < moduleCount - 1; row++) {
            for (var col = 0; col < moduleCount - 1; col++) {
              var count = 0;
              if (qrCode.isDark(row, col))
                count++;
              if (qrCode.isDark(row + 1, col))
                count++;
              if (qrCode.isDark(row, col + 1))
                count++;
              if (qrCode.isDark(row + 1, col + 1))
                count++;
              if (count == 0 || count == 4) {
                lostPoint += 3;
              }
            }
          }
          for (var row = 0; row < moduleCount; row++) {
            for (var col = 0; col < moduleCount - 6; col++) {
              if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
                lostPoint += 40;
              }
            }
          }
          for (var col = 0; col < moduleCount; col++) {
            for (var row = 0; row < moduleCount - 6; row++) {
              if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
                lostPoint += 40;
              }
            }
          }
          var darkCount = 0;
          for (var col = 0; col < moduleCount; col++) {
            for (var row = 0; row < moduleCount; row++) {
              if (qrCode.isDark(row, col)) {
                darkCount++;
              }
            }
          }
          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
          lostPoint += ratio * 10;
          return lostPoint;
        }
      };
      var QRCode = function() {
        function QRCode2(typeNumber, errorCorrectLevel) {
          this.typeNumber = typeNumber;
          this.errorCorrectLevel = errorCorrectLevel;
          this.modules = null;
          this.moduleCount = 0;
          this.dataCache = null;
          this.dataList = [];
        }
        QRCode2.prototype.addData = function(data) {
          var newData = new QR8bitByte(data);
          this.dataList.push(newData);
          this.dataCache = null;
        };
        QRCode2.prototype.isDark = function(row, col) {
          if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
            throw new Error(row + "," + col);
          }
          return this.modules[row][col];
        };
        QRCode2.prototype.getModuleCount = function() {
          return this.moduleCount;
        };
        QRCode2.prototype.make = function() {
          if (this.typeNumber < 1) {
            var typeNumber = 1;
            for (typeNumber = 1; typeNumber < 40; typeNumber++) {
              var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
              var buffer = new QRBitBuffer();
              var totalDataCount = 0;
              for (var i2 = 0; i2 < rsBlocks.length; i2++) {
                totalDataCount += rsBlocks[i2].dataCount;
              }
              for (var i2 = 0; i2 < this.dataList.length; i2++) {
                var data = this.dataList[i2];
                buffer.put(data.mode, 4);
                buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
                data.write(buffer);
              }
              if (buffer.getLengthInBits() <= totalDataCount * 8)
                break;
            }
            this.typeNumber = typeNumber;
          }
          this.makeImpl(false, this.getBestMaskPattern());
        };
        QRCode2.prototype.makeImpl = function(test, maskPattern) {
          this.moduleCount = this.typeNumber * 4 + 17;
          this.modules = new Array(this.moduleCount);
          for (var row = 0; row < this.moduleCount; row++) {
            this.modules[row] = new Array(this.moduleCount);
            for (var col = 0; col < this.moduleCount; col++) {
              this.modules[row][col] = null;
            }
          }
          this.setupPositionProbePattern(0, 0);
          this.setupPositionProbePattern(this.moduleCount - 7, 0);
          this.setupPositionProbePattern(0, this.moduleCount - 7);
          this.setupPositionAdjustPattern();
          this.setupTimingPattern();
          this.setupTypeInfo(test, maskPattern);
          if (this.typeNumber >= 7) {
            this.setupTypeNumber(test);
          }
          if (this.dataCache == null) {
            this.dataCache = QRCode2.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
          }
          this.mapData(this.dataCache, maskPattern);
        };
        QRCode2.prototype.setupPositionProbePattern = function(row, col) {
          for (var r = -1; r <= 7; r++) {
            if (row + r <= -1 || this.moduleCount <= row + r)
              continue;
            for (var c = -1; c <= 7; c++) {
              if (col + c <= -1 || this.moduleCount <= col + c)
                continue;
              if (0 <= r && r <= 6 && (c == 0 || c == 6) || 0 <= c && c <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c && c <= 4) {
                this.modules[row + r][col + c] = true;
              } else {
                this.modules[row + r][col + c] = false;
              }
            }
          }
        };
        QRCode2.prototype.getBestMaskPattern = function() {
          var minLostPoint = 0;
          var pattern = 0;
          for (var i2 = 0; i2 < 8; i2++) {
            this.makeImpl(true, i2);
            var lostPoint = QRUtil.getLostPoint(this);
            if (i2 == 0 || minLostPoint > lostPoint) {
              minLostPoint = lostPoint;
              pattern = i2;
            }
          }
          return pattern;
        };
        QRCode2.prototype.setupTimingPattern = function() {
          for (var r = 8; r < this.moduleCount - 8; r++) {
            if (this.modules[r][6] != null) {
              continue;
            }
            this.modules[r][6] = r % 2 == 0;
          }
          for (var c = 8; c < this.moduleCount - 8; c++) {
            if (this.modules[6][c] != null) {
              continue;
            }
            this.modules[6][c] = c % 2 == 0;
          }
        };
        QRCode2.prototype.setupPositionAdjustPattern = function() {
          var pos = QRUtil.getPatternPosition(this.typeNumber);
          for (var i2 = 0; i2 < pos.length; i2++) {
            for (var j = 0; j < pos.length; j++) {
              var row = pos[i2];
              var col = pos[j];
              if (this.modules[row][col] != null) {
                continue;
              }
              for (var r = -2; r <= 2; r++) {
                for (var c = -2; c <= 2; c++) {
                  if (r == -2 || r == 2 || c == -2 || c == 2 || r == 0 && c == 0) {
                    this.modules[row + r][col + c] = true;
                  } else {
                    this.modules[row + r][col + c] = false;
                  }
                }
              }
            }
          }
        };
        QRCode2.prototype.setupTypeNumber = function(test) {
          var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
          for (var i2 = 0; i2 < 18; i2++) {
            var mod = !test && (bits >> i2 & 1) == 1;
            this.modules[Math.floor(i2 / 3)][i2 % 3 + this.moduleCount - 8 - 3] = mod;
          }
          for (var i2 = 0; i2 < 18; i2++) {
            var mod = !test && (bits >> i2 & 1) == 1;
            this.modules[i2 % 3 + this.moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod;
          }
        };
        QRCode2.prototype.setupTypeInfo = function(test, maskPattern) {
          var data = this.errorCorrectLevel << 3 | maskPattern;
          var bits = QRUtil.getBCHTypeInfo(data);
          for (var i2 = 0; i2 < 15; i2++) {
            var mod = !test && (bits >> i2 & 1) == 1;
            if (i2 < 6) {
              this.modules[i2][8] = mod;
            } else if (i2 < 8) {
              this.modules[i2 + 1][8] = mod;
            } else {
              this.modules[this.moduleCount - 15 + i2][8] = mod;
            }
          }
          for (var i2 = 0; i2 < 15; i2++) {
            var mod = !test && (bits >> i2 & 1) == 1;
            if (i2 < 8) {
              this.modules[8][this.moduleCount - i2 - 1] = mod;
            } else if (i2 < 9) {
              this.modules[8][15 - i2 - 1 + 1] = mod;
            } else {
              this.modules[8][15 - i2 - 1] = mod;
            }
          }
          this.modules[this.moduleCount - 8][8] = !test;
        };
        QRCode2.prototype.mapData = function(data, maskPattern) {
          var inc = -1;
          var row = this.moduleCount - 1;
          var bitIndex = 7;
          var byteIndex = 0;
          for (var col = this.moduleCount - 1; col > 0; col -= 2) {
            if (col == 6)
              col--;
            for (; ; ) {
              for (var c = 0; c < 2; c++) {
                if (this.modules[row][col - c] == null) {
                  var dark = false;
                  if (byteIndex < data.length) {
                    dark = (data[byteIndex] >>> bitIndex & 1) == 1;
                  }
                  var mask = QRUtil.getMask(maskPattern, row, col - c);
                  if (mask) {
                    dark = !dark;
                  }
                  this.modules[row][col - c] = dark;
                  bitIndex--;
                  if (bitIndex == -1) {
                    byteIndex++;
                    bitIndex = 7;
                  }
                }
              }
              row += inc;
              if (row < 0 || this.moduleCount <= row) {
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        };
        QRCode2.createData = function(typeNumber, errorCorrectLevel, dataList) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
          var buffer = new QRBitBuffer();
          for (var i2 = 0; i2 < dataList.length; i2++) {
            var data = dataList[i2];
            buffer.put(data.mode, 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
            data.write(buffer);
          }
          var totalDataCount = 0;
          for (var i2 = 0; i2 < rsBlocks.length; i2++) {
            totalDataCount += rsBlocks[i2].dataCount;
          }
          if (buffer.getLengthInBits() > totalDataCount * 8) {
            throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
          }
          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
          }
          while (buffer.getLengthInBits() % 8 != 0) {
            buffer.putBit(false);
          }
          for (; ; ) {
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(QRCode2.PAD0, 8);
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(QRCode2.PAD1, 8);
          }
          return QRCode2.createBytes(buffer, rsBlocks);
        };
        QRCode2.createBytes = function(buffer, rsBlocks) {
          var offset = 0;
          var maxDcCount = 0;
          var maxEcCount = 0;
          var dcdata = new Array(rsBlocks.length);
          var ecdata = new Array(rsBlocks.length);
          for (var r = 0; r < rsBlocks.length; r++) {
            var dcCount = rsBlocks[r].dataCount;
            var ecCount = rsBlocks[r].totalCount - dcCount;
            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);
            dcdata[r] = new Array(dcCount);
            for (var i2 = 0; i2 < dcdata[r].length; i2++) {
              dcdata[r][i2] = 255 & buffer.buffer[i2 + offset];
            }
            offset += dcCount;
            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
            var modPoly = rawPoly.mod(rsPoly);
            ecdata[r] = new Array(rsPoly.getLength() - 1);
            for (var i2 = 0; i2 < ecdata[r].length; i2++) {
              var modIndex = i2 + modPoly.getLength() - ecdata[r].length;
              ecdata[r][i2] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
            }
          }
          var totalCodeCount = 0;
          for (var i2 = 0; i2 < rsBlocks.length; i2++) {
            totalCodeCount += rsBlocks[i2].totalCount;
          }
          var data = new Array(totalCodeCount);
          var index = 0;
          for (var i2 = 0; i2 < maxDcCount; i2++) {
            for (var r = 0; r < rsBlocks.length; r++) {
              if (i2 < dcdata[r].length) {
                data[index++] = dcdata[r][i2];
              }
            }
          }
          for (var i2 = 0; i2 < maxEcCount; i2++) {
            for (var r = 0; r < rsBlocks.length; r++) {
              if (i2 < ecdata[r].length) {
                data[index++] = ecdata[r][i2];
              }
            }
          }
          return data;
        };
        QRCode2.PAD0 = 236;
        QRCode2.PAD1 = 17;
        return QRCode2;
      }();
      function generate(text, level, version3) {
        var e_1, _a, e_2, _b, e_3, _c;
        if (level === void 0) {
          level = "L";
        }
        if (version3 === void 0) {
          version3 = -1;
        }
        var qr = new QRCode(version3, ErrorCorrectLevel[level]);
        var rects = [];
        qr.addData(text);
        qr.make();
        var rows = qr.modules;
        var size = rows.length;
        try {
          for (var _d = tslib.__values(rows.entries()), _e = _d.next(); !_e.done; _e = _d.next()) {
            var _f = tslib.__read(_e.value, 2), y = _f[0], row = _f[1];
            var rect = void 0;
            try {
              for (var _g = (e_2 = void 0, tslib.__values(row.entries())), _h = _g.next(); !_h.done; _h = _g.next()) {
                var _j = tslib.__read(_h.value, 2), x = _j[0], on = _j[1];
                if (on) {
                  if (!rect)
                    rect = { x, y, width: 0, height: 1 };
                  rect.width++;
                } else {
                  if (rect && rect.width > 0) {
                    rects.push(rect);
                  }
                  rect = void 0;
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_h && !_h.done && (_b = _g.return))
                  _b.call(_g);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
            if (rect && rect.width > 0) {
              rects.push(rect);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_e && !_e.done && (_a = _d.return))
              _a.call(_d);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var svg = ['<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ' + size + " " + size + '">'];
        try {
          for (var rects_1 = tslib.__values(rects), rects_1_1 = rects_1.next(); !rects_1_1.done; rects_1_1 = rects_1.next()) {
            var _k = rects_1_1.value, x = _k.x, y = _k.y, width = _k.width, height = _k.height;
            svg.push('<rect x="' + x + '" y="' + y + '" width="' + width + '" height="' + height + '" />');
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (rects_1_1 && !rects_1_1.done && (_c = rects_1.return))
              _c.call(rects_1);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        svg.push("</svg>");
        return svg.join("");
      }
      function apiCall(url, body) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, fetch(url, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json"
                  },
                  body: body ? JSON.stringify(body) : void 0
                })];
              case 1:
                return [2, _a.sent().json()];
            }
          });
        });
      }
      var version2 = "fuel/2";
      function compareVersion(otherVersion) {
        return parseVersion(otherVersion) >= parseVersion(version2);
      }
      function parseVersion(string) {
        var parts = string.trim().split("/");
        if (parts.length === 2 && parts[0] === "fuel") {
          return parseInt(parts[1]) || 0;
        }
        return -1;
      }
      function fuel(request, session, updatePrepareStatus, supportedChains, referrer) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var chainId, nodeUrl, result, cloned, signatures, _a;
          return tslib.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                assertEligible(request, session);
                updatePrepareStatus("Detecting if network resources are required.");
                chainId = request.getChainId();
                nodeUrl = supportedChains[String(chainId)];
                if (!nodeUrl) {
                  throw new Error("Blockchain not supported by this resource provider.");
                }
                return [4, apiCall(nodeUrl + "/v1/resource_provider/request_transaction", {
                  ref: referrer,
                  request,
                  signer: session.auth
                })];
              case 1:
                result = _b.sent();
                if (!result || !result.data) {
                  throw new Error("Invalid response from resource provider.");
                }
                if (!result.data.signatures || !result.data.signatures[0]) {
                  throw new Error("No signature returned from resource provider.");
                }
                if (result.code === 402 && !result.data.fee) {
                  throw new Error("Resource provider returned a response indicating required payment, but provided no fee amount.");
                }
                cloned = request.clone();
                if (result.code === 402) {
                  if (request.getInfoKey("no_fee")) {
                    throw new Error("Fee required but sender opted out.");
                  }
                  cloned.setInfoKey("txfee", result.data.fee);
                }
                if (result.data.costs) {
                  cloned.setInfoKey("txfeecpu", result.data.costs.cpu);
                  cloned.setInfoKey("txfeenet", result.data.costs.net);
                  cloned.setInfoKey("txfeeram", result.data.costs.ram);
                }
                signatures = result.data.signatures.map(function(s) {
                  return anchorLink.Signature.from(s);
                });
                cloned.setInfoKey("cosig", signatures, { type: anchorLink.Signature, array: true });
                _a = cloned.data;
                return [4, anchorLink.SigningRequest.create({ transaction: tslib.__assign({}, result.data.request[1]) }, { abiProvider: request.abiProvider })];
              case 2:
                _a.req = _b.sent().data.req;
                return [2, cloned];
            }
          });
        });
      }
      function assertEligible(request, session) {
        if (request.getRawInfoKey("no_modify")) {
          throw new Error("Request cannot be modified.");
        }
        if (request.isIdentity()) {
          throw new Error("Identity requests cannot be co-signed.");
        }
        var firstAction = request.getRawActions()[0];
        if (!firstAction) {
          throw new Error("No actions in request.");
        }
        var firstAuthorizer = firstAction.authorization[0];
        if (!firstAction) {
          throw new Error("First authorization missing.");
        }
        if (!firstAuthorizer.actor.equals(session.auth.actor) && !firstAuthorizer.actor.equals(anchorLink.PlaceholderName)) {
          throw new Error("Not first authorizer.");
        }
      }
      var AbortPrepare = Symbol();
      var SkipFee = Symbol();
      var defaultSupportedChains = {
        aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906: "https://eos.greymass.com",
        "2a02a0053e5a8cf73a56ba0fda11e4d92e0238a4a2aa74fccf46d5a910746840": "https://jungle3.greymass.com",
        "4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11": "https://telos.greymass.com",
        "1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4": "https://wax.greymass.com"
      };
      var Storage = function() {
        function Storage2(keyPrefix) {
          this.keyPrefix = keyPrefix;
        }
        Storage2.prototype.write = function(key, data) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            return tslib.__generator(this, function(_a) {
              localStorage.setItem(this.storageKey(key), data);
              return [2];
            });
          });
        };
        Storage2.prototype.read = function(key) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            return tslib.__generator(this, function(_a) {
              return [2, localStorage.getItem(this.storageKey(key))];
            });
          });
        };
        Storage2.prototype.remove = function(key) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            return tslib.__generator(this, function(_a) {
              localStorage.removeItem(this.storageKey(key));
              return [2];
            });
          });
        };
        Storage2.prototype.storageKey = function(key) {
          return this.keyPrefix + "-" + key;
        };
        return Storage2;
      }();
      var BrowserTransport = function() {
        function BrowserTransport2(options) {
          if (options === void 0) {
            options = {};
          }
          this.options = options;
          this.classPrefix = options.classPrefix || "anchor-link";
          this.injectStyles = !(options.injectStyles === false);
          this.importantStyles = !(options.importantStyles === false);
          this.requestStatus = !(options.requestStatus === false);
          this.fuelEnabled = options.disableGreymassFuel !== true;
          this.fuelReferrer = options.fuelReferrer || "teamgreymass";
          this.storage = new Storage(options.storagePrefix || "anchor-link");
          this.supportedChains = options.supportedChains || defaultSupportedChains;
        }
        BrowserTransport2.prototype.closeModal = function() {
          this.hide();
          if (this.activeCancel) {
            this.activeRequest = void 0;
            this.activeCancel("Modal closed");
            this.activeCancel = void 0;
          }
        };
        BrowserTransport2.prototype.setupElements = function() {
          var _this = this;
          if (this.injectStyles && !this.styleEl) {
            this.styleEl = document.createElement("style");
            this.styleEl.type = "text/css";
            var css = styleText.replace(/%prefix%/g, this.classPrefix);
            if (this.importantStyles) {
              css = css.split("\n").map(function(line) {
                return line.replace(/;$/i, " !important;");
              }).join("\n");
            }
            this.styleEl.appendChild(document.createTextNode(css));
            document.head.appendChild(this.styleEl);
          }
          if (!this.containerEl) {
            this.containerEl = this.createEl();
            this.containerEl.className = this.classPrefix;
            this.containerEl.onclick = function(event) {
              if (event.target === _this.containerEl) {
                event.stopPropagation();
                _this.closeModal();
              }
            };
            document.body.appendChild(this.containerEl);
          }
          if (!this.requestEl) {
            var wrapper = this.createEl({ class: "inner" });
            var closeButton = this.createEl({ class: "close" });
            closeButton.onclick = function(event) {
              event.stopPropagation();
              _this.closeModal();
            };
            this.requestEl = this.createEl({ class: "request" });
            wrapper.appendChild(this.requestEl);
            wrapper.appendChild(closeButton);
            var version3 = this.createEl({
              class: "version",
              text: BrowserTransport2.version + " (" + anchorLink.Link.version + ")"
            });
            version3.onclick = function(event) {
              event.stopPropagation();
              window.open("https://github.com/greymass/anchor-link", "_blank");
            };
            wrapper.appendChild(version3);
            this.containerEl.appendChild(wrapper);
          }
        };
        BrowserTransport2.prototype.createEl = function(attrs) {
          var e_1, _a;
          if (!attrs)
            attrs = {};
          var el = document.createElement(attrs.tag || "div");
          if (attrs) {
            try {
              for (var _b = tslib.__values(Object.keys(attrs)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                var value = attrs[attr];
                switch (attr) {
                  case "src":
                    el.setAttribute(attr, value);
                    break;
                  case "tag":
                    break;
                  case "text":
                    el.appendChild(document.createTextNode(value));
                    break;
                  case "class":
                    el.className = this.classPrefix + "-" + value;
                    break;
                  default:
                    el.setAttribute(attr, value);
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return))
                  _a.call(_b);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
          return el;
        };
        BrowserTransport2.prototype.hide = function() {
          if (this.containerEl) {
            this.containerEl.classList.remove(this.classPrefix + "-active");
          }
          this.clearTimers();
        };
        BrowserTransport2.prototype.show = function() {
          if (this.containerEl) {
            this.containerEl.classList.add(this.classPrefix + "-active");
          }
        };
        BrowserTransport2.prototype.displayRequest = function(request) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var sameDeviceRequest, returnUrl, sameDeviceUri, crossDeviceUri, isIdentity, title, subtitle, qrEl, linkEl, linkA, iframe_1, infoEl, infoTitle, infoSubtitle, actionEl, footnoteEl, footnoteLink, footnoteLink, logoEl;
            return tslib.__generator(this, function(_a) {
              this.setupElements();
              sameDeviceRequest = request.clone();
              returnUrl = generateReturnUrl();
              sameDeviceRequest.setInfoKey("same_device", true);
              sameDeviceRequest.setInfoKey("return_path", returnUrl);
              sameDeviceUri = sameDeviceRequest.encode(true, false);
              crossDeviceUri = request.encode(true, false);
              isIdentity = request.isIdentity();
              title = isIdentity ? "Login" : "Sign";
              subtitle = "Scan the QR-code with Anchor on another device or use the button to open Anchor on this device.";
              qrEl = this.createEl({ class: "qr" });
              try {
                qrEl.innerHTML = generate(crossDeviceUri);
              } catch (error) {
                console.warn("Unable to generate QR code", error);
              }
              linkEl = this.createEl({ class: "uri" });
              linkA = this.createEl({
                tag: "a",
                class: "button",
                href: crossDeviceUri,
                text: "Launch Anchor"
              });
              linkEl.appendChild(linkA);
              if (isFirefox() || isBrave()) {
                iframe_1 = this.createEl({
                  class: "wskeepalive",
                  src: "about:blank",
                  tag: "iframe"
                });
                linkEl.appendChild(iframe_1);
                linkA.addEventListener("click", function(event) {
                  event.preventDefault();
                  iframe_1.setAttribute("src", sameDeviceUri);
                });
              } else {
                linkA.addEventListener("click", function(event) {
                  event.preventDefault();
                  window.location.href = sameDeviceUri;
                });
              }
              infoEl = this.createEl({ class: "info" });
              infoTitle = this.createEl({ class: "title", tag: "span", text: title });
              infoSubtitle = this.createEl({ class: "subtitle", tag: "span", text: subtitle });
              infoEl.appendChild(infoTitle);
              infoEl.appendChild(infoSubtitle);
              actionEl = this.createEl({ class: "actions" });
              actionEl.appendChild(qrEl);
              actionEl.appendChild(linkEl);
              if (isIdentity) {
                footnoteEl = this.createEl({ class: "footnote", text: "Don't have Anchor yet? " });
                footnoteLink = this.createEl({
                  tag: "a",
                  target: "_blank",
                  href: "https://greymass.com/anchor",
                  text: "Download now"
                });
                footnoteEl.appendChild(footnoteLink);
              } else {
                footnoteEl = this.createEl({
                  class: "footnote",
                  text: "Anchor signing is brought to you by "
                });
                footnoteLink = this.createEl({
                  tag: "a",
                  target: "_blank",
                  href: "https://greymass.com",
                  text: "Greymass"
                });
                footnoteEl.appendChild(footnoteLink);
              }
              emptyElement(this.requestEl);
              logoEl = this.createEl({ class: "logo" });
              this.requestEl.appendChild(logoEl);
              this.requestEl.appendChild(infoEl);
              this.requestEl.appendChild(actionEl);
              this.requestEl.appendChild(footnoteEl);
              this.show();
              return [2];
            });
          });
        };
        BrowserTransport2.prototype.showLoading = function() {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var infoEl, infoTitle, infoSubtitle, logoEl;
            return tslib.__generator(this, function(_a) {
              this.setupElements();
              emptyElement(this.requestEl);
              infoEl = this.createEl({ class: "info" });
              infoTitle = this.createEl({ class: "title", tag: "span", text: "Loading" });
              infoSubtitle = this.createEl({
                class: "subtitle",
                tag: "span",
                text: "Preparing request..."
              });
              this.prepareStatusEl = infoSubtitle;
              infoEl.appendChild(infoTitle);
              infoEl.appendChild(infoSubtitle);
              logoEl = this.createEl({ class: "logo loading" });
              this.requestEl.appendChild(logoEl);
              this.requestEl.appendChild(infoEl);
              this.show();
              return [2];
            });
          });
        };
        BrowserTransport2.prototype.onRequest = function(request, cancel) {
          this.activeRequest = request;
          this.activeCancel = cancel;
          this.displayRequest(request).catch(cancel);
        };
        BrowserTransport2.prototype.onSessionRequest = function(session, request, cancel) {
          if (session.metadata.sameDevice) {
            request.setInfoKey("return_path", generateReturnUrl());
          }
          if (session.type === "fallback") {
            this.onRequest(request, cancel);
            if (session.metadata.sameDevice) {
              window.location.href = request.encode();
            }
            return;
          }
          this.activeRequest = request;
          this.activeCancel = cancel;
          this.setupElements();
          var timeout = session.metadata.timeout || 60 * 1e3 * 5;
          var deviceName = session.metadata.name;
          var infoTitle = this.createEl({ class: "title", tag: "span", text: "Sign" });
          var expires = this.getExpiration(request, timeout);
          var updateCountdown = function() {
            infoTitle.textContent = "Sign - " + countdownFormat(expires);
          };
          this.countdownTimer = setInterval(updateCountdown, 200);
          updateCountdown();
          var infoEl = this.createEl({ class: "info" });
          infoEl.appendChild(infoTitle);
          var subtitle;
          if (deviceName && deviceName.length > 0) {
            subtitle = "Please open your Anchor Wallet on your device \u201C" + deviceName + "\u201D to review and sign the transaction.";
          } else {
            subtitle = "Please review and sign the transaction in the linked wallet.";
          }
          var infoSubtitle = this.createEl({ class: "subtitle", tag: "span", text: subtitle });
          infoEl.appendChild(infoSubtitle);
          emptyElement(this.requestEl);
          var logoEl = this.createEl({ class: "logo" });
          this.requestEl.appendChild(logoEl);
          this.requestEl.appendChild(infoEl);
          this.show();
          if (session.metadata.sameDevice) {
            if (session.metadata.launchUrl) {
              window.location.href = session.metadata.launchUrl;
            } else if (isAppleHandheld()) {
              window.location.href = "anchor://link";
            }
          }
        };
        BrowserTransport2.prototype.sendSessionPayload = function(payload, session) {
          if (!session.metadata.triggerUrl || !session.metadata.sameDevice) {
            return false;
          }
          if (payload.array.length > 700) {
            return false;
          }
          window.location.href = session.metadata.triggerUrl.replace("%s", anchorLink.Base64u.encode(payload.array));
          return true;
        };
        BrowserTransport2.prototype.clearTimers = function() {
          if (this.closeTimer) {
            clearTimeout(this.closeTimer);
            this.closeTimer = void 0;
          }
          if (this.countdownTimer) {
            clearTimeout(this.countdownTimer);
            this.countdownTimer = void 0;
          }
        };
        BrowserTransport2.prototype.getExpiration = function(request, timeout) {
          if (timeout === void 0) {
            timeout = 0;
          }
          var expiration = request.getRawTransaction().expiration;
          if (expiration.equals(0)) {
            return new Date(Date.now() + timeout);
          } else {
            return expiration.toDate();
          }
        };
        BrowserTransport2.prototype.showFee = function(request, fee) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var cancelPromise, feeEl, feeTitle, feeSubtitle, feePart1, feeBypass, feePart2, feeDescription, logoEl, choiceEl, confirmEl, expireEl, expires, expireTimer, footnoteEl, footnoteLink, skipPromise, confirmPromise;
            var _this = this;
            return tslib.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  this.activeRequest = request;
                  cancelPromise = new Promise(function(resolve, reject) {
                    _this.activeCancel = function(reason) {
                      var error;
                      if (typeof reason === "string") {
                        error = new Error(reason);
                      } else {
                        error = reason;
                      }
                      error[AbortPrepare] = true;
                      reject(error);
                    };
                  });
                  this.setupElements();
                  emptyElement(this.requestEl);
                  feeEl = this.createEl({ class: "fee" });
                  feeTitle = this.createEl({ class: "title", tag: "div", text: "Transaction Fee" });
                  feeSubtitle = this.createEl({
                    class: "subtitle",
                    tag: "span",
                    text: "Your account lacks the network resources for this transaction and it cannot be covered for free."
                  });
                  feePart1 = this.createEl({
                    tag: "span",
                    text: "You can try to "
                  });
                  feeBypass = this.createEl({
                    tag: "a",
                    text: "proceed without the fee"
                  });
                  feePart2 = this.createEl({
                    tag: "span",
                    text: " or accept the fee shown below to pay for these costs."
                  });
                  feeDescription = this.createEl({
                    class: "subtitle",
                    tag: "span"
                  });
                  feeDescription.appendChild(feePart1);
                  feeDescription.appendChild(feeBypass);
                  feeDescription.appendChild(feePart2);
                  feeEl.appendChild(feeTitle);
                  feeEl.appendChild(feeSubtitle);
                  feeEl.appendChild(feeDescription);
                  logoEl = this.createEl({ class: "fuel" });
                  this.requestEl.appendChild(logoEl);
                  this.requestEl.appendChild(feeEl);
                  choiceEl = this.createEl({ class: "choice" });
                  confirmEl = this.createEl({ tag: "a", class: "button", text: "Accept Fee of " + fee });
                  expireEl = this.createEl({ tag: "span", text: "Offer expires in --:--" });
                  choiceEl.appendChild(expireEl);
                  choiceEl.appendChild(confirmEl);
                  feeEl.appendChild(choiceEl);
                  expires = this.getExpiration(request);
                  expireTimer = setInterval(function() {
                    expireEl.textContent = "Offer expires in " + countdownFormat(expires);
                    if (expires.getTime() < Date.now()) {
                      _this.activeCancel("Offer expired");
                    }
                  }, 200);
                  footnoteEl = this.createEl({
                    class: "footnote",
                    text: "Resources offered by "
                  });
                  footnoteLink = this.createEl({
                    tag: "a",
                    target: "_blank",
                    href: "https://greymass.com/en/fuel",
                    text: "Greymass Fuel"
                  });
                  footnoteEl.appendChild(footnoteLink);
                  this.requestEl.appendChild(footnoteEl);
                  skipPromise = waitForEvent(feeBypass, "click").then(function() {
                    var error = new Error("Skipped fee");
                    error[SkipFee] = true;
                    throw error;
                  });
                  confirmPromise = waitForEvent(confirmEl, "click");
                  this.show();
                  return [4, Promise.race([confirmPromise, skipPromise, cancelPromise]).finally(function() {
                    clearInterval(expireTimer);
                  })];
                case 1:
                  _a.sent();
                  return [2];
              }
            });
          });
        };
        BrowserTransport2.prototype.prepare = function(request, session) {
          return tslib.__awaiter(this, void 0, void 0, function() {
            var result, timeout, modified, fee, error_1, modified;
            var _this = this;
            return tslib.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  this.showLoading();
                  if (!this.fuelEnabled || !session || request.isIdentity()) {
                    return [2, request];
                  }
                  if (typeof session.metadata.cosignerVersion === "string" && compareVersion(session.metadata.cosignerVersion)) {
                    return [2, request];
                  }
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 5, , 6]);
                  result = fuel(request, session, function(message) {
                    if (_this.prepareStatusEl) {
                      _this.prepareStatusEl.textContent = message;
                    }
                  }, this.supportedChains, this.fuelReferrer);
                  timeout = new Promise(function(r) {
                    return setTimeout(r, 5e3);
                  }).then(function() {
                    throw new Error("API timeout after 5000ms");
                  });
                  return [4, Promise.race([result, timeout])];
                case 2:
                  modified = _a.sent();
                  fee = modified.getInfoKey("txfee");
                  if (!fee)
                    return [3, 4];
                  return [4, this.showFee(modified, String(fee))];
                case 3:
                  _a.sent();
                  _a.label = 4;
                case 4:
                  return [2, modified];
                case 5:
                  error_1 = _a.sent();
                  if (error_1[AbortPrepare]) {
                    this.hide();
                    throw error_1;
                  } else {
                    console.info("Skipping resource provider: " + (error_1.message || error_1));
                    if (error_1[SkipFee]) {
                      modified = request.clone();
                      modified.setInfoKey("no_fee", true, "bool");
                      return [2, modified];
                    }
                  }
                  return [3, 6];
                case 6:
                  return [2, request];
              }
            });
          });
        };
        BrowserTransport2.prototype.onSuccess = function(request) {
          var _this = this;
          if (request === this.activeRequest) {
            this.clearTimers();
            if (this.requestStatus) {
              this.setupElements();
              var infoEl = this.createEl({ class: "info" });
              var logoEl = this.createEl({ class: "logo" });
              logoEl.classList.add("success");
              var infoTitle = this.createEl({ class: "title", tag: "span", text: "Success!" });
              var subtitle = request.isIdentity() ? "Login completed." : "Transaction signed.";
              var infoSubtitle = this.createEl({ class: "subtitle", tag: "span", text: subtitle });
              infoEl.appendChild(infoTitle);
              infoEl.appendChild(infoSubtitle);
              emptyElement(this.requestEl);
              this.requestEl.appendChild(logoEl);
              this.requestEl.appendChild(infoEl);
              this.show();
              this.closeTimer = setTimeout(function() {
                _this.hide();
              }, 1.5 * 1e3);
            } else {
              this.hide();
            }
          }
        };
        BrowserTransport2.prototype.onFailure = function(request, error) {
          if (request === this.activeRequest && error["code"] !== "E_CANCEL") {
            this.clearTimers();
            if (this.requestStatus) {
              this.setupElements();
              var infoEl = this.createEl({ class: "info" });
              var logoEl = this.createEl({ class: "logo" });
              logoEl.classList.add("error");
              var infoTitle = this.createEl({
                class: "title",
                tag: "span",
                text: "Transaction Error"
              });
              var errorMessage = void 0;
              if (anchorLink.isInstanceOf(error, anchorLink.APIError)) {
                if (error.name === "eosio_assert_message_exception") {
                  errorMessage = error.details[0].message;
                } else if (error.details.length > 0) {
                  errorMessage = error.details.map(function(d) {
                    return d.message;
                  }).join("\n");
                } else {
                  errorMessage = error.message;
                }
              } else {
                errorMessage = error.message || String(error);
              }
              var infoSubtitle = this.createEl({
                class: "subtitle",
                tag: "span",
                text: errorMessage
              });
              infoEl.appendChild(infoTitle);
              infoEl.appendChild(infoSubtitle);
              emptyElement(this.requestEl);
              this.requestEl.appendChild(logoEl);
              this.requestEl.appendChild(infoEl);
              this.show();
            } else {
              this.hide();
            }
          } else {
            this.hide();
          }
        };
        BrowserTransport2.prototype.userAgent = function() {
          return "BrowserTransport/" + BrowserTransport2.version + " " + navigator.userAgent;
        };
        BrowserTransport2.version = "3.1.3";
        return BrowserTransport2;
      }();
      function waitForEvent(element, eventName, timeout) {
        return new Promise(function(resolve, reject) {
          var listener = function(event) {
            element.removeEventListener(eventName, listener);
            resolve(event);
          };
          element.addEventListener(eventName, listener);
          if (timeout) {
            setTimeout(function() {
              element.removeEventListener(eventName, listener);
              reject(new Error("Timed out waiting for " + eventName));
            }, timeout);
          }
        });
      }
      function countdownFormat(date) {
        var timeLeft = date.getTime() - Date.now();
        if (timeLeft > 0) {
          return new Date(timeLeft).toISOString().substr(14, 5);
        }
        return "00:00";
      }
      function emptyElement(el) {
        while (el.firstChild) {
          el.removeChild(el.firstChild);
        }
      }
      function generateReturnUrl() {
        if (isChromeiOS()) {
          return "googlechrome://";
        }
        if (isFirefoxiOS()) {
          return "firefox:://";
        }
        if (isAppleHandheld() && isBrave()) {
          return "brave://";
        }
        if (isAppleHandheld()) {
          var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
          var rv = window.location.href.split("#")[0] + "#";
          for (var i2 = 0; i2 < 8; i2++) {
            rv += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
          }
          return rv;
        }
        if (isAndroid() && isFirefox()) {
          return "android-intent://org.mozilla.firefox";
        }
        if (isAndroid() && isEdge()) {
          return "android-intent://com.microsoft.emmx";
        }
        if (isAndroid() && isOpera()) {
          return "android-intent://com.opera.browser";
        }
        if (isAndroid() && isBrave()) {
          return "android-intent://com.brave.browser";
        }
        if (isAndroid() && isAndroidWebView()) {
          return "android-intent://webview";
        }
        if (isAndroid() && isChromeMobile()) {
          return "android-intent://com.android.chrome";
        }
        return window.location.href;
      }
      function isAppleHandheld() {
        return /iP(ad|od|hone)/i.test(navigator.userAgent);
      }
      function isChromeiOS() {
        return /CriOS/.test(navigator.userAgent);
      }
      function isChromeMobile() {
        return /Chrome\/[.0-9]* Mobile/i.test(navigator.userAgent);
      }
      function isFirefox() {
        return /Firefox/i.test(navigator.userAgent);
      }
      function isFirefoxiOS() {
        return /FxiOS/.test(navigator.userAgent);
      }
      function isOpera() {
        return /OPR/.test(navigator.userAgent) || /Opera/.test(navigator.userAgent);
      }
      function isEdge() {
        return /Edg/.test(navigator.userAgent);
      }
      function isBrave() {
        return navigator["brave"] && typeof navigator["brave"].isBrave === "function";
      }
      function isAndroid() {
        return /Android/.test(navigator.userAgent);
      }
      function isAndroidWebView() {
        return /wv/.test(navigator.userAgent);
      }
      module.exports = BrowserTransport;
    }
  });

  // lib/index.js
  var require_lib = __commonJS({
    "lib/index.js"(exports) {
      "use strict";
      var __extends = exports && exports.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f2, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f2 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WaxAuthClient = exports.TransactionNotSignedError = void 0;
      var waxjs = __importStar(require_dist2());
      var eosjs_1 = require_dist3();
      var eosjs_jssig_1 = require_eosjs_jssig();
      var anchor_link_1 = __importDefault(require_anchor_link());
      var anchor_link_browser_transport_1 = __importDefault(require_anchor_link_browser_transport());
      var TransactionNotSignedError = function(_super) {
        __extends(TransactionNotSignedError2, _super);
        function TransactionNotSignedError2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.message = "Error while signing transaction";
          return _this;
        }
        return TransactionNotSignedError2;
      }(Error);
      exports.TransactionNotSignedError = TransactionNotSignedError;
      var WaxAuthClient = function() {
        function WaxAuthClient2(tryAutoLogin, rpcUrl, chainId) {
          if (tryAutoLogin === void 0) {
            tryAutoLogin = void 0;
          }
          this.waxAddress = "";
          this.wax = new waxjs.WaxJS(rpcUrl !== null && rpcUrl !== void 0 ? rpcUrl : "https://wax.greymass.com", void 0, tryAutoLogin, false);
          this.eosEndpoint = new eosjs_1.JsonRpc(rpcUrl !== null && rpcUrl !== void 0 ? rpcUrl : "https://wax.greymass.com");
          var signatureProvider = new eosjs_jssig_1.JsSignatureProvider([]);
          this.eosApi = new eosjs_1.Api({ rpc: this.eosEndpoint, signatureProvider });
          var transport = new anchor_link_browser_transport_1.default();
          this.link = new anchor_link_1.default({
            transport,
            chains: [
              {
                chainId: chainId !== null && chainId !== void 0 ? chainId : "1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4",
                nodeUrl: rpcUrl !== null && rpcUrl !== void 0 ? rpcUrl : "https://wax.greymass.com"
              }
            ]
          });
        }
        WaxAuthClient2.prototype.loginWax = function() {
          return __awaiter(this, void 0, void 0, function() {
            var waxAddress;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.wax.login()];
                case 1:
                  waxAddress = _a.sent();
                  if (!waxAddress)
                    throw new Error("Could not log in");
                  this.waxAddress = waxAddress;
                  return [2, waxAddress];
              }
            });
          });
        };
        WaxAuthClient2.prototype.loginAnchor = function() {
          return __awaiter(this, void 0, void 0, function() {
            var identity;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.link.login("MonkeyBattle")];
                case 1:
                  identity = _a.sent();
                  this.linkSession = identity.session;
                  this.waxAddress = identity.session.auth.actor.toString();
                  return [2, this.waxAddress];
              }
            });
          });
        };
        WaxAuthClient2.prototype.getTransactionData = function(nonce) {
          return {
            data: {
              actions: [
                {
                  account: "orng.wax",
                  name: "requestrand",
                  authorization: [
                    {
                      actor: this.waxAddress,
                      permission: "active"
                    }
                  ],
                  data: {
                    caller: this.waxAddress,
                    signing_value: nonce,
                    assoc_id: nonce
                  }
                }
              ]
            },
            options: {
              blocksBehind: 3,
              expireSeconds: 30,
              broadcast: false,
              sign: true
            }
          };
        };
        WaxAuthClient2.prototype.getProofWax = function(nonce) {
          return __awaiter(this, void 0, void 0, function() {
            var txData, transaction;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  txData = this.getTransactionData(nonce);
                  return [4, this.wax.api.transact(txData.data, txData.options)];
                case 1:
                  transaction = _a.sent();
                  if (!transaction.signatures[0]) {
                    throw new TransactionNotSignedError();
                  }
                  return [2, transaction];
              }
            });
          });
        };
        WaxAuthClient2.prototype.getProofAnchor = function(nonce) {
          return __awaiter(this, void 0, void 0, function() {
            var txData, tx;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!this.linkSession)
                    throw new Error("Link Session not defined");
                  txData = this.getTransactionData(nonce);
                  return [4, this.linkSession.transact(txData.data, txData.options)];
                case 1:
                  tx = _a.sent();
                  return [2, {
                    transaction: {
                      serializedTransaction: this.eosApi.serializeTransaction(JSON.parse(JSON.stringify(tx.transaction))),
                      signatures: tx.signatures
                    }
                  }];
              }
            });
          });
        };
        return WaxAuthClient2;
      }();
      exports.WaxAuthClient = WaxAuthClient;
    }
  });
  require_lib();
})();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @file {@link http://asmjs.org Asm.js} implementation of the {@link https://en.wikipedia.org/wiki/Advanced_Encryption_Standard Advanced Encryption Standard}.
 * @author Artem S Vybornov <vybornov@gmail.com>
 * @license MIT
 */
/**
 * Anchor Link Browser Transport v3.1.3
 * https://github.com/greymass/anchor-link-browser-transport
 *
 * @license
 * Copyright (c) 2020 Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
/**
 * Anchor Link v3.2.3
 * https://github.com/greymass/anchor-link
 *
 * @license
 * Copyright (c) 2020 Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
/**
 * EOSIO Core v0.4.6
 * https://github.com/greymass/eosio-core
 *
 * @license
 * Copyright (c) 2020 FFF00 Agents AB & Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
/**
 * EOSIO Signing Request v2.2.2
 * https://github.com/greymass/eosio-signing-request
 *
 * @license
 * Copyright  2021 Greymass Inc.
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the Software), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR
 * INTENDED FOR USE IN THE DESIGN, CONSTRUCTION, OPERATION OR
 * MAINTENANCE OF ANY MILITARY FACILITY.
 */
